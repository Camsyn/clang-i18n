# " '%0 %select{sink:|source:}1' must be with '%select{omp_cur_iteration - 1|omp_cur_iteration}1'"
HCB22E641D2E6: "'%0 %select{sink:|source:}1' 必须与 '%select{omp_cur_iteration - 1|omp_cur_iteration}1' 一起使用"
# " '%0' in a raw string literal delimiter is a C++2c extension"
H03B242298EB9: "'%0' 在原始字符串字面量分隔符中是C++2c扩展"
# " '%0' in a raw string literal delimiter is incompatible with standards before C++2c"
HFCBE1727461C: "'%0' 在原始字符串字面量分隔符中与C++2c之前的版本标准不兼容"
# '#else after #else'
H73FE4A6784FB: '在#else之后出现#else'
# '#else without #if'
HF8F50363B288: '没有 #if 的 #else'
# '#embed is a %select{C23|Clang}0 extension'
H799E9AA4840E: '#embed 是 %select{C23|Clang}0 的扩展'
# '#embed is incompatible with C standards before C23'
H1AF95A3E3444: '#embed 与 C23 之前的 C 标准不兼容'
# '#endif without #if'
H56B14C401F16: '缺少 #if 的 #endif'
# '#ident is a language extension'
H45C329EC97BC: '#ident 是语言扩展'
# '#import is a language extension'
H8768B3DA6294: '#import 是语言扩展'
# '#import of type library is an unsupported Microsoft feature'
H1CFAB9C94AB6: '#import 类型库是微软不支持的功能'
# '#include nested too deeply'
H21908EF6D74E: '#include 嵌套过深'
# "#include of '%0' not seen while attempting to %select{create|use}1 precompiled header"
H05355AF7456A: "未找到 '%0' 的#include，因为在尝试%select{创建|使用}1预编译头时"
# '#include resolved using non-portable Microsoft search rules as: %0'
HE0D8871EA3B6: '#include 使用非移植的微软搜索规则解析为: %0'
# '#include_next in file found relative to primary source file or found by absolute path; will search from start of include path'
H92850FB4B236: '#include_next 在文件中相对于主源文件或通过绝对路径找到；将从包含路径的开头重新搜索'
# '#include_next in primary source file; will search from start of include path'
HA1F5AE68D4B4: '#include_next 在主源文件中使用；将从包含路径的开头开始搜索'
# '#include_next is a language extension'
H924C2DCE9AC7: '#include_next 是一种语言扩展'
# '#line directive requires a positive integer argument'
H2EB091899FF1: '#line 指令需要一个正整数参数'
# '#line directive with zero argument is a GNU extension'
H05235496C826: '使用零参数的 #line 指令是 GNU 扩展'
# '#line number greater than 32767 is incompatible with C++98'
HF9B195DC3866: '#line 的行号大于 32767 与 C++98 不兼容'
# '#pragma %0(".drectve") has undefined behavior, use #pragma comment(linker, ...) instead'
H6CC89C517043: '#pragma %0(".drectve") 行为未定义，建议使用 #pragma comment(linker, ...)'
# '#pragma %0(pop, ...) failed: %1'
H1F44FB9E690A: '#pragma %0(pop, ...) 失败：%1'
# '#pragma align(packed) may not be compatible with objects generated with AIX XL C/C++'
H19CC6269DA45: '#pragma align(packed) 可能与AIX XL C/C++生成的对象不兼容'
# '#pragma entered here'
H4EB06A1F820E: '#pragma 从此处开始生效'
# "#pragma execution_character_set expected '%0'"
H3700F774625D: "#pragma execution_character_set 预期的参数为 '%0'"
# "#pragma execution_character_set expected 'push' or 'pop'"
HF944C9D4F311: "#pragma execution_character_set 预期接 'push' 或 'pop'"
# "#pragma execution_character_set invalid value '%0', only 'UTF-8' is supported"
HF7B9B86DDFE7: "#pragma execution_character_set 无效值 '%0'，仅支持 'UTF-8'"
# '#pragma hdrstop filename not supported, /Fp can be used to specify precompiled header filename'
HB20EE88D126A: '#pragma hdrstop 不支持指定文件名，可通过 /Fp 指定预编译头文件名'
# '#pragma hdrstop not seen while attempting to use precompiled header'
H482D12372789: '使用预编译头时未检测到 #pragma hdrstop'
# '#pragma once in main file'
H9D36B8727C26: '主文件中包含 #pragma once'
# '#pragma options align=reset failed: %0'
H3024180A558C: '#pragma options align=reset 失败: %0'
# '#pragma redefine_extname is applicable to external C declarations only; not applied to %select{function|variable}0 %1'
HAF6CFAD80C5F: '#pragma redefine_extname仅适用于外部C声明；不应用于%select{函数|变量}0 %1'
# '#pragma system_header ignored in main file'
HE58DA574E5C2: '#pragma system_header 在主文件中被忽略'
# '#pragma visibility pop with no matching #pragma visibility push'
H3EDA32C5E985: '#pragma visibility pop 没有对应的 #pragma visibility push'
# '#pragma visibility push with no matching #pragma visibility pop'
HB15E579A68AB: '#pragma visibility push 没有对应的 #pragma visibility pop'
# "#pragma warning expected '%0'"
HE762E253E06E: "#pragma warning 预期 '%0'"
# "#pragma warning expected 'push', 'pop', 'default', 'disable', 'error', 'once', 'suppress', 1, 2, 3, or 4"
HBCB4550F177A: "#pragma warning 预期 'push', 'pop', 'default', 'disable', 'error', 'once', 'suppress', 1, 2, 3 或 4"
# '#pragma warning expected a warning number'
HB9A465F10016: '#pragma warning 预期一个警告编号'
# '#pragma warning(push, level) requires a level between 0 and 4'
H99A37FD4A6D8: '#pragma warning(push, level) 需要级别在0到4之间'
# '#warning is a %select{C23|C++23}0 extension'
H0F157EC51CD6: '#warning 是 %select{C23|C++23}0 的扩展'
# '#warning is incompatible with C standards before C23'
H447994BFEB83: '#warning 与 C23 之前的 C 标准不兼容'
# '#warning is incompatible with C++ standards before C++23'
H42FA898C6606: '#warning 与 C++23 之前的 C++ 标准不兼容'
# '%0'
HDEB42D2F46D5: '%0'
# '%0 %select{parameter|return}1 type is unsupported; support for vector types for this target is introduced in %2'
HDC6BFCFF388E: '%0 %select{参数|返回}1 类型不受支持；此目标的向量类型支持在 %2 中引入'
# "%0 '%1' is acquired exclusively and shared in the same scope"
H7390A9DF88C0: "%0 '%1' 在同一作用域中被独占获取和共享"
# "%0 '%1' is not held on every path through here"
H6674AA570899: "%0 '%1' 在所有路径上都未被持有"
# "%0 '%1' is still held at the end of function"
HC378A7D8C58E: "%0 '%1' 在函数结束时仍然被持有"
# "%0 '%1' must be acquired before '%2'"
H1AA537616F4E: "%0 '%1' 必须在 '%2' 之前获取"
# "%0 '%2' not managed by '%1'"
H7EC62D1C1AF9: "%0 '%2' 未被 '%1' 管理"
# "%0 (%1) exceeds limit (%2) in '%3'"
HE73AA4C10244: "%0 (%1) 超过 '%3' 中的限制 (%2)"
# '%0 acquired here'
HEA3E3310E736: '%0 在此处获取'
# '%0 additional files entered using a total of %1B (%human1B) of space'
HBB08F5A2D9D4: '%0 使用总共 %1B (%human1B) 空间输入了附加文件'
# '%0 and %1%select{ attributes|}2 are not compatible'
H3E0737276230: '%0 和 %1%select{属性|}2 不兼容'
# '%0 appears multiple times in clauses on the same declare target directive'
H71D418F6E9B9: '%0 在同一 declare 目标指令的子句中多次出现'
# '%0 applied to an expression is a GNU extension'
HE4B8DDF4E86C: '%0 应用于表达式是一个 GNU 扩展'
# '%0 argument must be a constant unsigned integer expression'
HD9AE42B82C9D: '%0 参数必须是常量无符号整数表达式'
# '%0 argument of MTE builtin function must be a null or a pointer (%1 invalid)'
H1FAF65C9963B: '%0 参数必须是空指针或指针类型（%1 无效）'
# '%0 argument of MTE builtin function must be a pointer (%1 invalid)'
H0BF1182D2AC8: '%0 参数必须是指针类型（%1 无效）'
# '%0 argument of MTE builtin function must be an integer type (%1 invalid)'
H2B10B0C97CC4: '%0 参数必须是整数类型（%1 无效）'
# '%0 argument to %1 must be of vector type'
H61B90BC8950E: '%0 参数传递给 %1 时必须为向量类型'
# '%0 attribute %plural{0:takes no arguments|1:takes one argument|:requires exactly %1 arguments}1'
H8625FD5B48BC: '%0 属性 %plural{0:不需要参数|1:需要一个参数|:需要恰好%1个参数}1'
# '%0 attribute applied to non-RVV type %1'
H49243AEFBCDB: '%0 属性应用于非RVV类型%1'
# '%0 attribute applied to non-SVE type %1'
H7CA8225CCF33: '%0 属性应用于非SVE类型%1'
# "%0 attribute applies to function parameters only if their type is a reference to a 'scoped_lockable'-annotated type"
H8F04340A3021: "%0 属性仅适用于其类型是引用带有'scoped_lockable'注解类型的函数参数"
# "%0 attribute argument '%1' not supported on a global variable"
H12B4D27D7798: "%0 属性参数'%1'不支持全局变量"
# '%0 attribute argument is invalid: %select{max must be 0 since min is 0|min must not be greater than max}1'
HD3E478873102: '%0 属性参数无效：%select{max必须设为0，因为min已经是0|min不能大于max}1'
# '%0 attribute argument may only refer to a function parameter of integer type'
H05E563701DF2: '%0 属性参数只能引用整数类型的函数参数'
# '%0 attribute argument must be a string literal specifying a Swift function name'
H056A97564B83: '%0 属性参数必须是一个指定Swift函数名的字符串字面量'
# '%0 attribute argument not supported: %1'
HB519160711B1: '%0 属性参数不支持：%1'
# "%0 attribute can only be applied in a context annotated with 'capability' attribute"
H9411040D8420: "%0 属性只能应用于标注有'capability'属性的上下文中"
# '%0 attribute can only be applied once per parameter'
H3C2BAB720741: '%0 属性每个参数只能应用一次'
# '%0 attribute can only be applied to a %select{function|method}1 with an error parameter'
H5477D07BA320: '%0 属性只能应用于带有错误参数的%select{函数|方法}1'
# '%0 attribute can only be applied to a ARM, HLSL or RISC-V builtin'
H63E9059C2A3F: '%0 属性只能应用于ARM、HLSL或RISC-V内置函数'
# '%0 attribute can only be applied to instance variables or properties'
H30E90B5958C9: '%0 属性只能应用于实例变量或属性'
# "%0 attribute cannot be applied to %select{a function parameter|a variable with 'register' storage class|a 'catch' variable|a bit-field|an enumeration}1"
HD202D2E58321: "%0 属性不能应用于%select{函数参数|具有'register'存储类的变量|'catch'变量|位域|枚举}1"
# '%0 attribute cannot be applied to %select{methods in protocols|dealloc}1'
HC18046C82752: '%0 属性不能应用于%select{协议中的方法|dealloc}1'
# '%0 attribute cannot be applied to a %select{function|method}1 with no parameters'
H9F395B21D226: '%0 属性不能应用于没有参数的%select{函数|方法}1'
# '%0 attribute cannot be applied to a module'
H6CF918E64873: '%0 属性不能应用于模块'
# '%0 attribute cannot be applied to a module import'
H3AD0DE140148: '%0 属性不能应用于模块导入'
# '%0 attribute cannot be applied to non-static member functions'
HCA6FA0E6C0E4: '%0 属性不能应用于非静态成员函数'
# '%0 attribute cannot be applied to sizeless type %1'
H60D82BB85EBA: '%0 属性不能应用于大小未知类型%1'
# '%0 attribute cannot be applied to this declaration'
H1A106E97EE94: '%0 属性不能应用于此声明'
# '%0 attribute cannot be repeated'
H1FB2864F8926: '%0 属性不能重复使用'
# '%0 attribute cannot be used from %select{a block|an Objective-C function|this context}1'
HFCD2CCA9A22B: '%0 属性不能从%select{块|Objective-C函数|此上下文}1使用'
# '%0 attribute cannot be used with pointers to members'
H828AE7C76F14: '%0 属性不能用于成员指针'
# "%0 attribute cannot specify more than one 'self:' parameter"
HC2B60D257432: "%0 属性不能指定超过一个'self:'参数"
# '%0 attribute does not appear on the first declaration'
HE84901B6BFC0: '%0 属性未出现在首次声明中'
# '%0 attribute expression never produces a constant expression'
H6DB854C2324C: '%0 属性表达式无法生成常量表达式'
# "%0 attribute for 'subscript' getter cannot have a 'newValue:' parameter"
HEBB5613EEF15: "%0 属性的'subscript'获取器不能包含'newValue:'参数"
# "%0 attribute for 'subscript' must %select{be a getter or setter|have at least one parameter|have a 'self:' parameter}1"
H445CA4D5B31B: "%0 属性的'subscript'必须%select{是getter或setter|至少有一个参数|具有'self:'参数}1"
# "%0 attribute for 'subscript' setter cannot have multiple 'newValue:' parameters"
H2C95053B8BED: "%0 'subscript' setter 的属性不能有多个 'newValue:' 参数"
# "%0 attribute for 'subscript' setter must have a 'newValue:' parameter"
HD3A5819D09C5: "%0 'subscript' setter 的属性必须包含一个 'newValue:' 参数"
# "%0 attribute for getter must not have any parameters besides 'self:'"
HA628A2E87201: "%0 getter 属性除了 'self:' 之外不能有其他参数"
# '%0 attribute for setter must have one parameter for new value'
H349FB00769DE: '%0 setter 属性必须有一个新值参数'
# '%0 attribute has invalid identifier for the %select{base|context|parameter}1 name'
HC37D287D1C6D: '%0 属性为 %select{base|context|parameter}1 名称提供了无效的标识符'
# '%0 attribute has no effect on defaulted or deleted functions'
HDFBEF81FB2EF: '%0 属性对默认或已删除的函数无效'
# '%0 attribute ignored'
HCD3BE326728C: '%0 属性被忽略'
# '%0 attribute ignored because Clang does not yet support this attribute signature'
HB0B12C0AB26E: '因 Clang 尚不支持该属性签名，%0 属性被忽略'
# '%0 attribute ignored for field of type %1'
HBE46E60BBC6F: '类型 %1 的字段上，%0 属性被忽略'
# '%0 attribute ignored on a non-definition declaration'
H208A7E24C5FA: '在非定义声明上，%0 属性被忽略'
# '%0 attribute ignored on inline function'
H96102C6ED34D: '在内联函数上，%0 属性被忽略'
# '%0 attribute ignored on local class%select{| member}1'
HFF01D57072C2: '在局部类%select{| 成员}1 上，%0 属性被忽略'
# '%0 attribute ignored when parsing type'
HD37333D19CA5: '解析类型时，%0 属性被忽略'
# '%0 attribute is deprecated and ignored in %1'
HEFE3D7F726A1: '%0 属性在 %1 中已被弃用并忽略'
# '%0 attribute is ignored because %1 is not a function pointer'
H4475E1120012: '因 %1 不是函数指针，%0 属性被忽略'
# '%0 attribute is ignored because there exists no call expression inside the statement'
H7E65A2DFE3B4: '因语句内不存在调用表达式，%0 属性被忽略'
# '%0 attribute is ignored in non-aggregate type %1'
HDDFDF4BAA343: '在非聚合类型 %1 中，%0 属性被忽略'
# '%0 attribute is invalid for the implicit this argument'
H2D89A7CAF8E9: '%0 属性对隐式 this 参数无效'
# '%0 attribute is missing parameter label clause'
HD08320D115DE: '%0 属性缺少参数标签子句'
# '%0 attribute is not supported in %select{C|C++|Objective-C}1'
H40645DEA04DB: '%0 属性在 %select{C|C++|Objective-C}1 中不受支持'
# "%0 attribute is not supported on '%1'"
H46128D024C15: "%0 属性不受 '%1' 支持"
# '%0 attribute is not supported on targets missing %1; specify an appropriate -march= or -mcpu='
H8B26915B3400: '%0 属性在缺少 %1 的目标上不受支持；请指定适当的 -march= 或 -mcpu='
# '%0 attribute is not yet supported on AIX'
H09BE0575B2ED: '%0 属性在 AIX 上尚未支持'
# '%0 attribute is only allowed on empty statements'
H523B4DCA9F57: '%0 属性仅允许用于空语句'
# '%0 attribute is permitted on definitions only'
H7BE8228ED388: '%0 属性仅允许用于定义'
# "%0 attribute isn't implemented by this Objective-C runtime"
H4540FD7320B4: '%0 属性未在此 Objective-C 运行时中实现'
# '%0 attribute may not be used with no-return-attribute functions'
H9936965C5605: '%0 属性不可与带有 no-return-attribute 的函数一起使用'
# '%0 attribute may not be used with variadic functions'
HC4348E6FE2CB: '%0 属性不可与可变参数函数一起使用'
# '%0 attribute minimum and maximum arguments are equal'
HCEAC369F8447: '%0 属性的最小和最大参数值相等'
# "%0 attribute must be applied to a %select{function|method}1 annotated with non-'none' attribute 'swift_async'"
H1EED532B31A7: '%0 属性必须应用于带有非"none" "swift_async"属性的%select{函数|方法}1'
# '%0 attribute must be greater than 0'
H2544E0569FB3: '%0 属性必须大于 0'
# '%0 attribute on entry function does not match the target profile'
H789CC95F4AD2: '%0 属性在入口函数中与目标配置文件不匹配'
# '%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer|pointer/reference-to-OSObject-pointer}1 parameters'
H5089073C0897: '%0 属性仅适用于%select{Objective-C 对象|指针|指向 CF 指针的指针|指向 OSObject 指针的指针/引用}1 参数'
# '%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer}1 parameters'
HF1529765C253: '%0 属性仅适用于%select{Objective-C 对象|指针|指向 CF 指针的指针}1 参数'
# '%0 attribute only applies to %select{functions|methods|properties}1 that return %select{an Objective-C object|a pointer|a non-retainable pointer}2'
H0AEFAD59CD2C: '%0 属性仅适用于返回%select{Objective-C 对象|指针|不可保留指针}2的%select{函数|方法|属性}1'
# '%0 attribute only applies to %select{pointer|integer}1 arguments'
H3971FB6B9374: '%0 属性仅适用于%select{指针|整数}1参数'
# '%0 attribute only applies to a pointer or reference (%1 is invalid)'
HC8C4E00A6BE4: '%0 属性仅适用于指针或引用（%1 无效）'
# '%0 attribute only applies to return values that are pointers'
H83B4DE3C5663: '%0 属性仅适用于返回值为指针的情况'
# '%0 attribute only applies to return values that are pointers or references'
HA603B89762A9: '%0 属性仅适用于返回值为指针或引用的情况'
# '%0 attribute only applies to%select{| constant}1 pointer arguments'
H1E90BC4B3746: '%0 属性仅适用于%select{|常量}1指针参数'
# '%0 attribute parameter %1 is negative and will be ignored'
HB94334A9F06D: '%0 属性的参数 %1 为负数，将被忽略'
# '%0 attribute parameter %1 is out of bounds'
H9C7D1C19F9DB: '%0 属性的参数 %1 超出范围'
# '%0 attribute parameter %1 is out of bounds: %plural{0:no parameters to index into|1:can only be 1, since there is one parameter|:must be between 1 and %2}2'
HF05125794562: '%0 属性的参数 %1 超出范围：%plural{0:没有参数可供索引|1:只能是1，因为只有一个参数|:必须在1和%2之间}2'
# '%0 attribute parameter types do not match: parameter %1 of function %2 has type %3, but parameter %4 of function %5 has type %6'
H4FBE5E81E84C: '%0 属性的参数类型不匹配：函数 %2 的参数 %1 类型为 %3，而函数 %5 的参数 %4 类型为 %6'
# '%0 attribute parameters do not match the previous declaration'
HBB1E6D667EEA: '%0 属性的参数与之前的声明不匹配'
# '%0 attribute references function %1, which %plural{0:takes no arguments|1:takes one argument|:takes exactly %2 arguments}2'
HC6916839EF90: '%0 属性引用函数 %1，该函数%plural{0:没有参数|1:有一个参数|:恰好有%2个参数}2'
# '%0 attribute references parameter %1, but the function %2 has only %3 parameters'
H95C6EBBF3D05: '%0 属性引用参数 %1，但函数 %2 只有 %3 个参数'
# '%0 attribute requires %select{int or bool|an integer constant|a string|an identifier}1'
H4D660FD4970F: '%0 属性需要%select{int或bool类型|一个整型常量|一个字符串|一个标识符}1'
# '%0 attribute requires a %select{positive|non-negative}1 integral compile time constant expression'
H88B2A4A1C6F1: '%0 属性需要一个%select{正数|非负数}1 类型的整型编译时常量表达式'
# '%0 attribute requires an integer argument which is a constant power of two between %1 and %2 inclusive; provided argument was %3'
HBE3281153430: '%0 属性需要一个介于 %1 和 %2 之间的2的常量幂整数参数；提供的参数是 %3'
# "%0 attribute requires arguments whose type is annotated with 'capability' attribute; type here is %1"
H6A637254187D: '%0 属性需要参数类型带有"capability"属性；此处的类型是 %1'
# '%0 attribute requires integer constant between %1 and %2 inclusive'
HEAC447E72E0E: '%0 属性需要介于 %1 和 %2 之间的整型常量'
# '%0 attribute requires parameter %1 to be %select{int or bool|an integer constant|a string|an identifier|a constant expression|a builtin function}2'
H410FC41452B2: '%0 属性要求参数 %1 为%select{int或bool类型|一个整型常量|一个字符串|一个标识符|一个常量表达式|一个内置函数}2'
# '%0 attribute requires that both caller and callee functions have a prototype'
H16EEA1808E57: '%0 属性要求调用函数和被调用函数都具有原型声明'
# '%0 attribute requires that the return value is the result of a function call'
H374EE3F9FB1E: '%0 属性要求返回值必须是函数调用的结果'
# '%0 attribute takes at least %1 argument%s1'
HADEF6E200C29: '%0 属性至少需要 %1 个参数%s1'
# '%0 attribute takes no more than %1 argument%s1'
H19CAD7127F59: '%0 属性最多允许 %1 个参数%s1'
# "%0 attribute with '%1' convention can only be applied to a %select{function|method}2 returning %select{an integral type|a pointer}3"
HD834E8E626F3: '%0 属性使用"%1"约定时只能应用于返回%select{整型类型|指针}3的%select{函数|方法}2'
# "%0 attribute with '%1' convention must have an integral-typed parameter in completion handler at index %2, type here is %3"
HA510BC647385: '%0 属性使用"%1"约定时，完成处理程序在索引 %2 处必须具有整型参数，此处的类型为 %3'
# "%0 attribute with 'nonnull_error' convention can only be applied to a %select{function|method}1 with a completion handler with an error parameter"
HB02ECE112485: '%0 属性使用"nonnull_error"约定时只能应用于具有带有错误参数的完成处理程序的%select{函数|方法}1'
# '%0 attribute without capability arguments can only be applied to non-static methods of a class'
H1A6503974C19: '%0 属性在没有能力参数时只能应用于类的非静态方法'
# "%0 attribute without capability arguments refers to 'this', but %1 isn't annotated with 'capability' or 'scoped_lockable' attribute"
H4FEFB6A31DD8: "%0 属性引用了 'this'，但 %1 未标注 'capability' 或 'scoped_lockable' 属性"
# "%0 availability is ignored without a valid 'SDKSettings.json' in the SDK"
H44C1644AD110: '%0 可用性因 SDK 中缺少有效 "SDKSettings.json" 而被忽略'
# '%0 begins here'
H3AEE48765E33: '%0 开始于此处'
# '%0 bridges to %1, not %2'
HF3302ECAA235: '%0 桥接至 %1 而非 %2'
# "%0 byte order mark detected in '%1', but encoding is not supported"
H4406B8F3C975: "%0 在 '%1' 中检测到字节序标记，但当前编码不支持该标记"
# '%0 calling convention is not supported %select{for this target|on variadic function|on constructor/destructor|on builtin function}1'
HEDD5B64E1439: '%0 调用约定 %select{不适用于此目标|不适用于可变参数函数|不适用于构造函数/析构函数|不适用于内置函数}1'
# '%0 can appear only once in a capture list'
H17CCB4C13684: '捕获列表中 %0 只能出现一次'
# "%0 cannot appear before '::' because it is not a class%select{ or namespace|, namespace, or enumeration}1; did you mean ':'?"
H95866D5EB8E3: "%0 不能出现在 '::' 前，因为它不是类%select{或命名空间|、命名空间或枚举}1；是否应改为使用“:”？"
# '%0 cannot appear here'
H7B57CA319863: '%0 不能出现在此处'
# '%0 cannot appear here, place it after "%select{class|struct|interface|union|enum}1" to apply it to the type declaration'
H2B1210C2EB9F: '%0 不能出现在这里，将其放在 "%select{类|结构体|接口|联合|枚举}1" 后面以将其应用于类型声明'
# '%0 cannot be a template'
H09B919FC579B: '%0 不能是模板'
# '%0 cannot be applied to a module'
HED10CE4A1D68: '%0 不能应用于模块'
# '%0 cannot be applied to a module import'
HE5DD1D7C816C: '%0 不能应用于模块导入'
# '%0 cannot be captured because it does not have automatic storage duration'
HBA5ABB384993: '%0 无法被捕获，因为它没有自动存储期'
# "%0 cannot be declared 'weak_import' because its definition has been provided"
HE0A69210AAA7: "已提供 %0 的定义，因此其不能声明为 'weak_import'"
# '%0 cannot be declared consteval'
H16F780D20CBE: '%0 不能声明为 consteval'
# '%0 cannot be declared inside a namespace'
H52C308DDDEAD: '%0 不能声明在命名空间内'
# '%0 cannot be declared static in global scope'
HE95F0FB30315: '全局作用域中的 %0 不能声明为 static'
# '%0 cannot be defined in a condition'
H4D213A54365F: '%0 不能在条件中定义'
# '%0 cannot be defined in a parameter type'
H73A9723882B3: '%0 不能在参数类型中定义'
# '%0 cannot be defined in a type alias template'
H481A328DC270: '%0 不能在类型别名模板中定义'
# '%0 cannot be defined in a type specifier'
H66CFEB606651: '%0 不能在类型说明符中定义'
# '%0 cannot be defined in an enumeration'
H9015777D8EDA: '%0 不能在枚举中定义'
# '%0 cannot be defined in the result type of a function'
HBCF321DF1229: '%0 不能在函数的返回类型中定义'
# '%0 cannot be specialized%select{|: %2}1'
H2F24480223D6: '%0 不能被特化%select{|: %2}1'
# '%0 cannot be the name of a parameter'
H86909FCB5AFA: '%0 不能作为参数名'
# '%0 cannot be the name of a variable or data member'
H97536A002E4D: '%0 不能作为变量或数据成员的名称'
# '%0 cannot be used as the type of a kernel parameter'
H4649232301DD: '%0 不能用作内核参数的类型'
# '%0 cannot bridge to %1'
H223FE9046675: '%0 无法桥接到 %1'
# '%0 cannot have a dependent return type; use %1 instead'
H622C863D5758: '%0 不能具有依赖返回类型；请改用 %1'
# '%0 cannot take a dependent type as first parameter; use %1 instead'
HA474A1ABAD69: '%0 不能将依赖类型作为第一个参数；请改用 %1'
# '%0 cannot take a dependent type as first parameter; use size_t (%1) instead'
H54AA7CDA647F: '%0 不能将依赖类型作为第一个参数；请改用 size_t (%1)'
# "%0 cannot use 'super' because it is a root class"
HCB7FBC7D0FE7: "%0 不能使用 'super'，因为它是一个根类"
# '%0 causes a section type conflict with %1'
HC2A4EF19BEEF: '%0 与 %1 存在段类型冲突'
# '%0 clause previously used here'
HB8E770744C3C: '此处之前使用过 %0 子句'
# '%0 clause should not be followed by arguments; tokens will be ignored'
HC180595F601D: '%0 子句不应跟有参数；将忽略这些标记'
# '%0 command failed due to signal (use -v to see invocation)'
H6D5905ABD1C8: '%0 命令因信号而失败（使用 -v 查看调用信息）'
# '%0 command failed with exit code %1 (use -v to see invocation)'
H4949FF66B370: '%0 命令以退出码 %1 失败（使用 -v 查看调用信息）'
# '%0 currently has no effect on a using declaration'
HF72F1D74D1D1: '当前 %0 对 using 声明没有效果'
# '%0 declared as a reference to a reference'
H6B7D1478B098: '%0 被声明为引用的引用'
# '%0 declared here'
HF5B76F9106FA: '%0 在此处声明'
# '%0 defined here'
HAF9360C4877D: '%0 在此处定义'
# "%0 differs in AST file '%1' vs. current file"
H2B8E15EA63E3: "%0 在AST文件 '%1' 与当前文件中不一致"
# '%0 dimension is outside the allowed range [1, %1]'
H082ED204EAD0: '%0 维度超出允许的范围 [1, %1]'
# '%0 does not have a member named %1'
H9A87A68C56D5: '%0 没有名为 %1 的成员'
# '%0 does not have a member named %1; did you mean %2?'
HB35AA56437F0: '%0 没有名为 %1 的成员；您是指 %2 吗？'
# '%0 does not identify a valid pointer authentication key for the current target'
H788DB99BF41E: '%0 指定的指针认证密钥对当前目标无效'
# '%0 does not name a template but is followed by template arguments'
H33B12988518D: '%0 不是模板名称，但随后跟有模板参数'
# '%0 does not name a template but is followed by template arguments; did you mean %1?'
H4461F93F60D6: '%0 不是模板名称，但随后跟有模板参数；您是指 %1 吗？'
# '%0 does not refer to a type name in pseudo-destructor expression; expected the name of type %1'
H439E7BF75B12: '%0 在伪析构表达式中不指向类型名称；预期应为类型 %1 的名称'
# '%0 does not refer to a value'
H21D124F292F8: '%0 未引用有效值'
# '%0 does not refer to the name of a parameter pack'
H84CFFC360255: '%0 未引用参数包的名称'
# '%0 does not refer to the name of a parameter pack; did you mean %1?'
H833E3DFEF469: '%0 未引用参数包的名称；您是指 %1 吗？'
# "%0 does not support the '%1' %select{type qualifier|storage class specifier}2"
H0775C84F5711: "%0 不支持 '%1' %select{类型限定符|存储类说明符}2"
# "%0 does not support the option '%1'"
HCC61DEFC8375: "%0 不支持选项 '%1'"
# '%0 has C-linkage specified, but returns incomplete type %1 which could be incompatible with C'
H36CF04C5AD21: '%0 指定了C链接，但返回不完整类型 %1，这可能与C不兼容'
# '%0 has C-linkage specified, but returns user-defined type %1 which is incompatible with C'
H33D15C91E278: '%0 指定了C链接，但返回用户定义类型 %1，这与C不兼容'
# '%0 has a non-throwing exception specification but can still throw'
H115C08CCD253: '%0 声明了无抛出异常规范，但仍可能抛出异常'
# '%0 has been explicitly marked %select{unavailable|deleted|deprecated}1 here'
H8BC49D6916A0: '%0 已在此处显式标记为 %select{不可用|已删除|已弃用}1'
# '%0 has been marked as being introduced in %1 %2 %select{|in %5 environment }4here, but the deployment target is %1 %3%select{| %6 environment }4'
H0D47117119FF: '%0 被标记为在 %1 %2 %select{|%5 环境中}4 引入，但部署目标是 %1 %3%select{|%6 环境}4'
# "%0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{no super class|super class with type %5}4|instance variable '%4' access control is %select{|@private|@protected|@public|@package}5}3"
H8AC2F2F00B17: "%0 在不同模块中有不同定义；第一个差异是 %select{模块 '%2' 的定义|在这里定义}1 发现 %select{%select{没有基类|基类类型为 %5}4|实例变量 '%4' 的访问控制是 %select{|@private|@protected|@public|@package}5}3"
# '%0 has lower precedence than %1; %1 will be evaluated first'
HFFF20BD3A51A: '%0 的优先级比 %1 低；将先计算 %1'
# '%0 has no out-of-line virtual method definitions; its vtable will be emitted in every translation unit'
HF80DD309C805: '%0 没有外部虚方法定义；它的虚表将在每个翻译单元中生成'
# '%0 has unknown return type; cast the call to its declared return type'
H98622C79AEFA: '%0 的返回类型未知；将其调用转换为声明的返回类型'
# '%0 has unknown type, which is not supported for this kind of declaration'
H62292154D971: '%0 的类型未知，这种类型的声明不受支持'
# '%0 has unknown type; cast it to its declared type to use it'
HB47BA1F1A811: '%0 的类型未知；将其转换为声明的类型后再使用'
# '%0 has virtual functions but non-virtual destructor'
HE7971ACC4D33: '%0 有虚函数但没有虚析构函数'
# '%0 in capture list does not name a variable'
HDBFB52EAD640: '%0 在捕获列表中未命名变量'
# '%0 is a %select{struct|interface|union|class|enum}1 here'
H03376E721EF2: '%0 这里是一个 %select{结构体|接口|联合体|类|枚举}1'
# '%0 is a builtin with type %1'
HF5D497B12074: '%0 是类型为 %1 的内置函数'
# '%0 is a core feature in %select{OpenCL C|C++ for OpenCL}1 version %2 but not supported on this target'
HB2B1D8E45B2F: '%0 是 %select{OpenCL C|OpenCL 的 C++}1 版本 %2 的核心特性，但此目标不支持'
# '%0 is a large (%1 bytes) pass-by-value argument; pass it by reference instead ?'
H3328D1D6C300: '%0 是一个大（%1 字节）的按值传递参数；建议改为引用传递？'
# '%0 is a reserved attribute identifier'
HA23BACAA2167: '%0 是保留的属性标识符'
# '%0 is a reserved name for a module'
H539795173149: '%0 是保留的模块名称'
# '%0 is an %select{unsafe pointer used for buffer access|unsafe buffer that does not perform bounds checks}1'
HD2DA3F5D5287: '%0 是 %select{用于缓冲区访问的不安全指针|不执行边界检查的不安全缓冲区}1'
# '%0 is an immediate %select{function|constructor}5 because %select{its body|the%select{| default}7 initializer of %8}6 %select{evaluates the address of %select{an immediate|a consteval}2 function %1|contains a call to %select{an immediate|a consteval}2 %select{function|constructor}4 %1 and that call is not a constant expression}3'
H2D11120EB0CD: '%0 是一个 %select{立即函数|立即构造函数}5 因为 %select{其函数体|%select{|默认}7 的 %8 初始化器}6 %select{计算了 %select{一个立即|consteval}2 函数 %1 的地址|包含对 %select{立即|consteval}2 %select{函数|构造函数}4 %1 的调用，而该调用不是常量表达式}3'
# '%0 is an implicit parameter'
H18B31C3BE2ED: '%0 是一个隐式参数'
# '%0 is an incomplete type'
H23B2652D4493: '%0 是一个不完整类型'
# '%0 is an invalid name for a module'
H04BC4C58E825: '%0 是无效的模块名称'
# "%0 is currently enabled, but was not in the AST file '%1'"
H4A72404ECC3D: "%0 当前已启用，但在 AST 文件 '%1' 中并未启用"
# '%0 is defined here; did you mean %1?'
H3B788FE6A551: '%0 在此处定义；您是指 %1 吗？'
# '%0 is deprecated'
HFB3435CCEF09: '%0 已弃用'
# '%0 is deprecated: %1'
HBBBFE1910250: '%0 已弃用：%1'
# '%0 is expected to be a non-type template, but instantiated to a %select{class|type alias}1 template'
H0D2CA33F6096: '%0 应该是一个非类型模板，但实例化为一个 %select{类|类型别名}1 模板'
# '%0 is incompatible with selectors that return a %select{struct|union|vector}1 type'
HF29FF6DC9511: '%0 与返回 %select{结构体|联合|向量}1 类型的选择器不兼容'
# '%0 is incomplete'
HE1EB0B2A5FDF: '%0 是不完整的类型'
# "%0 is missing exception specification '%1'"
HFEFEB7B90D08: "%0 缺少异常说明 '%1'"
# '%0 is no longer a pack expansion but a pack indexing type; add a name to specify a pack expansion'
H52ECBB1B9A17: '%0 现在是打包索引类型而非打包扩展；请添加名称以指定打包扩展'
# '%0 is not a class type'
H5598919CD04A: '%0 不是类类型'
# '%0 is not a class%select{ or namespace|, namespace, or enumeration}1'
H6791F56D81BD: '%0 不是类%select{或命名空间|、命名空间或枚举类型}1'
# '%0 is not a direct base of %1, cannot inherit constructors'
H9090F9B02C3F: '%0 不是 %1 的直接基类，无法继承构造函数'
# '%0 is not a global variable, static local variable or static data member'
HC570BF566E38: '%0 不是全局变量、静态局部变量或静态数据成员'
# '%0 is not a global variable, static local variable or static data member; did you mean %1'
H32A3026BA924: '%0 不是全局变量、静态局部变量或静态数据成员；您是指 %1 吗？'
# '%0 is not a recognized builtin%select{|; consider including <intrin.h> to access non-builtin intrinsics}1'
HB8FF0E17F733: '%0 不是已识别的内置函数%select{|；请包含 <intrin.h> 以访问非内置本机函数}1'
# '%0 is not a structural type because it has a %select{non-static data member|base class}1 of non-structural type %2'
HF393BE38CC50: '%0 不是结构性类型，因为它具有非结构性类型 %2 的 %select{非静态数据成员|基类}1'
# '%0 is not a structural type because it has a %select{non-static data member|base class}1 that is not public'
H7772D2C2337B: '%0 不是结构性类型，因为它具有非公共的 %select{非静态数据成员|基类}1'
# '%0 is not a structural type because it has a mutable non-static data member'
HF8F430793986: '%0 不是结构性类型，因为它具有可变的非静态数据成员'
# '%0 is not a structural type because it has a non-static data member of rvalue reference type'
H3FC432618326: '%0 不是结构性类型，因为它具有右值引用类型的非静态数据成员'
# '%0 is not a valid SYCL kernel name type; a non-union class type is required'
H0BC00170201E: '%0 不是有效的 SYCL 内核名称类型；需要非联合类类型'
# '%0 is not a valid literal type for NSNumber'
H994AF662B0D5: '%0 不是NSNumber的有效文字类型'
# '%0 is not a valid property name (accessing an object of type %1)'
HA0D8AFF85380: '%0 不是有效的属性名称（访问类型为%1的对象）'
# "%0 is not an availability stage; use 'introduced', 'deprecated', or 'obsoleted'"
H5FED6488A0D9: "%0 不是可用性阶段；请使用'introduced'、'deprecated'或'obsoleted'"
# '%0 is not an enumerated type'
H7F1BAB170C64: '%0 不是枚举类型'
# '%0 is not defined, but forward declared here; conversion would be valid if it was derived from %1'
H176B6CEA9A74: '%0 未定义，但在此处有前置声明；如果其派生于%1类型则转换有效'
# '%0 is not defined, evaluates to 0'
HBDB44DE505CF: '%0 未定义，计算结果为0'
# '%0 is not literal because it has a non-trivial destructor'
HC9535B0A1692: '%0 不是文字类型，因为它具有非平凡的析构函数'
# '%0 is not literal because it has a user-provided destructor'
H35BFFB66B4EF: '%0 不是文字类型，因为它具有用户提供的析构函数'
# '%0 is not literal because it has base class %1 of non-literal type'
H41CFD9851FA8: '%0 不是文字类型，因为它具有基类%1属于非文字类型'
# '%0 is not literal because it has data member %1 of %select{non-literal|volatile}3 type %2'
H39754ECC239F: '%0 不是文字类型，因为它具有%select{非文字型|volatile}3类型%2的成员%1'
# '%0 is not literal because it is not an aggregate and has no constexpr constructors other than copy or move constructors'
HD7160BA9A570: '%0 不是文字类型，因为它不是聚合类型且除了拷贝或移动构造函数外没有constexpr构造函数'
# '%0 is not literal because its destructor is not constexpr'
HEAC0F5C26B7E: '%0 不是文字类型，因为它的析构函数不是constexpr'
# '%0 is not polymorphic'
H67C71DB95F18: '%0 不是多态类型'
# '%0 is not supported on HVX %1'
H7927AD732A30: '%0 不受HVX %1支持'
# '%0 is not supported on this target'
H331CCFBB5DA0: '%0 不受此目标平台支持'
# '%0 is not supported with -fembed-bitcode'
H580226EF44DA: '%0 不能与-fembed-bitcode选项同时使用'
# '%0 is not virtual and cannot be declared pure'
HFCE20933CC31: '%0 不是虚函数，不能声明为纯虚函数'
# '%0 is only available %select{|in %4 environment }3on %1 %2 or newer'
H1926B8ADA9BD: '%0 仅在%select{|%4环境 }3%1 %2或更高版本中可用'
# '%0 is only supported when \'-mrvv-vector-bits=<bits>\' is specified with a value of "zvl" or a power 2 in the range [64,65536]'
H714177E08C3D: '%0 仅在指定‘-mrvv-vector-bits=<bits>’参数为"zvl"或64到65536之间的2的幂时支持'
# "%0 is only supported when '-msve-vector-bits=<bits>' is specified with a value of 128, 256, 512, 1024 or 2048"
H5256E220BB0F: '在指定‘-msve-vector-bits=<bits>’参数值为128、256、512、1024或2048时支持%0'
# "%0 is required to declare the member 'unhandled_exception()'"
H72F7248FC774: "%0 必须声明成员 'unhandled_exception()'"
# "%0 is required to declare the member 'unhandled_exception()' when exceptions are enabled"
HA2F4C1A14DF7: "当启用异常时，%0 必须声明成员 'unhandled_exception()'"
# "%0 is required to have a non-throwing noexcept specification when the promise type declares 'get_return_object_on_allocation_failure()'"
H267685A6E8FC: "当 promise 类型声明 'get_return_object_on_allocation_failure()' 时，%0 必须具有不抛出异常的 noexcept 说明"
# '%0 is unavailable'
HD9DCE040D90B: '%0 不可用'
# '%0 is unavailable in ARC'
H5A0EF77D1311: '%0 在 ARC 中不可用'
# '%0 is unavailable: %1'
H3F1A4B4C46AF: '%0 不可用：%1'
# '%0 is unsupported with LoongArch linker relaxation (-mrelax)'
H711EE6DE37A1: '%0 不支持与 LoongArch 链接器放松 (-mrelax) 一起使用'
# '%0 is unsupported with RISC-V linker relaxation (-mrelax)'
H7184497D9FBD: '%0 不支持与 RISC-V 链接器放松 (-mrelax) 一起使用'
# '%0 is used as a header guard here, followed by #define of a different macro'
HD1F7F8F6EEEE: '%0 在此处用作头文件卫士，随后是不同宏的 #define'
# "%0 layout not recognized. Must be a non-polymorphic class type with no bases and two fields: a 'const E *' and either another 'const E *' or a 'std::size_t'"
HED28B381356F: "%0 布局未被识别。必须是一个无基类且非多态的类类型，并且包含两个字段：一个 'const E *' 和另一个 'const E *' 或 'std::size_t'"
# '%0 macro redefined'
H137240D8643E: '%0 宏被重新定义'
# "%0 managed by '%1' is '%3' instead of '%2'"
H2BF1BAAD2D9C: "由 '%1' 管理的 %0 是 '%3' 而不是 '%2'"
# "%0 marked 'override' but does not override any member functions"
H4E355023D40F: "%0 标记为 'override'，但未覆盖任何成员函数"
# '%0 may be deprecated because the receiver type is unknown'
H33FCAE6FB142: '%0 可能因接收器类型未知而被弃用'
# '%0 may be duplicated when built into a shared library: it is mutable, has hidden visibility, and external linkage'
H5AAA1A09F587: '当构建为共享库时，%0 可能会被重复：它是可变的，具有隐藏可见性且具有外部链接'
# '%0 may be unavailable because the receiver type is unknown'
H5F639AF749BC: '%0 可能因接收器类型未知而不可用'
# '%0 may not be nested in a struct due to flexible array member'
H56A636FEC1E0: '%0 可能因柔性数组成员而无法嵌套在结构体中'
# '%0 may not be used as an array element due to flexible array member'
H4CE3DAD3A8F2: '%0 可能因柔性数组成员而无法用作数组元素'
# '%0 may not intend to support class template argument deduction'
H3F1AA6022CE0: '%0 可能不打算支持类模板实参推导'
# '%0 may not respond to %1'
HE863B7C4E09E: '%0 可能无法响应 %1'
# '%0 must be explicitly converted to %1; use %select{%objcclass2|%objcinstance2}3 method for this conversion'
H7B5D141884DB: '%0 必须显式转换为%1；使用%select{%objcclass2|%objcinstance2}3方法进行此转换'
# '%0 must be name of an Objective-C class to be able to convert %1 to %2'
HF9706A398326: '%0 必须是Objective-C类的名称，以便将%1转换为%2'
# '%0 must be specified on definition if it is specified on any declaration'
H593384CDC4FD: '如果在任何声明中指定了 %0，必须在定义中指定它'
# '%0 must be used within a preprocessing directive'
HAA08D126AF16: '%0 必须在预处理指令中使用'
# '%0 must have at least one parameter'
H2488FE597801: '%0 必须至少有一个参数'
# "%0 must not appear in both clauses 'to' and 'link'"
HC3403F617C92: "%0 不得同时出现在' to '和' link '子句中"
# '%0 must return type %1'
H561F31EBFB23: '%0 必须返回类型%1'
# '%0 needs target feature %1'
H5236119E54CB: '%0 需要目标特性%1'
# '%0 needs to be instantiated from a class template with proper template arguments'
H6CDDF6DD374E: '%0 需要从具有适当模板参数的类模板实例化'
# '%0 needs to have exactly %1 template parameters'
HD0C675913338: '%0 必须恰好有%1个模板参数'
# '%0 only allowed in __except block or filter expression'
H5D665A901228: '%0 仅允许在__except块或过滤表达式中使用'
# '%0 only allowed in __except filter expression'
H6152837B25ED: '%0 仅允许在__except过滤表达式中使用'
# '%0 only allowed in __finally block'
H4B415A24C89A: '%0 仅允许在__finally块中使用'
# '%0 only applies to pointer types; type here is %1'
HAB4FE8662D8D: '%0 仅适用于指针类型；此处的类型是%1'
# "%0 overrides a destructor but is not marked 'override'"
HEE01F5122D86: "%0 覆盖了一个析构函数但未标记为'override'"
# "%0 overrides a member function but is not marked 'override'"
H7449F9821D96: "%0 覆盖了一个成员函数但未标记为'override'"
# "%0 parameter marked 'called_once' is called twice"
H9B0F1F204498: "%0 标记为'called_once'的参数被调用了两次"
# "%0 parameter marked 'called_once' is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2"
HBB87206669E4: "%0 标记为'called_once'的参数在%select{取真分支|取假分支|处理这种情况|所有情况都不适用|进入循环时|跳过循环时|取其中一个分支}2时%select{未被使用|未被调用}1"
# "%0 redeclared with '%1' access"
H6D05457F8E04: '%0 重新声明为具有"%1"访问权限'
# '%0 released here'
H2E4FF4BE13D1: '%0 在此处释放'
# "%0 requires %1 type support, but ABI '%2' does not support it"
H03B0999A3C3B: "%0 需要 %1 类型支持，但 ABI '%2' 不支持该特性"
# "%0 requires %select{|%2 bit size}1 %3 %select{|return }4type support, but target '%5' does not support it"
HE937C1210F37: "%0 需要 %select{|%2 位大小}1 %3 %select{|返回}4 类型支持，但目标架构 '%5' 不支持该特性"
# '%0 requires HVX, use -mhvx/-mhvx= to enable it'
H9F7369C63134: '%0 需要 HVX 支持，请使用 -mhvx/-mhvx= 开启该功能'
# "%0 requires debug info. Use %1 or debug options that enable debugger's stepping function; option ignored"
H985F4F582A8C: '%0 需要调试信息。请使用 %1 或启用调试器单步执行功能的选项；当前选项被忽略'
# '%0 requires more than 1 template argument; provide the remaining arguments explicitly to use it here'
H33A930D763B0: '%0 需要超过 1 个模板参数；请显式提供剩余参数以在此处使用'
# '%0 returns a reference'
H81B0F21DCC91: '%0 返回引用'
# '%0 should be declared prior to the call site%select{| or in %2| or in an associated namespace of one of its arguments}1'
H80A1DB32BBA2: '%0 应在调用位置之前声明%select{|或在 %2 中|或在其实参关联命名空间之一中}1'
# "%0 should not return a null pointer unless it is declared 'throw()'%select{| or 'noexcept'}1"
HD6330A6C968B: "%0 除非被声明为 'throw()'%select{|或 'noexcept'}1，否则不应返回空指针"
# '%0 size too large'
HC155B92BBDDE: '%0 尺寸过大'
# '%0 specified here'
H2793186BA8E0: '%0 在此处指定'
# '%0 takes type size_t (%1) as first parameter'
H994A3A678C5B: '%0 第一个参数应为 type size_t (%1)'
# '%0 template must have at least two parameters'
HC33714C2985B: '%0 模板必须至少有两个参数'
# '%0 type %1 not found; include the base header with -finclude-default-header'
HB4775AA2AD70: '%0 类型 %1 未找到；请通过 -finclude-default-header 引入基础头文件'
# '%0 type was not found; include <coroutine> before defining a coroutine'
H89DE99125E80: '%0 类型未找到；在定义协程前请包含 <coroutine>'
# '%0 used as the name of the previous parameter rather than as part of the selector'
HAA86630AF908: '%0 被用作前一个参数的名称而非选择器的一部分'
# '%0 used in array declarator outside of function prototype'
H667299EFB745: '%0 在函数原型外的数组声明符中使用'
# '%0 used in declare target directive is not a variable or a function name'
H56AD7716F4DF: '%0 在声明目标指令中不是变量或函数名'
# '%0 used in non-outermost array type derivation'
H7D46A3E1139D: '%0 在非最外层数组类型推导中使用'
# '%0 variable cannot be %1'
H88684475A953: '%0 变量不能是 %1'
# "%0 variable cannot be in a %1 clause in '#pragma omp %2' directive"
HF56ADE356ADE: '%0 变量不能在 #pragma omp %2 指令的 %1 子句中使用'
# '%0 variable must be %1'
H2457271DFCB0: '%0 变量必须是 %1'
# "%0 was %select{disabled|enabled}1 in AST file '%3' but is currently %select{disabled|enabled}2"
HC0632CD5FF96: "%0 在AST文件 '%3' 中%select{禁用|启用}1，但当前是%select{禁用|启用}2"
# '%0 was deserialized'
H39D399F5AEF8: '%0 已反序列化'
# '%0 was marked unused but was used'
H40B831F8FB51: '%0 被标记为未使用，但实际被使用了'
# '%0%select{ attribute|}1 cannot be applied to a base specifier'
H11035A3B905C: '%0%select{属性|}1 不能应用于基类说明符'
# '%0%select{ attribute|}1 cannot be applied to a declaration'
H127063747A92: '%0%select{属性|}1 不能应用于声明'
# '%0%select{ attribute|}1 cannot be applied to a statement'
H1C3F2544F25A: '%0%select{属性|}1 不能应用于语句'
# '%0%select{ attribute|}1 cannot be applied to types'
H96D80DF95948: '%0%select{属性|}1 不能应用于类型'
# '%0%select{ attribute|}1 only applies to %2'
H45C12381C633: '%0%select{属性|}1 仅适用于 %2'
# '%0%select{ attribute|}1 only applies to %select{functions|unions|variables and functions|functions and methods|functions, methods and blocks|functions, methods, and parameters|variables|variables and fields|variables, data members and tag types|types and namespaces|variables, functions and classes|kernel functions|non-K&R-style functions|for loop statements|virtual functions|parameters and implicit object parameters|non-member functions|functions, classes, or enumerations|classes|typedefs}2'
H9D37840D3CB2: '%0%select{属性|}1 仅适用于 %select{函数|联合体|变量和函数|函数和方法|函数、方法和块|函数、方法和参数|变量|变量和字段|变量、数据成员和标量类型|类型和命名空间|变量、函数和类|内核函数|非K&R风格函数|for循环语句|虚函数|参数和隐式对象参数|非成员函数|函数、类或枚举|类|类型别名}2'
# "%0%select{| following the 'template' keyword}1 cannot refer to a dependent template"
HA18DA36B7236: "%0%select{|在'template'关键字后}1不能引用依赖模板"
# "%0%select{| following the 'template' keyword}1 does not refer to a template"
HCADF8F759262: "%0%select{|在'template'关键字后}1未引用模板"
# "%0: '%1' input unused in cpp mode"
HF14789F9D841: "%0: 'cpp模式中未使用 '%1' 输入"
# "%0: '%1' input unused%select{ when '%3' is present|}2"
HA6B5E8785AC8: "%0: '%1' 输入未使用%select{当存在 '%3' 时|}2"
# "%0: 'get_return_object_on_allocation_failure()' must be a static member function"
HB26892211ABD: "%0: 'get_return_object_on_allocation_failure()' 必须是一个静态成员函数"
# "%0: previously preprocessed input%select{ unused when '%2' is present|}1"
H1EB52EB9DA3B: "%0: 之前预处理的输入%select{当存在 '%2' 时未使用|}1"
# "%0; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop or by providing the compiler option '-ffast-math'"
H50F1AE498158: "%0; 通过在循环前指定 '#pragma clang loop vectorize(enable)' 允许重新排序，或使用编译器选项 '-ffast-math'"
# "%0; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop; if the arrays will always be independent, specify '#pragma clang loop vectorize(assume_safety)' before the loop or provide the '__restrict__' qualifier with the independent array arguments -- erroneous results will occur if these options are incorrectly applied"
H696063533F0E: "%0; 通过在循环前指定 '#pragma clang loop vectorize(enable)' 允许重新排序；如果数组总是独立的，可在循环前指定 '#pragma clang loop vectorize(assume_safety)'，或为独立数组参数添加 '__restrict__' 限定符 —— 错误结果将出现在错误应用这些选项时"
# '%0B (%human0B) in local locations, %1B (%human1B) in locations loaded from AST files, for a total of %2B (%human2B) (%3%% of available space)'
H9B3C5907D274: '%0B (%human0B) 在本地位置，%1B (%human1B) 在AST文件加载位置，总计 %2B (%human2B) (%3%% 的可用空间)'
# '%1 %0 is hidden by a non-type declaration of %0 here'
HC05432050C69: '%1 %0 被此处的非类型声明 %0 隐藏'
# '%1 is a %select{private|protected}0 member of %3'
H4162E2E8D4C1: '%1 是 %3 的 %select{私有|受保护}0 成员'
# '%2 defined as %select{a struct|an interface|a class}0%select{| template}1 here but previously declared as %select{a struct|an interface|a class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI'
H65DDB76661CA: '%2 被定义为 %select{一个结构体|一个接口|一个类}0%select{|模板}1 这里，但之前声明为 %select{一个结构体|一个接口|一个类}3%select{|模板}1；这是有效的，但可能导致在 Microsoft C++ ABI 下的链接器错误'
# '%diff{$ and $ are not pointers to compatible types|pointers to incompatible types}0,1'
HE4DF3395C0FE: '%diff{指针 $ 和 $ 指向不兼容类型|指向不兼容类型的指针}0,1'
# '%diff{promoted type $ of K&R function parameter is not compatible with the parameter type $|promoted type of K&R function parameter is not compatible with parameter type}0,1 declared in a previous prototype'
HBE91EA4F0CCD: '%diff{K&R 函数参数提升后的类型 $ 与之前原型中声明的参数类型 $ 不兼容|K&R 函数参数的提升类型与参数类型不兼容}0,1 在之前的原型中声明'
# '%diff{return type $ must match previous return type $|return type must match previous return type}0,1 when %select{block literal|lambda expression}2 has unspecified explicit return type'
H503B0717AF47: '%diff{当 %select{块字面量|lambda 表达式}2 的显式返回类型未指定时，返回类型 $ 必须与之前的返回类型 $ 匹配|返回类型必须与之前的返回类型匹配}0,1'
# "%ordinal0 argument must be a %select{|scalar|vector|matrix|vector of|scalar or vector of}1%plural{[2,3]:%plural{0:|:%plural{0:|:,}2}3|:}1%plural{0:|: }1%select{|integer|signed integer|unsigned integer|'int'|pointer to a valid matrix element}2%plural{0:|: }2%plural{0:|:%plural{0:|:or }2}3%select{|floating-point}3%plural{0:|: }3%plural{[0,3]:type|:types}1 (was %4)"
HEE73BAE75429: "%ordinal0 参数必须是 %select{|标量|向量|矩阵|向量的|标量或向量的}1%plural{[2,3]:%plural{0:|:%plural{0:|:,}2}3|:}1%plural{0:|: }1%select{|整数|有符号整数|无符号整数|'int'|合法矩阵元素的指针}2%plural{0:|: }2%plural{0:|:%plural{0:|:或 }2}3%select{|浮点数}3%plural{0:|: }3%plural{[0,3]:类型|:类型}1（实际为 %4）"
# '%ordinal0 argument must be a WebAssembly table'
HF0E3AF42C5DD: '%ordinal0 参数必须是 WebAssembly 表'
# '%ordinal0 argument must be an integer'
HB74677AB0CCF: '%ordinal0 参数必须是整数'
# '%ordinal0 argument must match the element type of the WebAssembly table in the %ordinal1 argument'
HCC6BF06B970F: '%ordinal0 参数必须与 %ordinal1 参数中 WebAssembly 表的元素类型一致'
# '%plural{1:enumeration value %1 not explicitly handled in switch|2:enumeration values %1 and %2 not explicitly handled in switch|3:enumeration values %1, %2, and %3 not explicitly handled in switch|:%0 enumeration values not explicitly handled in switch: %1, %2, %3...}0'
HE8DAC9A52D87: '%plural{1:枚举值 %1 在 switch 中未显式处理|2:枚举值 %1 和 %2 在 switch 中未显式处理|3:枚举值 %1、%2 和 %3 在 switch 中未显式处理|:%0 个枚举值在 switch 中未显式处理：%1、%2、%3...}0'
# '%plural{1:enumeration value %1 not handled in switch|2:enumeration values %1 and %2 not handled in switch|3:enumeration values %1, %2, and %3 not handled in switch|:%0 enumeration values not handled in switch: %1, %2, %3...}0'
H0E3F79F6C010: '%plural{1:枚举值 %1 在 switch 中未处理|2:枚举值 %1 和 %2 在 switch 中未处理|3:枚举值 %1、%2 和 %3 在 switch 中未处理|:%0 个枚举值在 switch 中未处理：%1、%2、%3...}0'
# "%plural{2:'delete' used to delete pointer to object allocated with 'std::allocator<...>::allocate'|:%select{non-array delete|array delete|'std::allocator<...>::deallocate'}0 used to delete pointer to %select{array object of type %2|non-array object of type %2|object allocated with 'new'}0}1"
H1294E54BD6EF: "%plural{2:'delete' 用于删除通过 'std::allocator<...>::allocate' 分配的指针|:%select{非数组 delete|数组 delete|'std::allocator<...>::deallocate'}0 用于删除 %select{类型 %2 的数组对象|类型 %2 的非数组对象|通过 'new' 分配的对象}0 的指针}1"
# '%plural{[0,2]:must use a qualified name when declaring|3:cannot declare}0 a %select{constructor|destructor|conversion operator|deduction guide}0 as a friend'
H180E877A4B1E: '%plural{[0,2]:声明时必须使用限定名|3:不能声明}0 %select{构造函数|析构函数|类型转换运算符|推导指引}0 作为友元'
# "%q0 %select{with definition in module '%2'|defined here}1 has different definitions in different modules; first difference is this %select{||||static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property|unexpected decl}3"
HC2ECA20D4E80: "%q0 %select{在模块 '%2' 中有定义|在此处定义}1 在不同模块中有不同的定义；第一个差异是 %select{||||静态断言|字段|方法|类型别名|typedef|数据成员|友元声明|函数模板|方法|实例变量|属性|意外声明}3"
# '%q0 cannot be thread local when declared %q1'
H1F0205F4AD29: '%q0 在声明为 %q1 时不能是线程局部变量'
# "%q0 from module '%1' is not present in definition of %q2%select{ in module '%4'| provided earlier}3"
H9DF776E318FF: "%q0 在模块 '%1' 中不存在于 %q2%select{在模块 '%4' 的定义中|之前提供的定义中}3"
# "%q0 has different definitions in different modules; %select{definition in module '%2' is here|defined here}1"
HB3D6EB7685C3: "%q0 在不同模块中有不同的定义；%select{模块 '%2' 中的定义在此处|在此处定义}1"
# "%q0 has different definitions in different modules; %select{definition in module '%2'|defined here}1 first difference is %select{enum that is %select{not scoped|scoped}4|enum scoped with keyword %select{struct|class}4|enum %select{without|with}4 specified type|enum with specified type %4|enum with %4 element%s4|%ordinal4 element has name %5|%ordinal4 element %5 %select{has|does not have}6 an initializer|%ordinal4 element %5 has an initializer|}3"
H39CEC8B6DBEB: "%q0 在不同模块中有不同的定义；%select{模块 '%2' 的定义|此处定义}1 首个差异是 %select{该枚举 %select{未带作用域|带作用域}4|枚举用 %select{结构体|类}4 关键词带作用域|枚举 %select{无|有}4 指定类型|枚举的指定类型是 %4|枚举有 %4 元素%s4|%ordinal4 元素的名称是 %5|%ordinal4 元素 %5 %select{有|没有}6 初始化器|%ordinal4 元素 %5 有初始化器|}3"
# "%q0 has different definitions in different modules; %select{definition in module '%2'|defined here}1 first difference is %select{return type is %4|%ordinal4 parameter with name %5|%ordinal4 parameter with type %5%select{| decayed from %7}6|%ordinal4 parameter with%select{out|}5 a default argument|%ordinal4 parameter with a default argument|function body}3"
H68AA8A549FAA: "%q0 在不同模块中有不同的定义；%select{模块 '%2' 的定义|此处定义}1 首个差异是 %select{返回类型为 %4|%ordinal4 参数名为 %5|%ordinal4 参数类型为 %5%select{| 衰减为 %7}6|%ordinal4 参数%select{外|}5 有默认参数|%ordinal4 参数有默认参数|函数体}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%4 base %plural{1:class|:classes}4|%4 virtual base %plural{1:class|:classes}4|%ordinal4 base class with type %5|%ordinal4 %select{non-virtual|virtual}5 base class %6|%ordinal4 base class %5 with %select{public|protected|private|no}6 access specifier}3"
HC4303FABC437: "%q0 在不同模块中有不同的定义；第一个差异是 %select{在模块 '%2' 的定义|在此处定义}1 发现 %select{有 %4 个基类%plural{1:类|:类}4|有 %4 个虚基类%plural{1:类|:类}4|%ordinal4 基类类型为 %5|%ordinal4 %select{非虚|虚}5 基类 %6|%ordinal4 基类 %5 的访问说明符为 %select{public|protected|private|无}6}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%4 referenced %plural{1:protocol|:protocols}4|%ordinal4 referenced protocol with name %5}3"
HC9695A16C965: "%q0 在不同模块中有不同的定义；第一个差异是 %select{在模块'%2'中的定义|在此处定义}1 发现 %select{引用了%4 %plural{1:协议|:协议}4|%ordinal4 参考的协议名称为%5}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{method %5|constructor|destructor}4 that has %6 parameter%s6|%select{method %5|constructor|destructor}4 with %ordinal6 parameter of type %7%select{| decayed from %9}8|%select{method %5|constructor|destructor}4 with %ordinal6 parameter named %7}3"
HA17814A91726: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2'中的定义|在此处定义}1 发现 %select{%select{方法 %5|构造函数|析构函数}4 具有 %6 参数%s6|%select{方法 %5|构造函数|析构函数}4 的第 %ordinal6 参数类型为 %7%select{| 衰减为 %9}8|%select{方法 %5|构造函数|析构函数}4 的第 %ordinal6 参数名为 %7}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{typedef|type alias}4 name %5|%select{typedef|type alias}4 %5 with underlying type %6}3"
H290AB6198D53: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2'中的定义|在此处定义}1 发现 %select{%select{typedef|类型别名}4 名称 %5|%select{typedef|类型别名}4 %5 其底层类型为 %6}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{data member with name %4|data member %4 with type %5|data member %4 with%select{out|}5 an initializer|data member %4 with an initializer|data member %4 %select{is constexpr|is not constexpr}5}3"
H3C6A067820A4: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2'中的定义|在此处定义}1 发现 %select{具有名称 %4 的数据成员|数据成员 %4 的类型 %5|数据成员 %4%select{有|}5 初始值设定项|数据成员 %4 具有初始值设定项|数据成员 %4 %select{是constexpr|不是constexpr}5}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{end of class|public access specifier|private access specifier|protected access specifier|static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property}3"
HC7FCD2470FA2: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2'中的定义|在此处定义}1 发现 %select{类结尾|public访问说明符|private访问说明符|protected访问说明符|静态断言|字段|方法|类型别名|typedef|数据成员|朋友声明|函数模板|方法|实例变量|属性}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{field %4|field %4 with type %5|%select{non-|}5bit-field %4|bit-field %4 with one width expression|%select{non-|}5mutable field %4|field %4 with %select{no|an}5 initializer|field %4 with an initializer}3"
H60D85DC0E685: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2'中的定义|在此处定义}1 发现 %select{字段 %4|字段 %4 的类型 %5|%select{非-|}5位字段 %4|位字段 %4 具有单个宽度表达式|%select{非-|}5可变字段 %4|字段 %4 具有%select{无|}5初始值设定项|字段 %4 具有初始值设定项}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{method %4 with return type %5|%select{class|instance}5 method %4|%select{no|'required'|'optional'}4 method control|method %4 with %select{no designated initializer|designated initializer}5|%select{regular|direct}5 method %4|method %4}3"
H5AECB1226BDE: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2'中的定义|在此处定义}1 发现 %select{返回类型为 %5 的方法 %4|%select{类|实例}5 方法 %4|%select{无|'required'|'optional'}4 方法控制|方法 %4 具有%select{无指定初始化器|指定初始化器}5|%select{常规|直接}5 方法 %4|方法 %4}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{property %4|property %4 with type %5|%select{no|'required'|'optional'}4 property control|property %4 with %select{default |}6'%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}5' attribute}3"
H47E62251068F: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2'中的定义|在此处定义}1 发现 %select{属性 %4|属性 %4 的类型 %5|%select{无|'required'|'optional'}4 属性控制|属性 %4 具有%select{默认 |}6'%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}5' 属性}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{static assert with condition|static assert with message|static assert with %select{|no }4message|%select{method %5|constructor|destructor}4|%select{method %5|constructor|destructor}4 is %select{not deleted|deleted}6|%select{method %5|constructor|destructor}4 is %select{not defaulted|defaulted}6|%select{method %5|constructor|destructor}4 is %select{|pure }6%select{not virtual|virtual}7|%select{method %5|constructor|destructor}4 is %select{not static|static}6|%select{method %5|constructor|destructor}4 is %select{not volatile|volatile}6|%select{method %5|constructor|destructor}4 is %select{not const|const}6|%select{method %5|constructor|destructor}4 is %select{not inline|inline}6|%select{method %5|constructor|destructor}4 with %ordinal6 parameter with%select{out|}7 a default argument|%select{method %5|constructor|destructor}4 with %ordinal6 parameter with a default argument|%select{method %5|constructor|destructor}4 with %select{no |}6template arguments|%select{method %5|constructor|destructor}4 with %6 template argument%s6|%select{method %5|constructor|destructor}4 with %6 for %ordinal7 template argument|%select{method %5|constructor|destructor}4 with %select{no body|body}6|%select{method %5|constructor|destructor}4 with body|friend %select{class|function}4|friend %4|friend function %4|function template %4 with %5 template parameter%s5|function template %4 with %ordinal5 template parameter being a %select{type|non-type|template}6 template parameter|function template %4 with %ordinal5 template parameter %select{with no name|named %7}6|function template %4 with %ordinal5 template parameter with %select{no |}6default argument|function template %4 with %ordinal5 template parameter with default argument %6|function template %4 with %ordinal5 template parameter with one type|function template %4 with %ordinal5 template parameter %select{not |}6being a template parameter pack|}3"
HCEB41952ED68: "%q0 在不同模块中具有不同的定义；第一个差异是 %select{模块 '%2'中的定义|在此处定义}1 发现 %select{带有条件的静态断言|带有消息的静态断言|%select{|无 }4消息的静态断言|%select{方法 %5|构造函数|析构函数}4|%select{方法 %5|构造函数|析构函数}4 是 %select{未删除|已删除}6|%select{方法 %5|构造函数|析构函数}4 是 %select{未默认|已默认}6|%select{方法 %5|构造函数|析构函数}4 是 %select{|纯 }6%select{非虚|虚}7|%select{方法 %5|构造函数|析构函数}4 是 %select{非静态|静态}6|%select{方法 %5|构造函数|析构函数}4 是 %select{非volatile|volatile}6|%select{方法 %5|构造函数|析构函数}4 是 %select{非const|const}6|%select{方法 %5|构造函数|析构函数}4 是 %select{非内联|内联}6|%select{方法 %5|构造函数|析构函数}4 具有第 %ordinal6 参数带有%select{出|}7 默认参数|%select{方法 %5|构造函数|析构函数}4 具有第 %ordinal6 参数带有默认参数|%select{方法 %5|构造函数|析构函数}4 具有%select{无 |}6模板参数|%select{方法 %5|构造函数|析构函数}4 具有 %6 模板参数%s6|%select{方法 %5|构造函数|析构函数}4 具有 %6 作为第 %ordinal7 模板参数|%select{方法 %5|构造函数|析构函数}4 具有%select{无|有}6函数体|%select{方法 %5|构造函数|析构函数}4 具有函数体|友元 %select{类|函数}4|友元 %4|友元函数 %4|函数模板 %4 具有 %5 模板参数%s5|函数模板 %4 具有第 %ordinal5 模板参数是 %select{类型|非类型|模板}6 模板参数|函数模板 %4 具有第 %ordinal5 模板参数%select{无名称|名称为 %7}6|函数模板 %4 具有第 %ordinal5 模板参数%select{无|}6默认参数|函数模板 %4 具有第 %ordinal5 模板参数默认参数 %6|函数模板 %4 具有第 %ordinal5 模板参数具有一个类型|函数模板 %4 具有第 %ordinal5 模板参数%select{不|}6是模板参数包|}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{unnamed template parameter|template parameter %5|template parameter with %select{no |}4default argument|template parameter with default argument}3"
HA9E92FE31082: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2'中的定义|在此处定义}1 发现 %select{未命名的模板参数|模板参数 %5|模板参数%select{无 |}4默认参数|模板参数具有默认参数}3"
# '%q0 hides overloaded virtual %select{function|functions}1'
H2FDDD909C4BF: '%q0 隐藏重载虚 %select{函数|函数}1'
# '%q0 is not a member of class %1'
H76BB7974AA85: '%q0 不是类 %1 的成员'
# '%q0 must have external linkage when declared %q1'
HEEACDE119817: '%q0 声明为 %q1 时必须具有外部链接性'
# '%q0 redeclared inline; %1 attribute ignored'
HE698B2D72430: '%q0 重复声明为内联；忽略 %1 属性'
# '%q0 redeclared without %1 attribute: previous %1 ignored'
HD8FE54A130EE: '%q0 未重复声明 %1 属性：忽略先前的 %1 属性'
# "%q0 redeclared without 'dllimport' attribute: 'dllexport' attribute added"
H6D76D4BE2232: "%q0 未重复声明'dllimport'属性：添加'dllexport'属性"
# '%select{#elif|#elifdef|#elifndef}0 after #else'
H66B8B159F15D: '%select{#elif|#elifdef|#elifndef}0 在#else之后'
# '%select{#elif|#elifdef|#elifndef}0 without #if'
HF4D335F3B905: '%select{#elif|#elifdef|#elifndef}0 未在#if之后'
# '%select{#line|GNU line marker}0 directive interprets number as decimal, not octal'
HDF9BCDB36B4E: '%select{#line|GNU行标记}0 指令将数字解释为十进制而非八进制'
# '%select{#line|GNU line marker}0 directive requires a simple digit sequence'
H065F2C4ACA47: '%select{#line|GNU行标记}0 指令需要简单的数字序列'
# '%select{%1 and |}0%2 tokens %select{introducing statement expression|terminating statement expression|introducing attribute|terminating attribute|forming pointer to member type}3 appear in different macro expansion contexts'
H64A1AC254D6A: '%select{%1 和 |}0%2 标记 %select{引入语句表达式|终止语句表达式|引入属性|终止属性|形成成员指针类型}3 出现在不同的宏展开上下文中'
# '%select{%1 and |}0%2 tokens %select{introducing statement expression|terminating statement expression|introducing attribute|terminating attribute|forming pointer to member type}3 are separated by whitespace'
H9C7F5E5CC536: '%select{%1 和 |}0%2 标记 %select{引入语句表达式|终止语句表达式|引入属性|终止属性|形成成员指针类型}3 被空白字符分隔'
# '%select{%1 is a virtual base class of base class %2 declared here|virtual base class %1 declared here}0'
H0907DB13630C: '%select{%2 的子对象是虚拟基类 %1 的声明位置|虚拟基类 %1 声明于此}0'
# '%select{%2 has subobjects that are|%3 has type %2 that is}0 non-trivial to %select{default-initialize|destruct|copy}1'
H48AF719C5841: '%select{%2 包含的子对象是|%3 的类型 %2 是}0 非平凡的 %select{默认初始化|销毁|复制}1'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of nested pointer'
H229282294F90: '%select{%diff{将 $ 赋值给 $|将不同类型赋值}1,0|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}0,1|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 改变了嵌套指针的地址空间'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of pointer'
H34858D5559B9: '%select{%diff{将 $ 赋值给 $|将不同类型赋值}1,0|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}0,1|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 改变了指针的地址空间'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes retain/release properties of pointer'
HCD0B002FCAD8: '%select{%diff{将 $ 赋值给 $|将不同类型赋值}1,0|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}0,1|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 改变了指针的 retain/release 属性'
# "%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between pointers to integer types %select{with different sign|where one is of the unique plain 'char' type and the other is not}3"
H1F24CCDCD587: "%select{%diff{将 $ 赋值给 $|将不同类型赋值}0,1|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}0,1|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 在整数指针类型之间转换 %select{带有不同的符号|其中一个为普通 'char' 类型而另一个不是}3"
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between void pointer and function pointer'
HA7C5AA745059: '%select{%diff{将 $ 赋值给 $|将不同类型赋值}0,1|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}0,1|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 在 void 指针和函数指针之间转换'
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers'
H7F0C4095C720: '%select{%diff{将 $ 赋值给 $|将不同类型赋值}0,1|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}0,1|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 舍弃了指针类型中的限定符'
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers in nested pointer types'
HA6738ACC7EBA: '%select{%diff{将 $ 赋值给 $|将不同类型赋值}0,1|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}0,1|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 舍弃了嵌套指针类型中的限定符'
# '%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2'
HCAB9D3041C51: '%select{%diff{将类型 $ 赋值给类型不兼容的 $|将类型赋值给不兼容类型}0,1|%diff{将类型 $ 传递给类型不兼容的参数 $|将类型传递给不兼容参数类型}0,1|%diff{从结果类型不兼容的 $ 函数返回 $|从结果类型不兼容的函数返回类型}0,1|%diff{将类型 $ 转换为类型不兼容的 $|将类型转换为不兼容类型}0,1|%diff{用类型不兼容的 $ 表达式初始化 $|用类型不兼容的表达式初始化类型}0,1|%diff{将类型 $ 发送到类型不兼容的参数 $|将类型发送给不兼容参数类型}0,1|%diff{将类型 $ 铸为类型不兼容的 $|将类型铸为不兼容类型}0,1}2'
# '%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4'
H5631F8DA82CD: '%select{%diff{将类型 $ 赋值给类型不兼容的 $|将类型赋值给不兼容类型}0,1|%diff{将类型 $ 传递给类型不兼容的参数 $|将类型传递给不兼容参数类型}0,1|%diff{从结果类型不兼容的 $ 函数返回 $|从结果类型不兼容的函数返回类型}0,1|%diff{将类型 $ 转换为类型不兼容的 $|将类型转换为不兼容类型}0,1|%diff{用类型不兼容的 $ 表达式初始化 $|用类型不兼容的表达式初始化类型}0,1|%diff{将类型 $ 发送到类型不兼容的参数 $|将类型发送给不兼容参数类型}0,1|%diff{将类型 $ 铸为类型不兼容的 $|将类型铸为不兼容类型}0,1}2%select{|; 通过 * 解引用|; 通过 & 获取地址|; 移除 *|; 移除 &}3%select{|: 不同的类%diff{ ($ vs $)|}5,6|: 参数数量不同 (%5 vs %6)|: 第 %ordinal5 参数类型不匹配%diff{ ($ vs $)|}6,7|: 返回类型不同%diff{ ($ vs $)|}5,6|: 限定符不同 (%5 vs %6)|: 异常规范不同}4'
# '%select{%select{increment|decrement}1 of readonly property|no setter method %2 for %select{increment|decrement}1 of property}0'
HAF55C5B7D9CC: '%select{%select{只读属性的递增|只读属性的递减}|缺少 %select{递增|递减}1 属性的设置方法 %2}0'
# "%select{%select{reference|'std::initializer_list'}0 member|member with %select{reference|'std::initializer_list'}0 subobject}1 declared here"
H1B5CDFE7B6DA: "%select{%select{引用|'std::initializer_list'}0 成员|%select{引用|'std::initializer_list'}0 子对象}1 在此处声明"
# "%select{'#pragma clang fp eval_method'|option 'ffp-eval-method'}0 cannot be used with %select{option 'fapprox-func'|option 'mreassociate'|option 'freciprocal'|option 'ffp-eval-method'|'#pragma clang fp reassociate'|'#pragma clang fp reciprocal'}1"
HD4A3AC42422A: "%select{'#pragma clang fp eval_method'|选项 '-ffp-eval-method'}0 不能与 %select{选项 '-fapprox-func'|选项 '-mreassociate'|选项 '-freciprocal'|选项 '-ffp-eval-method'|'#pragma clang fp reassociate'|'#pragma clang fp reciprocal'}1 一起使用"
# "%select{'auto'|'decltype(auto)'|'__auto_type'|template arguments}0 deduced as %1 in declaration of %2 and deduced as %3 in declaration of %4"
H11DB7A31A7DA: "%select{'auto'|'decltype(auto)'|'__auto_type'|模板参数}0 在 %2 的声明中推导为 %1，并在 %4 的声明中推导为 %3"
# "%select{'auto'|'decltype(auto)'|'__auto_type'|use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}2 %3 requires template arguments; argument deduction}0 not allowed %select{in function prototype|in non-static struct member|in struct member|in non-static union member|in union member|in non-static class member|in interface member|in exception declaration|in template parameter until C++17|in block literal|in template argument|in typedef|in type alias|in function return type|in conversion function type|here|in lambda parameter|in type allocated by 'new'|in K&R-style function parameter|in template parameter|in friend declaration|in function prototype that is not a function declaration|in requires expression parameter|in array declaration|in declaration of conversion function template|in lambda parameter before C++14}1"
H7226E87E7B56: "%select{'auto'|'decltype(auto)'|'__auto_type'|使用 %select{类模板|函数模板|变量模板|别名模板|模板模板参数|概念|模板}2 %3 需要模板参数；不允许进行参数推导}0 在 %select{函数原型|非静态结构成员|结构成员|非静态联合成员|联合成员|非静态类成员|接口成员|异常声明|C++17 之前的模板参数|块字面量|模板参数|typedef|类型别名|函数返回类型|转换函数类型|此处|lambda 参数|new 分配的类型|K&R 样式函数参数|模板参数|友元声明|非函数声明的函数原型|requires 表达式参数|数组声明|转换函数模板声明|C++14 之前的 lambda 参数}1 进行参数推导"
# "%select{'mutable'|'static'|'constexpr'|'consteval'}0 cannot appear multiple times in a lambda declarator"
HA9F29290F39F: "%select{'mutable'|'static'|'constexpr'|'consteval'}0 不能在 lambda 声明符中重复出现"
# "%select{'size' argument to memset is '0'|setting buffer to a 'sizeof' expression}0; did you mean to transpose the last two arguments?"
HBE450D9F2F6C: "%select{memset 的 'size' 参数为 '0'|使用 'sizeof' 表达式设置缓冲区}0；是否想交换最后两个参数？"
# '%select{<ERROR>|constexpr|consteval|constinit}0 can only be used in %select{|variable and function|function|variable}0 declarations'
H8ABC77B14403: '%select{<错误>|constexpr|consteval|constinit}0 只能用于 %select{|变量和函数|函数|变量}0 声明'
# '%select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is not a friend of %select{|incomplete class }1%2'
HFE0AE74FD7A7: '%select{<错误>|相等|三向|相等|关系}0 比较运算符不是 %select{|不完整类 }1%2 的友元'
# '%select{<error>|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments; argument deduction only allowed for class templates or alias templates'
HDE23AA7C6E82: '%select{<错误>|函数模板|变量模板|别名模板|模板模板参数|概念|模板}0 %1 需要模板参数；仅类模板或别名模板允许参数推导'
# '%select{@available|__builtin_available}0 does not guard availability here; use if (%select{@available|__builtin_available}0) instead'
HBA44F219FD20: '%select{@available|__builtin_available}0 不在此处进行可用性检查；请改用 if (%select{@available|__builtin_available}0)'
# "%select{AST file '%1' was|current translation unit is}0 compiled with the target feature '%2' but the %select{current translation unit is|AST file '%1' was}0 not"
H5C12AF216CA3: "%select{AST文件 '%1' 被|当前翻译单元使用}0 目标特性 '%2' 编译，但 %select{当前翻译单元未使用该特性|AST文件 '%1' 未被}0 使用"
# "%select{MIPS|MSP430|RISC-V|AVR}0 '%select{interrupt|signal}1' attribute only applies to functions that have %select{no parameters|a 'void' return type}2"
HC530D462FB18: "%select{MIPS|MSP430|RISC-V|AVR}0 '%select{interrupt|signal}1' 属性仅适用于 %select{无参数|返回类型为 'void' 的}2 函数"
# "%select{OpenACC '%3' construct|while loop|do loop}0 cannot appear in intervening code of a '%1' with a '%2' clause"
HB2C5F39C46C3: "%select{OpenACC '%3' 构造|while 循环|do 循环}0 不能出现在带有 '%2' 子句的 '%1' 中间代码段"
# "%select{OpenACC 'gang' clause with a 'dim' value greater than 1|OpenACC 'reduction' clause}0 cannot appear on the same '%1' construct as a %select{'reduction' clause|'gang' clause with a 'dim' value greater than 1}0"
H3449F0200ABB: "%select{OpenACC 'gang' 子句（dim 值大于1）|OpenACC 'reduction' 子句}0 不能与同一 '%1' 构造中的 %select{'reduction' 子句|'gang' 子句（dim 值大于1）}0 同时存在"
# '%select{OpenACC sub-array|OpenMP array section}0 is not allowed here'
H8129F6E36883: '%select{OpenACC 子数组|OpenMP 数组区间}0 在此处无效'
# '%select{PCH|current translation unit}0 has no VFS overlays'
H1F8E7EA59762: '%select{预编译头|当前翻译单元}0 没有虚拟文件系统覆盖层'
# '%select{PCH|current translation unit}0 has the following VFS overlays:\n%1'
HF3357458F7A1: '%select{预编译头|当前翻译单元}0 的虚拟文件系统覆盖层如下：\n%1'
# "%select{PCH|module|AST}0 file '%1' built from a different branch (%2) than the compiler (%3)"
H47225B26A402: "%select{预编译头|模块|AST}0 文件 '%1' 来自不同分支 (%2)，而当前编译器来自 (%3)"
# "%select{PCH|module|AST}0 file '%1' contains compiler errors"
H70FD1E0F0771: "%select{预编译头|模块|AST}0 文件 '%1' 包含编译错误"
# "%select{PCH|module|AST}0 file '%1' is out of date and needs to be rebuilt%select{|: %3}2"
H1F11095B483F: "%select{预编译头|模块|AST}0 文件 '%1' 已过期需要重新生成%select{|： %3}2"
# "%select{PCH|module|AST}0 file '%1' not found%select{|: %3}2"
HA37A363A734E: "%select{预编译头|模块|AST}0 文件 '%1' 未找到%select{|： %3}2"
# "%select{PCH|module|AST}0 file '%1' uses a newer format that cannot be read"
H80665252BAE8: "%select{预编译头|模块|AST}0 文件 '%1' 使用无法读取的新格式"
# "%select{PCH|module|AST}0 file '%1' uses an older format that is no longer supported"
HB4B0734241D0: "%select{预编译头|模块|AST}0 文件 '%1' 使用已不再支持的旧格式"
# '%select{__block variables|global variables|fields|instance variables}0 cannot have __autoreleasing ownership'
H8459C5DA92C1: '%select{__block 变量|全局变量|字段|实例变量}0 不能使用 __autoreleasing 所有权'
# '%select{__device__|__global__|__host__|__host__ __device__}0 function %1 cannot overload %select{__device__|__global__|__host__|__host__ __device__}2 function %3'
HD56CBB05D1A2: '%select{__device__|__global__|__host__|__host__ __device__}0 函数 %1 不能与 %select{__device__|__global__|__host__|__host__ __device__}2 函数 %3 重载'
# '%select{a reference type|an array type|a non-vector or non-vectorizable scalar type}0 is an invalid argument to attribute %1'
H9A7D97DDD421: '%select{一个引用类型|一个数组类型|一个非向量或不可向量化标量类型}0 是属性 %1 的无效参数'
# "%select{a variable|a parameter|'this'}0 cannot appear in more than one %1 clause"
HE09D18DCA51A: "%select{一个变量|一个参数|'this'}0 不能出现在超过一个 %1 子句中"
# '%select{address of|reference to}0 stack memory associated with %select{local variable|parameter|compound literal}2 %1 %select{returned|passed to musttail function}3'
HDE8352A90808: '%select{地址的|引用的}0 栈内存与 %select{局部变量|参数|复合字面量}2 %1 %select{返回|传递给 musttail 函数}3'
# '%select{alias|ifunc}0 definition is part of a cycle'
H75F8799A172C: '%select{别名|ifunc}0 定义属于一个循环'
# '%select{alias|ifunc}0 must point to a defined %select{variable or |}1function'
HA8FBD807C04A: '%select{别名|ifunc}0 必须指向已定义的 %select{变量或 |}1 函数'
# "%select{alias|ifunc}1 will not be in section '%0' but in the same section as the %select{aliasee|resolver}2"
H14919DB80F8A: "%select{别名|ifunc}1 将不会位于 '%0' 节中，而是与 %select{别名目标|解析器}2 处于相同的节"
# '%select{alias|ifunc}2 will always resolve to %0 even if weak definition of %1 is overridden'
H739E4FBA0F0D: '%select{别名|ifunc}2 将始终解析为 %0 即使 %1 的弱定义被覆盖'
# '%select{aligning a value|the result of checking whether a value is aligned}0 to 1 byte is %select{a no-op|always true}0'
H6A34843E702F: '%select{将值对齐|检查值是否对齐的结果}0 到 1 字节是 %select{无操作|始终为真}0'
# '%select{alignment of|offset of the aligned pointer from}0 the base pointee object (%1 %plural{1:byte|:bytes}1) is %select{less than|not a multiple of}0 the asserted %2 %plural{1:byte|:bytes}2'
H473934A0D013: '%select{基对象指针的对齐值|对齐指针与基对象的偏移量}0 (%1 %plural{1:字节|:字节}1) 小于或不是 %select{对齐值的倍数|所声明的}0 %2 %plural{1:字节|:字节}2 的倍数'
# '%select{alignment|size}0 of field %1 (%2 bits) does not match the %select{alignment|size}0 of the first field in transparent union; transparent_union attribute ignored'
HF5A022BDF3DB: '%select{对齐值|大小}0 的字段 %1 (%2 位) 与透明联合中第一个字段的 %select{对齐值|大小}0 不匹配；透明联合属性被忽略'
# '%select{alignment|size}0 of first field is %1 bits'
H996CEE2D3252: '%select{对齐值|大小}0 的第一个字段是 %1 位'
# '%select{all|second and third}0 arguments to %1 must be of scalar or vector type with matching scalar element type%diff{: $ vs $|}2,3'
HE09C48EB126A: '%select{所有|第二个和第三个}0 参数到 %1 必须为标量或向量类型且具有匹配的标量元素类型%diff{: $ vs $|}2,3'
# '%select{an attribute specifier sequence|%0}1 in this position is a C++23 extension'
H561F9F6DB91B: '%select{属性说明符序列|%0}1 在此位置是 C++23 扩展'
# '%select{an attribute specifier sequence|%1}0 in this position is incompatible with C++ standards before C++23'
HEF130F97BB12: '%select{属性说明符序列|%1}0 在此位置与 C++23 之前的版本不兼容'
# '%select{and|because}0 %1 does not satisfy %2'
H1152B396A251: '%select{并且|因为}0 %1 不满足 %2'
# '%select{and|because}0 %1 does not satisfy %2:'
H7FDA8323151A: '%select{并且|因为}0 %1 不满足 %2:'
# "%select{and|because}0 '%1' (%2 %3 %4) evaluated to false"
H5A2EAB383E7A: "%select{并且|因为}0 '%1' (%2 %3 %4) 的求值结果为 false"
# "%select{and|because}0 '%1' evaluated to false"
HD9EC26C0E6B0: "%select{并且|因为}0 '%1' 的求值结果为 false"
# "%select{and|because}0 '%1' may throw an exception"
HA87D7335D9EB: "%select{并且|因为}0 '%1' 可能抛出异常"
# "%select{and|because}0 '%1' would be invalid"
HAD3CC48247E5: "%select{并且|因为}0 '%1' 将会无效"
# "%select{and|because}0 '%1' would be invalid%2"
HEF46AC24BE27: "%select{并且|因为}0 '%1' 将会无效%2"
# "%select{and|because}0 '%1' would be invalid: %2"
HD3831227C190: "%select{并且|因为}0 '%1' 会导致无效：%2"
# "%select{and|because}0 type constraint '%1' was not satisfied:"
HD561B1DB876A: "%select{并且|因为}0 类型约束 '%1' 未满足："
# '%select{anonymous struct|union}0 member %1 has a non-trivial %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2'
H443C398B6494: '%select{匿名结构体|联合体}0 成员 %1 具有非平凡的 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}2'
# '%select{anonymous struct|union}0 member %1 with a non-trivial %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2 is incompatible with C++98'
HE6728E1CAD49: '%select{匿名结构体|联合体}0 成员 %1 具有非平凡的 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}2 与 C++98 不兼容'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3'
H510A2D2A82E0: '%select{浮点型|枚举类型}1 类型 %2 %plural{2:与|4:来自|:和}0 %select{枚举|浮点型}1 类型 %3 之间的%select{算术运算|按位运算|比较|条件表达式|复合赋值}0'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3 is deprecated'
H08C01E0FFD79: '%select{浮点型|枚举类型}1 类型 %2 %plural{2:与|4:来自|:和}0 %select{枚举|浮点型}1 类型 %3 之间的%select{算术运算|按位运算|比较|条件表达式|复合赋值}0 已弃用'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2'
H15481858FE39: '%select{不同枚举类型的算术运算|不同枚举类型的按位运算|不同枚举类型的比较|不同枚举类型的条件表达式|不同枚举类型的复合赋值}0%diff{ ($和$)|}1,2'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2 is deprecated'
HB2E74DC62C72: '%select{不同枚举类型的算术运算|不同枚举类型的按位运算|不同枚举类型的比较|不同枚举类型的条件表达式|不同枚举类型的复合赋值}0%diff{ ($和$)|}1,2 是已弃用的'
# '%select{assignment to readonly property|no setter method %1 for assignment to property}0'
H7FB56A6FE5D6: '%select{将只读属性赋值|属性赋值没有设置器方法 %1}0'
# '%select{base class|inherited virtual base class}0 %1 has %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR*|}2constructor'
H3EE5604475F7: '%select{基类|继承的虚基类}0 %1 具有%select{私有|受保护}3 %select{默认 |拷贝 |移动 |*ERROR* |*ERROR* |*ERROR*|}2构造函数'
# '%select{bit-field %1|anonymous bit-field}0 is too wide (%2 bits)'
H4CB82469419C: '%select{位段 %1|匿名位段}0 过宽（%2 位）'
# "%select{block pointer|pointer|reference}0 to function type %select{%2 |}1cannot have '%3' qualifier"
H0BABB964A63A: "%select{块指针|指针|引用}0 到函数类型 %select{%2 |}1 不能带有 '%3' 限定符"
# '%select{call to non-static member function|use of non-static data member}0 %2 of %1 from nested type %3'
H4DA493B4F5FF: '%select{调用非静态成员函数|使用非静态数据成员}0 %2 的 %1 来自嵌套类型 %3'
# '%select{cannot assign to return value because function %1 returns a const value|cannot assign to variable %1 with const-qualified type %2|cannot assign to %select{non-|}1static data member %2 with const-qualified type %3|cannot assign to non-static data member within const member function %1|cannot assign to %select{variable %2|non-static data member %2|lvalue}1 with %select{|nested }3const-qualified data member %4|read-only variable is not assignable}0'
H957C121C1C4E: '%select{不能将返回值赋值因为函数 %1 返回 const 值|不能将 const 限定类型 %2 的变量 %1 赋值|不能将 const 限定类型 %3 的%select{非-|}1静态数据成员 %2 赋值|不能在 const 成员函数 %1 内对非静态数据成员赋值|不能对%select{变量 %2|非静态数据成员 %2|左值}1 赋值，因为其%select{|嵌套 }3const 限定数据成员 %4|只读变量不可赋值}0'
# "%select{case value|enumerator value|non-type template argument|non-type parameter of template template parameter|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'}0 %select{cannot be narrowed from type %2 to %3|evaluates to %2, which cannot be narrowed to type %3}1"
HECF4733C9DA0: "%select{情况值|枚举值|非类型模板实参|模板模板参数的非类型参数|数组大小|显式说明符实参|noexcept 说明符实参|调用'size()'|调用'data()'}0 %select{不能从类型 %2 窄化到 %3|计算为 %2，无法窄化为类型 %3}1"
# "%select{case value|enumerator value|non-type template argument|non-type parameter of template template parameter|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'}0 is not a constant expression"
HFB41B693F137: "%select{情况值|枚举值|非类型模板实参|模板模板参数的非类型参数|数组大小|显式说明符实参|noexcept 说明符实参|调用'size()'|调用'data()'}0 不是常量表达式"
# '%select{cast|implicit conversion}0 of %select{Objective-C|block|C}1 pointer type %2 to %select{Objective-C|block|C}3 pointer type %4 requires a bridged cast'
H312933E2115D: '%select{转换|隐式转换}0 %select{Objective-C|块|C}1 指针类型 %2 到 %select{Objective-C|块|C}3 指针类型 %4 需要桥接转换'
# '%select{category %1|class extension}0 cannot conform to protocol %2 because of direct members declared in interface %3'
H86E18740A145: '%select{分类 %1|类扩展}0 因为在接口 %3 中声明的直接成员，无法符合协议 %2'
# '%select{category|class extension}0 conforms to protocol %1 which defines method %2'
H1219B6B58D30: '%select{分类|类扩展}0 符合协议 %1，其中定义了方法 %2'
# '%select{character|integer}0 literal with user-defined suffix cannot be used in preprocessor constant expression'
HF3B4B5DEEBAB: '%select{字符|整数}0 字面量带有用户定义后缀，不能在预处理器常量表达式中使用'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 must occur at global scope'
HB1B7C78CE71E: '%select{类模板|类模板部分|变量模板|变量模板部分|函数模板|成员函数|静态数据成员|成员类|枚举类型}0 特化 %1 必须出现在全局作用域中'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3'
HFB74AB926D65: '%select{类模板|类模板部分|变量模板|变量模板部分|函数模板|成员函数|静态数据成员|成员类|枚举类型}0 特化 %1 不在 %select{包含 %2 的命名空间中|类 %2 或其上层命名空间}3'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3 is a Microsoft extension'
H61AEC4FCDF68: '%select{类模板|类模板部分|变量模板|变量模板部分|函数模板|成员函数|静态数据成员|成员类|枚举类型}0 特化 %1 不在 %select{包含 %2 的命名空间中|类 %2 或其上层命名空间}3 是 Microsoft 扩展'
# '%select{class|instance}0 method %1 also declared here'
H40D03C99413F: '%select{类|实例}0 方法 %1 还在这里声明'
# '%select{class|instance}0 method %1 has a different number of parameters in different translation units (%2 vs. %3)'
H1C2BED5A5D12: '%select{类|实例}0 方法 %1 在不同翻译单元中的参数数量不同 (%2 vs. %3)'
# '%select{class|instance}0 method %1 has a parameter with a different types in different translation units (%2 vs. %3)'
H27FF7F628706: '%select{类|实例}0 方法 %1 在不同翻译单元中的参数类型不同 (%2 vs. %3)'
# '%select{class|instance}0 method %1 has incompatible result types in different translation units (%2 vs. %3)'
H81568F1228D2: '%select{类|实例}0 方法 %1 在不同翻译单元中的返回类型不兼容 (%2 vs. %3)'
# '%select{class|instance}0 method %1 is assumed to return an instance of its receiver type (%2)'
H57512855C27C: '%select{类|实例}0 方法 %1 默认返回接收者的实例类型 (%2)'
# '%select{class|instance}0 method %1 is variadic in one translation unit and not variadic in another'
HF51A27778394: '%select{类|实例}0 方法 %1 在一个翻译单元中是可变参数函数而在另一个中不是'
# '%select{class|protocol|category|class extension|implementation|category implementation}0 started here'
HB972B56B97CE: '%select{类|协议|分类|类扩展|实现|分类实现}0 在此处开始'
# '%select{class|struct|interface|union|enum|enum class|enum struct}0 cannot be marked %select{<ERROR>|constexpr|consteval|constinit}1'
H6CC4F10FF6EF: '%select{类|结构体|接口|联合体|枚举|枚举类|枚举结构体}0 无法被标记为%select{<ERROR>|constexpr|consteval|constinit}1'
# '%select{class|type alias}0 template declared here'
HC92E96CB1535: '%select{类|类型别名}0 模板在此处声明'
# '%select{class|variable}0 template partial specialization contains %select{a template parameter|template parameters}1 that cannot be deduced; this partial specialization will never be used'
H8F8D0B49DE65: '%select{类|变量}0 的模板偏特化包含 %select{无法推导的模板参数|无法推导的模板参数}1，该偏特化将永远不会被使用'
# '%select{class|variable}0 template partial specialization does not specialize any template argument; to %select{declare|define}1 the primary template, remove the template argument list'
HC805ED783ADF: '%select{类|变量}0 模板部分特化未特化任何模板参数；要 %select{声明|定义}1 主模板，请移除模板参数列表'
# '%select{class|variable}0 template partial specialization is not more specialized than the primary template'
HD6682742D913: '%select{类|变量}0 模板部分特化并不比主模板更具体'
# '%select{codeseg|section}0 does not match previous declaration'
H9AFE01E1A06A: '%select{代码段|节}0 与之前的声明不匹配'
# "%select{command line contains|AST file '%1' was built with}0 '-detailed-preprocessing-record' but %select{AST file '%1' was not built with it|it is not present on the command line}0"
H668E0E039D43: "%select{命令行包含|AST 文件 '%1' 是使用}0 '-detailed-preprocessing-record' 编译的，但 %select{AST 文件 '%1' 未使用该选项|命令行未指定该选项}0"
# "%select{command line contains|AST file '%1' was built with}0 '-undef' but %select{AST file '%1' was not built with it|it is not present on the command line}0"
H8E60AF265E55: "%select{命令行包含|AST 文件 '%1' 是使用}0 '-undef' 编译的，但 %select{AST 文件 '%1' 未使用该选项|命令行未指定该选项}0"
# '%select{comparison between %diff{ ($ and $)|}0,1|arithmetic operation with operands of type %diff{ ($ and $)|}0,1|conditional operator with the second and third operands of type %diff{ ($ and $)|}0,1}2 which are pointers to non-overlapping address spaces'
H47A4B5F7D5D9: '%select{涉及 %diff{ ($ 和 $)|}0,1 的比较|运算符的操作数类型为 %diff{ ($ 和 $)|}0,1|条件运算符的第二个和第三个操作数类型为 %diff{ ($ 和 $)|}0,1}2 其指针指向不同地址空间'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 converts between mismatching address spaces'
HB50BD1C6F363: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C 风格强制转换|函数式强制转换|addrspace_cast}0 从 %1 转换到 %2 在不匹配的地址空间之间进行'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 is not allowed'
H0994EC770949: '从类型 %1 到 %2 的 %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 转换不允许'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from rvalue to reference type %2'
H79F10447DC2A: '从右值到引用类型 %2 的 %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 转换'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 casts away qualifiers'
H56EB9B5EABD1: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 从 %1 到 %2 的转换去除了限定符'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2, which are not related by inheritance, is not allowed'
HC3DB71EF3442: '从 %1 到 %2 的 %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 转换不允许，因为它们之间没有继承关系'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from bit-field lvalue to reference type %2'
H1DAD5B4DA5AC: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 从位段左值到引用类型 %2 的转换'
# '%select{const_cast||||C-style cast|functional-style cast|}0 to %2, which is not a reference, pointer-to-object, or pointer-to-data-member'
H2773305E9004: '%select{const_cast||||C-style cast|functional-style cast|}0 转换到 %2，其不是引用、对象指针或数据成员指针'
# "%select{constexpr|consteval}0 function's return type %1 is not a literal type"
H8C05F94E8F5F: '%select{constexpr|consteval}0 函数的返回类型 %1 不是字面类型'
# '%select{constexpr|consteval}1 %select{function|constructor}0 never produces a constant expression'
H022CBA14DE42: '%select{constexpr|consteval}1 %select{函数|构造函数}0 的常量表达式计算始终失败'
# "%select{constexpr|consteval}2 %select{function|constructor}1's %ordinal0 parameter type %3 is not a literal type"
H6B5DAAD976BB: '%select{constexpr|consteval}2 %select{函数|构造函数}1 的第 %ordinal0 个参数类型 %3 不是字面类型'
# '%select{constructor for %1 must explicitly initialize the|implicit default constructor for %1 must explicitly initialize the|cannot use constructor inherited from base class %4;}0 %select{base class|member}2 %3 %select{which|which|of %1}0 does not have a default constructor'
HE93B407A4DE4: '%select{构造函数 %1 必须显式初始化|隐式默认构造函数 %1 必须显式初始化|不能使用从基类 %4 继承的构造函数;}0 %select{基类|成员}2 %3 %select{未|未|在 %1 中}0 具有默认构造函数'
# '%select{constructor for %1|implicit default constructor for %1|cannot use constructor inherited from %1:}0 must explicitly initialize the %select{reference|const}2 member %3'
H5DD624CAFF41: '%select{构造函数 %1|隐式默认构造函数 %1|不能使用从 %1 继承的构造函数:}0 必须显式初始化 %select{引用|const}2 成员 %3'
# '%select{constructor|destructor}1 %0 must not return void expression'
H76E14738E327: '%select{构造函数|析构函数}1 %0 不得返回 void 表达式'
# '%select{const|reference}0 member %1 will never be initialized'
H67E2118A2E7C: '%select{const|引用}0 成员 %1 将永远不会被初始化'
# '%select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1 invokes deleted constructor'
HE9CE7E623BF3: '%select{复制变量|复制参数|初始化模板参数|返回对象|初始化表达式结果|抛出对象|复制成员子对象|复制数组元素|分配对象|复制临时|初始化基类子对象|初始化向量元素|捕获值}0 类型为 %1 的对象调用了已删除的构造函数'
# '%select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}1 of type %2 when binding a reference to a temporary would %select{invoke an inaccessible constructor|find no viable constructor|find ambiguous constructors|invoke a deleted constructor}0 in C++98'
H29AE4DB3DE15: '在 C++98 中，%select{复制变量|复制参数|初始化模板参数|返回对象|初始化表达式结果|抛出对象|复制成员子对象|复制数组元素|分配对象|复制临时|初始化基类子对象|初始化向量元素|捕获值}1 类型为 %2 的对象，在绑定临时引用时会 %select{调用不可访问的构造函数|找不到有效构造函数|存在二义性构造函数|调用了已删除的构造函数}0'
# '%select{copy|move}0 assignment operator of %1 is implicitly deleted because field %2 is of %select{reference|const-qualified}4 type %3'
HA5E40C813D22: '%select{拷贝|移动}0 赋值运算符 %1 被隐式删除，因为字段 %2 是 %select{引用|const限定}4 类型 %3'
# '%select{data member %1|base class %2}0 declared here'
HC9ED4A45B57E: '%select{数据成员 %1|基类 %2}0 在此处声明'
# '%select{data member |non-public member function |static member function |user-declared constructor|user-declared destructor|operator |nested class }0%1 is not permitted within an interface type'
H9EC34E188C56: '%select{数据成员 |非公开成员函数 |静态成员函数 |用户声明构造函数|用户声明析构函数|运算符 |嵌套类 }0%1 不允许出现在接口类型中'
# '%select{declaration|definition|default argument declared|explicit specialization declared|partial specialization declared}0 here is not %select{visible|reachable|reachable|reachable|reachable|reachable}0'
H804351062C9E: '%select{声明|定义|默认参数声明|显式特化声明|部分特化声明}0 此处的 %select{不可见|不可达|不可达|不可达|不可达|不可达}0'
# "%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from module '%2' before it is required"
HC491502A3888: "%select{声明|定义|默认参数|显式特化|部分特化}0 的 %1 必须在需要前从模块 '%2' 导入"
# '%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from one of the following modules before it is required:%2'
HA8E1DF60359B: '%select{声明|定义|默认参数|显式特化|偏特化}0的%1必须在需要前从以下模块导入：%2'
# '%select{declaration|definition}0 of %select{struct|interface|union|class|enum}1 in a dependent scope'
H690477FDDE60: '%select{声明|定义}0的%select{结构体|接口|联合|类|枚举}1在依赖作用域中'
# '%select{decremented|incremented}0 here'
HD8461A402F1F: '此处%select{递减|递增}0'
# '%select{decrement|increment}0 of object of volatile-qualified type %1 is deprecated'
H57C759966E48: '%select{递减|递增}0类型为volatile限定的%1的对象已弃用'
# '%select{default construction|assignment}0 of lambda is incompatible with C++ standards before C++20'
H3C92D92BB26F: '%select{默认构造|赋值}0的lambda与C++20之前的C++标准不兼容'
# '%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because all %select{data members|data members of an anonymous union member}2 are const-qualified'
HF80E1E94C448: '%select{的默认构造函数|继承构造函数}0%1因所有%select{数据成员|匿名联合成员的数据成员}2为const限定而隐式删除'
# '%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because field %2 of %select{reference|const-qualified}4 type %3 would not be initialized'
H3F45472DFCD6: '%select{的默认构造函数|继承构造函数}0 %1 被隐式删除，因为字段 %2 的 %select{引用|const限定}4 类型 %3 未被初始化'
# '%select{default constructor of|copy constructor of|move constructor of|copy assignment operator of|move assignment operator of|destructor of|constructor inherited by}0 %1 is implicitly deleted because %select{base class %3|%select{||||variant }4field %3}2 %select{has %select{no|a deleted|multiple|an inaccessible|a non-trivial}4 %select{%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|%select{default|corresponding|default|default|default}4 constructor}0|destructor}5%select{||s||}4|is an ObjC pointer}6'
H1BB10C6BA0EA: '%select{的默认构造函数|的复制构造函数|的移动构造函数|的复制赋值运算符|的移动赋值运算符|的析构函数|继承构造函数}0%1因%select{基类%3|%select{||||variant }4字段%3}2%select{具有%select{无|被删除的|多个|不可访问的|非平凡的}4%select{%select{默认构造函数|复制构造函数|移动构造函数|复制赋值运算符|移动赋值运算符|析构函数|%select{默认|对应|默认|默认|默认}4构造函数}0|析构函数}5%select{||s||}4|是ObjC指针}6而隐式删除'
# "%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be 'constexpr' in a class with virtual base class"
HAA0AD1F4C5AC: '%select{默认构造函数|复制构造函数|移动构造函数|复制赋值运算符|移动赋值运算符|析构函数}0在具有虚基类的类中不能为constexpr'
# '%select{defaulted|deleted}0 function definitions are a C++11 extension'
H2588FE2C83FF: '%select{默认化|删除化}0函数定义是C++11扩展'
# '%select{defaulted|deleted}0 function definitions are incompatible with C++98'
HE7CB963644EA: '%select{默认化|删除化}0函数定义与C++98不兼容'
# "%select{definition|#undef}0 of configuration macro '%1' has no effect on the import of '%2'; pass '%select{-D%1=...|-U%1}0' on the command line to configure the module"
H20DEB068BA86: "%select{定义|#undef}0的配置宏'%1'对导入'%2'无影响；请通过命令行传递'%select{-D%1=...|-U%1}0'配置模块"
# '%select{delete|destructor}0 called on %1 that is abstract but has non-virtual destructor'
HD3B2B405330A: '对具有非虚析构函数的抽象%1调用%select{delete|析构函数}0'
# '%select{delete|destructor}0 called on non-final %1 that has virtual functions but non-virtual destructor'
HD186820BFF8C: '对非final且包含虚函数但非虚析构函数的%1调用%select{delete|析构函数}0'
# '%select{delimited|named}0 escape sequences are a %select{C++23|C2y|Clang}1 extension'
HDBE05BE4D14B: '%select{限定|命名}0转义序列是%select{C++23|C2y|Clang}1扩展'
# '%select{delimited|named}0 escape sequences are incompatible with C++ standards before C++23'
HFB62920439FF: '%select{限定|命名}0转义序列与C++23之前的C++标准不兼容'
# '%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to %select{|class containing a }2dynamic class %3; vtable pointer will be %select{overwritten|copied|moved|compared}4'
H63A8D05F544B: '此%1调用的%select{目标|源|第一个操作数|第二个操作数}0是指向%select{|包含动态类的类}2%3的指针；vtable指针将被%select{覆盖|复制|移动|比较}4'
# '%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to record %2 that is not trivial to %select{primitive-default-initialize|primitive-copy}3'
HB6A0DAA8C1C8: '%select{此 %1 调用的|源|第一个操作数的|第二个操作数的}0 目标是指向非 %select{原始默认初始化|原始复制}3 类型 %2 的指针'
# '%select{destination for|source of}0 this %1 call is a pointer to ownership-qualified type %2'
HEE4DB03498AC: '此%1调用的%select{目标|源}0是指向所有权限定类型%2的指针'
# '%select{destructor|deallocator}0 has a %select{non-throwing|implicit non-throwing}1 exception specification'
H78E56ACB6245: '%select{析构函数|解分配器}0具有%select{不抛出异常的|隐式不抛出异常的}1异常规范'
# '%select{dictionary|array}1 subscript base type %0 is not an Objective-C object'
HE2828D54BB1B: '%select{字典|array}1 下标基类型 %0 不是 Objective-C 对象'
# '%select{equality|inequality|relational|three-way}0 comparison result unused'
H69C6598EFBD9: '%select{相等|不等|关系|三向}0 比较结果未被使用'
# '%select{expected an expression statement|expected built-in assignment operator|expected expression of scalar type|expected lvalue expression}0'
H7F94DE3BA105: '%select{期望表达式语句|期望内置赋值运算符|期望标量类型表达式|期望左值表达式}0'
# "%select{expected an expression statement|expected built-in binary or unary operator|expected unary decrement/increment operation|expected expression of scalar type|expected assignment expression|expected built-in binary operator|expected one of '+', '*', '-', '/', '&', '^', '%|', '<<', or '>>' built-in operations|expected in right hand side of expression}0"
H13014A5049BE: "%select{期望表达式语句|期望内置二元或一元运算符|期望一元增减运算|期望标量类型表达式|期望赋值表达式|期望内置二元运算符|期望 '+' '*' '-' '/' '&' '^' '%' '|' '<<' 或 '>>' 内置运算|期望在表达式右侧}0"
# '%select{expected assignment expression|expected compound statement|expected exactly two expression statements|expected in right hand side of the first expression}0'
H71EE048AAB44: '%select{期望赋值表达式|期望复合语句|期望恰好两个表达式语句|期望在第一个表达式右侧}0'
# "%select{expected compound statement|expected exactly one expression statement|expected assignment statement|expected conditional operator|expect result value to be at false expression|expect binary operator in conditional expression|expect '<', '>' or '==' as order operator|expect comparison in a form of 'x == e', 'e == x', 'x ordop expr', or 'expr ordop x'|expect lvalue for result value|expect scalar value|expect integer value|unexpected 'else' statement|expect '==' operator|expect an assignment statement 'v = x'|expect a 'if' statement|expect no more than two statements|expect a compound statement|expect 'else' statement|expect a form 'r = x == e; if (r) ...'}0"
H2BEDF1CDD9ED: "%select{期望复合语句|期望恰好一个表达式语句|期望赋值语句|期望条件运算符|期望假分支结果值|期望条件表达式中的二元运算符|期望 '<' '>' 或 '==' 作为顺序运算符|期望 'x == e' 'e == x' 'x ordop expr' 或 'expr ordop x' 形式的比较|期望左值作为结果值|期望标量值|期望整数值|意外的 'else' 语句|期望 '==' 运算符|期望赋值语句 'v = x'|期望 'if' 语句|期望不超过两个语句|期望复合语句|期望 'else' 语句|期望 'r = x == e; if (r) ...' 形式}0"
# '%select{explicit|friend}0 specialization cannot have a trailing requires clause unless it declares a function template'
H4B8C1F1CA2BB: '%select{显式|友元}0 特殊化除非声明函数模板，否则不能有尾随 requires 子句'
# '%select{expression|base type|declaration type|data member type|bit-field size|static assertion|fixed underlying type|enumerator value|using declaration|friend declaration|qualifier|initializer|default argument|non-type template parameter type|exception type|explicit specialization|partial specialization|__if_exists name|__if_not_exists name|lambda|block|type constraint|requirement|requires clause}0 contains%plural{0: an|:}1 unexpanded parameter pack%plural{0:|1: %2|2:s %2 and %3|:s %2, %3, ...}1'
HE9A8E0B2E8F5: '%select{表达式|基类型|声明类型|数据成员类型|位段大小|静态断言|固定底层类型|枚举值|使用声明|友元声明|限定符|初始化器|默认参数|非类型模板参数类型|异常类型|显式特殊化|部分特殊化|__if_exists 名称|__if_not_exists 名称|lambda|block|类型约束|需求|requires 子句}0 包含%plural{0: 一个|:}1 未展开的参数包%plural{0:|1: %2|2:s %2 和 %3|:s %2, %3, ...}1'
# '%select{extension|category}0 of non-parameterized class %1 cannot have type parameters'
H6F4F8CBFDF9B: '%select{扩展|分类}0 非参数化类 %1 不能有类型参数'
# '%select{fewer|more}0 specifiers in format string than expected'
H294968301C0D: '%select{比预期少|比预期多}0 格式字符串说明符'
# "%select{field width|precision}0 used with '%1' conversion specifier, resulting in undefined behavior"
H2CF9930D6217: " '%1' 转换说明符使用了%select{字段宽度|精度}0，导致未定义行为"
# '%select{field|base class}0 %1 will be initialized after %select{field|base}2 %3'
HE92BDD84B944: '%select{字段|基类}0 %1 将在 %select{字段|基类}2 %3 之后被初始化'
# '%select{first two|all}1 arguments to %0 must be vectors'
HF5292D19FFBC: '%select{前两个|所有}1 个 %0 参数必须是向量类型'
# '%select{first two|all}1 arguments to %0 must have the same type'
H648C1151AF74: '%select{前两个|所有}1 个 %0 参数必须具有相同类型'
# "%select{first|second|third|fourth}0 parameter of 'main' (%select{argument count|argument array|environment|platform-specific data}0) must be of type %1"
HF5B9D5CD8E73: "%select{第一个|第二个|第三个|第四个}0 'main' 参数 (%select{参数计数|参数数组|环境|平台特定数据}0) 必须为类型 %1"
# '%select{first|second|third}0 parameter has unexpected type %1 (should be %2)'
HB94305DC6AD8: '%select{第一个|第二个|第三个}0 参数类型意外 %1（应为 %2）'
# '%select{first|second}0 operand was implicitly converted to type %1'
HBF77ADC8F095: '%select{第一个|第二个}0 操作数被隐式转换为类型 %1'
# '%select{forward class declaration|class definition|category|extension}0 has too %select{few|many}1 type parameters (expected %2, have %3)'
HF027D432E158: '%select{前向类声明|类定义|分类|扩展}0 的类型参数 %select{太少|太多}1（预期 %2，实际 %3）'
# '%select{function %1 which returns const-qualified type %2 declared here|variable %1 declared const here|%select{non-|}1static data member %2 declared const here|member function %q1 is declared const here|%select{|nested }1data member %2 declared const here}0'
HA9209A7005BD: '%select{返回const限定类型%2的函数%1在此声明|在此声明为const的变量%1|非%select{静态|匿名}1数据成员%2在此声明为const|在此声明为const的成员函数%q1|%select{嵌套|}1数据成员%2在此声明为const}0'
# '%select{function parameter|typedef}0 cannot be %select{<ERROR>|constexpr|consteval|constinit}1'
H86C3A8B0C257: '%select{函数参数|typedef}0 不能是 %select{<ERROR>|constexpr|consteval|constinit}1'
# '%select{function template|class template|variable template|type alias template|template template parameter}0 %1 declared here'
H91E08CCD64B6: '%select{函数模板|类模板|变量模板|类型别名模板|模板模板参数}0 %1 在此处声明'
# '%select{function with deduced return type|declaration with trailing return type}0 must be the only declaration in its group'
HA1CB6C2DD073: '%select{具有推导返回类型的函数|带有尾随返回类型的声明}0 必须是其组中唯一的声明'
# "%select{function|block|lambda|coroutine}0 declared 'noreturn' should not return"
HBB674CBF2E79: "%select{函数|代码块|lambda|协程}0 声明为 'noreturn' 不应返回"
# "%select{function|class|variable}0 cannot be defined in an explicit instantiation; if this declaration is meant to be a %select{function|class|variable}0 definition, remove the 'template' keyword"
HF2F19E25243A: "%select{函数|类|变量}0 不能在显式实例化中定义；如果此声明旨在作为 %select{函数|类|变量}0 的定义，请移除 'template' 关键字"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not %select{allocate or deallocate memory|throw or catch exceptions|have static local variables|use thread-local variables|access ObjC methods or properties}2"
H8DE43E9D40B0: "%select{函数|构造函数|析构函数|lambda|代码块|构造函数的成员初始化器}0 具有 '%1' 属性，不得 %select{分配或释放内存|抛出或捕获异常|具有静态局部变量|使用线程局部变量|访问ObjC方法或属性}2"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not call non-'%1' %select{function|constructor|destructor|lambda|block}2 '%3'"
HD57CFC80D164: "%select{函数|构造函数|析构函数|lambda|代码块|构造函数的成员初始化器}0 具有 '%1' 属性，不得调用非 '%1' %select{函数|构造函数|析构函数|lambda|代码块}2 '%3'"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not call non-'%1' expression"
H5BD0868978EA: "%select{函数|构造函数|析构函数|lambda|代码块|构造函数的成员初始化器}0 具有 '%1' 属性，不得调用非 '%1' 表达式"
# "%select{function|constructor|destructor|lambda|block|member initializer}0 cannot be inferred '%1' because it %select{allocates or deallocates memory|throws or catches exceptions|has a static local variable|uses a thread-local variable|accesses an ObjC method or property}2"
H2867CEC6E928: "%select{函数|构造函数|析构函数|lambda|代码块|成员初始化器}0 无法推断 '%1' 属性，因为其 %select{分配或释放内存|抛出或捕获异常|具有静态局部变量|使用线程局部变量|访问ObjC方法或属性}2"
# "%select{function|constructor|destructor|lambda|block|member initializer}0 cannot be inferred '%1' because it calls non-'%1' %select{function|constructor|destructor|lambda|block}2 '%3'"
H314F30794920: "%select{函数|构造函数|析构函数|lambda|代码块|成员初始化器}0 无法推断 '%1' 属性，因为其调用了非 '%1' %select{函数|构造函数|析构函数|lambda|代码块}2 '%3'"
# "%select{function|constructor|destructor|lambda|block}0 does not permit inference of '%1' because it is declared '%2'"
HB9A03E541F67: "%select{函数|构造函数|析构函数|lambda|代码块}0 无法推断 '%1' 属性，因其已被声明为 '%2'"
# "%select{function|constructor|destructor|lambda|block}0 with '%1' attribute should be declared noexcept"
HB030E37D6AD6: "%select{函数|构造函数|析构函数|lambda|代码块}0 具有 '%1' 属性时应声明为 noexcept"
# "%select{function|kernel}0 cannot be called 'main'"
H12368C59A019: "%select{函数|内核函数}0 不能名为 'main'"
# '%select{function|method|block}0 has been explicitly marked sentinel here'
H02C89F36F346: '%select{函数|方法|代码块}0 在此处被显式标记为 sentinel'
# "%select{function|method}0 %1 could be declared with attribute 'noreturn'"
H2A06C5AB5A01: "%select{函数|方法}0 %1 可以用属性 'noreturn' 进行声明"
# "%select{function|parameter}0 declared '[[carries_dependency]]' after its first declaration"
HA7BEBD006826: "%select{函数|参数}0 声明为 '[[carries_dependency]]'，但此属性出现在其首次声明之后"
# '%select{function|variable}0 %1 is not needed and will not be emitted'
HF8ADE574A433: '%select{函数|变量}0 %1 未被使用且将不会被编译'
# '%select{function|variable}0 %q1 has internal linkage but is not defined'
H45C099CD2E21: '%select{函数|变量}0 %q1 具有内部链接但未被定义'
# '%select{function|variable}0 %q1 is used but not defined in this translation unit, and cannot be defined in any other translation unit because its type does not have linkage'
H4CCCEB729733: '%select{函数|变量}0 %q1 在此翻译单元中被使用但未定义，且其类型无链接性，因此无法在其他翻译单元中定义'
# '%select{global|private}0 module fragment cannot be exported'
H32D31F303DCC: '%select{全局|私有}0 模块片段无法被导出'
# '%select{hex|octal}0 escape sequence out of range'
HD900722CD654: '%select{十六进制|八进制}0 转义序列超出范围'
# '%select{if|switch}0 initialization statements are incompatible with C++ standards before C++17'
H48F2A35749E7: '%select{if|switch}0 初始化语句与 C++17 之前的 C++ 标准不兼容'
# '%select{implicit conversion|cast}0 of %select{%2|a non-Objective-C pointer type %2|a block pointer|an Objective-C pointer|an indirect pointer to an Objective-C pointer}1 to %3 is disallowed with ARC'
H2BE56E173B04: '%select{隐式转换|强制类型转换}0 将 %select{%2|非 Objective-C 指针类型 %2|块指针|Objective-C 指针|指向 Objective-C 指针的间接指针}1 转换为 %3 在 ARC 中不允许'
# '%select{implicit conversion|cast}0 of weak-unavailable object of type %1 to a __weak object of type %2'
H5E0A61E4DC2C: '%select{隐式转换|显式转换}0 类型为 %1 的 weak-unavailable 对象到类型为 %2 的 __weak 对象'
# '%select{implicitly |}2captured%select{| by reference}3%select{%select{ due to use|}2 here| via initialization of lambda capture %0}1'
H0BA3D7D599E5: '%select{隐式 |}2捕获%select{|通过引用}3%select{%select{ 因为此处的使用|}2 |通过 lambda 捕获 %0 的初始化}1'
# '%select{implicit|explicit}0 instantiation first required here'
HB12903FE55DA: '%select{隐式|显式}0 实例化首次在此处需要'
# '%select{implicit|explicit}0 instantiation of template %1 within its own definition'
H0FEA9F8C421A: '%select{隐式|显式}0 实例化模板 %1 在其自身定义中'
# '%select{implicit|explicit}0 instantiation of undefined template %1'
H04E01542E9F2: '%select{隐式|显式}0 实例化未定义的模板 %1'
# "%select{incompatible|duplicate}0 directives '%1' and '%2'"
HEFD5CC9864D7: "%select{不兼容|重复}0 指令 '%1' 和 '%2'"
# '%select{instance variable|property}2 with %0 attribute must be an object type (invalid %1)'
HFD8E12A874BC: '%select{实例变量|属性}2 需要 %0 属性必须为对象类型（无效 %1）'
# '%select{instance|class}1 method %0 not found ; did you mean %2?'
H113C6B0985AF: '%select{实例|类}1 方法 %0 未找到；是否想表达 %2？'
# '%select{integer|integral}1 constant expression must have %select{integer|integral or unscoped enumeration}1 type, not %0'
H07847569345A: '%select{整型|积分型}1 常量表达式必须具有 %select{整型|积分型或无作用域枚举}1 类型，而非 %0'
# "%select{interrupt service routine|function with attribute 'no_caller_saved_registers'}0 should only call a function with attribute 'no_caller_saved_registers' or be compiled with '-mgeneral-regs-only'"
HE2C243372C8E: "%select{中断服务例程|带有属性 'no_caller_saved_registers' 的函数}0 应仅调用带有 'no_caller_saved_registers' 属性的函数或使用 '-mgeneral-regs-only' 编译"
# "%select{invalid use of|unknown}2 attribute subject matcher sub-rule '%0'; '%1' matcher %select{does not support sub-rules|supports the following sub-rules: %3}2"
H8BFF482F0D6A: "%select{无效用法|未知}2 属性匹配子规则 '%0'；'%1' 匹配器 %select{不支持子规则|支持以下子规则： %3}2"
# "%select{invalid value '%0'; must be positive|value '%0' is too large}1"
HEC3DA4A69943: "%select{无效值 '%0'；必须为正数|值 '%0' 过大}1"
# "%select{invalid|missing}0 option%select{ %1|}0; expected 'contract', 'reassociate', 'reciprocal', or 'exceptions'"
H280D64C6E2E8: "%select{无效|缺失}0 选项%select{ %1|}0；预期 'contract', 'reassociate', 'reciprocal' 或 'exceptions'"
# '%select{invalid|missing}0 option%select{ %1|}0; expected vectorize, vectorize_width, interleave, interleave_count, unroll, unroll_count, pipeline, pipeline_initiation_interval, vectorize_predicate, or distribute'
HC3AB036EF44A: '%select{无效|缺失}0 选项%select{ %1|}0；预期 vectorize, vectorize_width, interleave, interleave_count, unroll, unroll_count, pipeline, pipeline_initiation_interval, vectorize_predicate 或 distribute'
# '%select{in|co|contra}0variant type parameter %1 conflicts with previous %select{in|co|contra}2variant type parameter %3'
H893590D91D8F: '%select{in|co|contra}0variant 类型参数 %1 与之前的 %select{in|co|contra}2variant 类型参数 %3 冲突'
# '%select{left |right |}0operand to %select{assignment|compound assignment|increment|decrement}1 expression must be %select{an l-value|of scalar type (was %3)}2'
H115469577E3D: '%select{左|右|}0 操作数到 %select{赋值|复合赋值|递增|递减}1 表达式必须为 %select{l-value|标量类型（实际类型为 %3）}2'
# '%select{left|right}0 side of operator converted from negative value to unsigned: %1'
H1DC6B6DA95C3: '%select{左|右}0 操作数的运算符将负值转换为无符号数：%1'
# '%select{left|right}1 operand to ? is void, but %select{right|left}1 operand is of type %0'
H8125EE82CC5A: '%select{左|右}1 操作数到 ? 运算符的类型为 void，但 %select{右|左}1 操作数类型为 %0'
# '%select{loading directly from|assigning directly to}0 pointer to type %1 requires cl_khr_fp16. Use vector data %select{load|store}0 builtin functions instead'
H66CF7FCAA26B: '%select{直接加载自|直接赋值到}0 类型为 %1 的指针需要 cl_khr_fp16 扩展。请改用向量数据 %select{加载|存储}0 内置函数'
# '%select{local variable|parameter|typedef}0 %1 cannot be declared __module_private__'
H1DE6DC0BF8C5: '%select{局部变量|参数|typedef类型}0 %1 不能声明为 __module_private__'
# "%select{map type '%1' is not allowed|map type must be specified}0 for '#pragma omp %2'"
HA49CE3340880: "%select{映射类型 '%1' 不允许|必须指定映射类型}0 用于 '#pragma omp %2'"
# "%select{missing '#include'|missing '#include %3'}2; %select{||default argument of |explicit specialization of |partial specialization of }0%1 must be %select{declared|defined|defined|declared|declared}0 before it is used"
H0EC06C773CD9: "%select{缺少 '#include'|缺少 '#include %3'}2; %select{||默认参数的 |显式特例化的 |部分特例化的 }0%1 必须在使用前被 %select{声明|定义|定义|声明|声明}0"
# '%select{no_destroy|always_destroy}0 attribute can only be applied to a variable with static or thread storage duration'
H7D17D7EDA6B0: '%select{no_destroy|always_destroy}0 属性只能应用于具有静态或线程存储持续期的变量'
# '%select{non-constexpr|constexpr|consteval}1 declaration of %0 follows %select{non-constexpr|constexpr|consteval}2 declaration'
H2DCC831B3932: '%select{非 constexpr|constexpr|consteval}1 声明的 %0 跟随 %select{非 constexpr|constexpr|consteval}2 声明'
# '%select{non-constexpr|undefined}0 %select{function|constructor}1 %2 cannot be used in a constant expression'
H338EAA31FD42: '%select{非 constexpr|未定义}0 %select{函数|构造函数}1 %2 不能用于常量表达式'
# '%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a temporary of type $|cannot bind to incompatible temporary}1,2'
HD89DCBC20587: '%select{非 const|volatile}0 左值引用 %diff{到类型 $ 不能绑定到临时类型 $|不能绑定到不兼容的临时}1,2'
# '%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a value of unrelated type $|cannot bind to a value of unrelated type}1,2'
H1777D1633EE8: '%select{非 const|volatile}0 左值引用 %diff{到类型 $ 不能绑定到无关类型 $|不能绑定到无关类型}1,2'
# '%select{non-const|volatile}0 lvalue reference to type %1 cannot bind to an initializer list temporary'
H3CF62E12AA3E: '%select{非 const|volatile}0 类型 %1 的左值引用不能绑定到初始化列表临时值'
# '%select{non-const|volatile}0 reference cannot bind to bit-field%select{| %1}2'
H8AF09902E67B: '%select{非 const|volatile}0 引用不能绑定到位段%select{| %1}2'
# '%select{non-const|volatile}0 reference cannot bind to matrix element'
HA82833F246FF: '%select{非 const|volatile}0 引用不能绑定到矩阵元素'
# '%select{non-const|volatile}0 reference cannot bind to vector element'
H6E26FD01A944: '%select{非 const|volatile}0 引用不能绑定到向量元素'
# '%select{non-integral type %0|%0}1 is an invalid underlying type'
HAB3E494D65F5: '%select{非整型类型 %0|%0}1 是无效的基础类型'
# '%select{non-kernel function|function scope}0 variable cannot be declared in %1 address space'
H0866366952CF: '%select{非内核函数|函数作用域}0 变量不能声明在 %1 地址空间中'
# "%select{non-member function|static member function|explicit object member function|deduction guide}0 %select{of type %2 |}1cannot have '%3' qualifier"
HFB817CBCD184: "%select{非成员函数|静态成员函数|显式对象成员函数|推导指引}0 %select{的类型 %2 |}1 不能有 '%3' 限定符"
# '%select{non-member|member}0 %select{<ERROR>|equality|three-way|equality|relational}1 comparison operator must have %select{2|1}0 parameters'
HB5C9D99264DA: '%select{非成员|成员}0 %select{<ERROR>|相等|三向|相等|关系}1 比较运算符必须有 %select{2|1}0 个参数'
# '%select{non-member|static member|non-static member}0 function cannot perform a tail call to %select{non-member|static member|non-static member|pointer-to-member}1 function%select{| %3}2'
HE869F55E570F: '%select{非成员|静态成员|非静态成员}0 函数不能尾调用 %select{非成员|静态成员|非静态成员|成员指针}1 函数%select{| %3}2'
# "%select{non-pointer|function pointer|void pointer}0 argument to '__builtin_launder' is not allowed"
H5F5CB4F84C85: "%select{非指针|函数指针|void 指针}0 参数传递给 '__builtin_launder' 不允许"
# "%select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|alias template|template template argument}1 %0 cannot be referenced with the '%select{struct|interface|union|class|enum}2' specifier"
HA353FC8D883A: "%select{非结构体类型|非类类型|非联合类型|非枚举类型|typedef|类型别名|模板|别名模板|模板模板参数}1 %0 不能通过 '%select{struct|interface|union|class|enum}2' 规范符引用"
# '%select{non-virtual|virtual}0 derivation here'
H7895E4BCBED9: '此处%select{非虚|虚}0派生'
# "%select{non-|function }0pointer argument to '__builtin_is_within_lifetime' is not allowed"
HEC6E2A0FBA29: "传递给 '__builtin_is_within_lifetime' 的%select{非-|函数 }0指针参数不允许"
# "%select{no|too many}0 integer expression arguments provided to OpenACC 'num_gangs' %select{|clause: '%1' directive expects maximum of %2, %3 were provided}0"
HDF54FE517944: "为OpenACC 'num_gangs' %select{|子句 '%1' 指令最多接受 %2，但提供了 %3个}0提供了%select{no|too many}0整型表达式参数"
# "%select{orphaned 'omp section' directives are prohibited, it|'omp section' directive}0 must be closely nested to a sections region%select{|, not a %1 region}0"
HF07F4A64D372: "%select{孤儿的 'omp section' 指令被禁止，它|'omp section' 指令}0必须紧密嵌套到一个 sections 区域%select{|，而不是一个 %1 区域}0"
# "%select{overridden|current}0 method is explicitly declared 'instancetype'%select{| and is expected to return an instance of its class type}0"
HB89C11914779: "%select{覆盖|当前}0方法显式声明为 'instancetype'%select{|并期望返回其类类型的实例}0"
# "%select{overridden|current}0 method is part of the '%select{|alloc|copy|init|mutableCopy|new|autorelease|dealloc|finalize|release|retain|retainCount|self}1' method family%select{| and is expected to return an instance of its class type}0"
HB76B1E081BAA: "%select{覆盖|当前}0方法属于 '%select{|alloc|copy|init|mutableCopy|new|autorelease|dealloc|finalize|release|retain|retainCount|self}1' 方法族%select{|并期望返回其类类型的实例}0"
# '%select{parameters|function return value}0 cannot have __fp16 type; did you forget * ?'
H3BDED28AD784: '%select{参数|函数返回值}0不能具有 __fp16 类型；是否漏掉了 * ？'
# '%select{parameter|non-static data member}3 %0 %select{|of %1 }3shadows member inherited from type %2'
H35412B47BBE2: '%select{参数|非静态数据成员}3 %0 %select{|of %1 }3遮蔽了从类型 %2 继承的成员'
# '%select{parameter|parameter pack}0 declared here'
H2699C14A1A0C: '%select{参数|参数包}0 声明于此'
# "%select{parenthesize the third argument|cast the second argument to 'int'}0 to silence"
H798E3A404637: '%select{括号化第三个参数|将第二个参数强制转换为 int}0 来消除警告'
# '%select{partial specialization|explicit specialization|explicit instantiation}0 of alias templates is not permitted'
H336DD87FEE99: '%select{部分特化|显式特化|显式实例化}0 别名模板是不允许的'
# '%select{pointers|references}0 are unsupported in HLSL'
H134DDEB0FD66: '%select{指针|引用}0 在HLSL中不受支持'
# '%select{pointers|references}0 to functions are not allowed'
H30519C3FCFC8: '函数%select{指针|引用}0不允许'
# '%select{pointer|block pointer|member pointer}0 is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)'
HF29961D95705: '%select{指针|块指针|成员指针}0 缺少空值类型说明符 (_Nonnull, _Nullable 或 _Null_unspecified)'
# '%select{pointer|reference}0 to %select{|subobject of }1%select{temporary|%3}2 is not a constant expression'
H7F2DE7357BB3: '%select{指向|指向子对象的 %select{|%3}2 的 %select{临时对象|}1 指针}0 不是一个常量表达式'
# "%select{pointer|reference}0 to %select{|subobject of }1%select{type_info object|string literal|temporary object|predefined '%3' variable}2 is not allowed in a template argument"
HD8CE51EB9A3E: "%select{指向|引用}0 %select{|子对象的 }1%select{type_info对象|字符串字面量|临时对象|预定义的 '%3' 变量}2 不能在模板参数中使用"
# '%select{pointer|reference}0 to %select{|subobject of }1heap-allocated object is not a constant expression'
H9D1E7F5B4FD5: '%select{指向|引用}0 %select{|子对象的 }1堆分配对象不是常量表达式'
# '%select{pointer|reference}0 to WebAssembly reference type is not allowed'
HECDCB166B532: '%select{指针|引用}0 到 WebAssembly 引用类型不允许'
# '%select{pointer|reference}0 to a consteval declaration is not a constant expression'
H8FC8E4B28636: '%select{指针|引用}0 到 consteval 声明不是常量表达式'
# '%select{pointer|reference}1 to non-const type %0 with no explicit ownership'
H0FF342784C44: '%select{指针|引用}1 到非 const 类型 %0 未显式指定所有权'
# '%select{precompiled header|module}0 uses __DATE__ or __TIME__'
H2637E05CCFD6: '%select{预编译头|模块}0使用了__DATE__或__TIME__'
# '%select{program scope|static local|extern}0 variable must reside in %1 address space'
H8250A4383E97: '%select{程序作用域|静态局部|extern}0变量必须位于%1地址空间中'
# '%select{property|instance variable}0 access cannot be qualified with %1'
H8153C2BE3904: '%select{属性|实例变量}0的访问不能使用%1修饰符'
# "%select{public|private|project}1 umbrella header file not found in input: '%0'"
HFB4B45B92460: "%select{公共|私有|项目}1 伞状头文件未在输入中找到: '%0'"
# "%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature"
H5561702CDE0D: "%select{限定符在 |静态 |}0数组大小%select{||'[*] '}0是C99特性"
# "%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature, not permitted in C++"
HD9EDD0C87400: "%select{限定符在 |静态 |}0数组大小%select{||'[*] '}0是C99特性，不被C++允许"
# '%select{read of|read of|assignment to|increment of|decrement of|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile %select{temporary|object %2|member %2}1 is not allowed in a constant expression'
H88BF34501395: '%select{读取|读取|对...的赋值|递增|递减|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile %select{临时对象|对象%2|成员%2}1在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile-qualified type %1 is not allowed in a constant expression'
HFA8AACB1DC9D: '%select{读取|读取|对...的赋值|递增|递减|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 %1的volatile限定类型在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of subobject of|destruction of|read of}0 %select{object outside its lifetime|uninitialized object}1 is not allowed in a constant expression'
H030F1EA383B2: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|子对象构造|析构|读取}0 %select{超出其生命周期的对象|未初始化对象}1在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of subobject of|destruction of|read of}0 member %1 of union with %select{active member %3|no active member}2 is not allowed in a constant expression'
HAA36C87281CE: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|子对象构造|析构|读取}0 union成员%1在%select{有活动成员%3|无活动成员}2时不允许出现在常量表达式中'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 %select{temporary|variable}1 whose %plural{8:storage duration|:lifetime}0 has ended'
H1E2EE7FC7CDC: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 %select{临时对象|变量}1其%plural{8:存储持续期|:生命周期}0已结束'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 dereferenced null pointer is not allowed in a constant expression'
H22FE9FDFDD6D: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 解引用空指针在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 dereferenced one-past-the-end pointer is not allowed in a constant expression'
H0D344CA7C10F: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 解引用结束位置后指针在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 element of array without known bound is not allowed in a constant expression'
H5DD079C28614: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 未知边界数组的元素在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 heap allocated object that has been deleted'
H0F4326DA1EA9: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 已被删除的堆分配对象在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 mutable member %1 is not allowed in a constant expression'
H08EBC2661AFA: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 mutable成员%1在常量表达式中不允许'
# "%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 object '%1' whose value is not known"
H2547ED9973E0: "%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 值未知的对象'%1'在常量表达式中不允许"
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 temporary is not allowed in a constant expression outside the expression that created the temporary'
H1A04D5C0C6D4: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 临时对象在创建它的表达式之外的常量表达式中不允许'
# '%select{reading|writing}1 the value pointed to by %0 requires holding %select{any mutex|any mutex exclusively}1'
H20B2C79559EA: '%select{读取|写入}1所指向的%0需要持有%select{任意互斥锁|独占互斥锁}1'
# '%select{reading|writing}1 variable %0 requires holding %select{any mutex|any mutex exclusively}1'
HAB41C50F5547: '%select{读取|写入}1变量%0需要持有%select{任意互斥锁|独占互斥锁}1'
# "%select{reading|writing}3 the value pointed to by %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HA3CF53D5D321: "%select{读取|写入}3 %1所指向的值需要保持%0 %select{'%2'|'独占的%2'}3"
# "%select{reading|writing}3 variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HBF61FE4FFCA3: "%select{读取|写入}3 变量%1需要保持%0 %select{'%2'|'独占的%2'}3"
# "%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime is shorter than the lifetime of the constructed object"
H31A36503387B: "%select{引用|'std::initializer_list'的后备数组}2 %select{|成员%0的子对象}1 %select{绑定到|是}2 一个临时对象，其生命周期比构造对象的生命周期短"
# "%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime would be shorter than the lifetime of the constructed object"
H54C5751F42B3: "%select{引用|'std::initializer_list'的后备数组}2 %select{|成员%0的子对象}1 %select{绑定到|是}2 一个临时对象，其生命周期将比构造对象的生命周期短"
# '%select{reference|pointer}0 member declared here'
H8AC5A0A64CFD: '%select{引用|指针}0 成员在此声明'
# '%select{reinterpret_cast|C-style cast}0 from %1 to %2 changes address space of nested pointers'
HDAB148B74E30: '从%1到%2的%select{reinterpret_cast|C风格转换}0更改了嵌套指针的地址空间'
# '%select{reinterpret_cast|dynamic_cast|%select{this conversion|cast that performs the conversions of a reinterpret_cast}1|cast from %1}0 is not allowed in a constant expression%select{| in C++ standards before C++20||}0'
H1688ED0E5178: '%select{reinterpret_cast|dynamic_cast|%select{此转换|执行reinterpret_cast转换的转换}1|来自%1的转换}0 在常量表达式中不允许%select{|在C++20之前的C++标准中||}0'
# '%select{remainder|division}0 by zero is undefined'
HDDF6DBF3AFB2: '%select{余数|除法}0 除以零是未定义的'
# '%select{returning|passing}0 a VL-dependent argument %select{from|to}0 a function with a different streaming-mode is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime'
HD835E99E7B94: '%select{返回|传递}0 一个VL相关的参数%select{从|到}0 具有不同流式模式的函数，在流式和非流式向量长度运行时不同的情况下属于未定义行为'
# '%select{returning|passing}0 a VL-dependent argument %select{from|to}0 a locally streaming function is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime'
H78DE8F398FA2: '%select{返回|传递}0 一个VL相关的参数%select{从|到}0 一个本地流式函数，在流式和非流式向量长度运行时不同的情况下属于未定义行为'
# '%select{return|parameter|variable|field|instance variable|synthesized instance variable}0 type %1 is an abstract class'
H83DAE33A1A29: '%select{返回类型|参数类型|变量类型|字段类型|实例变量类型|合成实例变量类型}0 %1是抽象类'
# "%select{self-|array |pointer }0comparison always evaluates to %select{a constant|true|false|'std::strong_ordering::equal'}1"
H25C7EE9B164E: "%select{自我|数组 |指针 }0比较始终计算为%select{一个常量|true|false|'std::strong_ordering::equal'}1"
# "%select{shader model|Vulkan environment|shader stage}0 '%1' in target '%2' is invalid for HLSL code generation"
H559D5EF03AE6: "%select{着色器模型|Vulkan环境|着色器阶段}0 '%1' 在目标'%2'中对HLSL代码生成无效"
# "%select{shader model|Vulkan environment|shader stage}0 is required as %select{OS|environment}1 in target '%2' for HLSL code generation"
H2955A7AC1204: "需要将%select{着色器模型|Vulkan环境|着色器阶段}0 指定为%select{操作系统|环境}1 在目标'%2'中进行HLSL代码生成"
# '%select{signed value|extra discriminator|blended pointer|blended integer}0 must have %select{pointer|integer|pointer or integer}1 type; type here is %2'
HA4822404707C: '%select{有符号值|额外判别器|混合指针|混合整数}0 必须具有%select{指针|整数|指针或整数}1 类型；此处类型为%2'
# "%select{signed |}0'size_t' literal is out of range of possible %select{signed |}0'size_t' values"
HADACA5CF45B7: "'%select{有符号 |}0'size_t' 字面量超出可能%select{有符号 |}0'size_t' 值的范围"
# '%select{signed|unsigned}0 _BitInt must have a bit size of at least %select{2|1}0'
H866585566251: '%select{有符号|无符号}0 _BitInt 必须具有至少%select{2|1}0位大小'
# '%select{signed|unsigned}0 _BitInt of bit sizes greater than %1 not supported'
HB66515AEE2F3: '%select{有符号|无符号}0 _BitInt 的位大小超过%1不受支持'
# "%select{source|destination}2 of '%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' is %3"
H752C91AB4DE4: "'%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0'的%select{源|目标}2 是%3"
# "%select{statement after '#pragma omp %1' must be a for loop|expected %2 for loops after '#pragma omp %1'%select{|, but found only %4}3}0"
H5AE78EDFB051: '%select{#pragma omp %1后的语句必须是一个for循环|期望在#pragma omp %1后有%2个for循环%select{|，但仅找到%4}3}0'
# '%select{statement|directive}0 outside teams construct here'
HCEC20E30EFC9: '%select{语句|指令}0 在 teams 结构外部此处'
# "%select{static data member is predetermined as shared|variable with static storage duration is predetermined as shared|loop iteration variable is predetermined as private|loop iteration variable is predetermined as linear|loop iteration variable is predetermined as lastprivate|constant variable is predetermined as shared|global variable is predetermined as shared|non-shared variable in a task construct is predetermined as firstprivate|variable with automatic storage duration is predetermined as private}0%select{|; perhaps you forget to enclose 'omp %2' directive into a parallel or another task region?}1"
HF1446F769957: "%select{静态数据成员被预设为共享|具有静态存储期的变量被预设为共享|循环迭代变量被预设为私有|循环迭代变量被预设为线性|循环迭代变量被预设为 lastprivate|常量变量被预设为共享|全局变量被预设为共享|任务构造中非共享变量被预设为 firstprivate|自动存储期变量被预设为私有}0%select{|; 或许您忘记将 'omp %2' 指令包含在并行或另一个任务区域内？}1"
# "%select{string|character|boolean|numeric}0 literal must be prefixed by '@' in a collection"
H437BC3E10750: "%select{字符串|字符|布尔|数值}0 文字必须以前缀 '@' 开头"
# "%select{string|numeric}0 literal must be prefixed by '@'"
HE32E641B2BF1: "%select{字符串|数值}0 文字必须以前缀 '@' 开头"
# '%select{struct|interface|class}0 with virtual base %plural{1:class|:classes}1 is not a literal type'
H74349A7BD7CA: '%select{结构|接口|类}0 具有虚拟基类%plural{1:类|：类}1 不是字面类型'
# '%select{struct|interface|class}0%select{| template}1 %2 was previously declared as a %select{struct|interface|class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI'
H2D10AD8D0564: '%select{结构|接口|类}0%select{| 模板}1 %2 之前被声明为 %select{结构|接口|类}3%select{| 模板}1；该声明有效，但可能在 Microsoft C++ ABI 下引发链接器错误'
# '%select{struct|interface|union|class|enum}0 %1 does not declare any constructor to initialize its non-modifiable members'
HAB227F7E6966: '%select{结构|接口|联合|类|枚举}0 %1 未声明任何构造函数来初始化其不可修改成员'
# '%select{struct|union}0 kernel parameters may not contain pointers'
H1723C50B8752: '%select{结构|联合}0 内核参数不能包含指针'
# '%select{struct|union}0 without named members is a GNU extension'
HBECD0A183C46: '%select{结构|联合}0 无命名成员是 GNU 扩展'
# '%select{subtraction|addition}0 of address-of-label expressions is not supported with ptrauth indirect gotos'
H131327EB0D0D: '%select{标签地址差|标签地址和}0 不支持带有 ptrauth 间接 goto'
# '%select{template type|non-type template|template template}0 parameter%select{| pack}1 conflicts with previous %select{template type|non-type template|template template}0 parameter%select{ pack|}1'
HACD51B91D6D5: '%select{模板类型|非类型模板|模板模板}0 参数%select{| 包}1 与之前的 %select{模板类型|非类型模板|模板模板}0 参数%select{ 包|}1 冲突'
# '%select{template type|non-type template|template template}0 parameter%select{| pack}1 does not match %select{template type|non-type template|template template}0 parameter%select{ pack|}1 in template argument'
H42D8D01F5E06: '%select{模板类型|非类型模板|模板模板}0 参数%select{| 包}1 与模板实参中的 %select{模板类型|非类型模板|模板模板}0 参数%select{ 包|}1 不匹配'
# '%select{template|partial|member}0 specialization cannot be declared __module_private__'
H0A90D5264D30: '%select{模板|部分|成员}0 专项化不能被声明为 __module_private__'
# '%select{temporary %select{whose address is used as value of|%select{|implicitly }2bound to}4 %select{%select{|reference }4member of local variable|local %select{variable|reference}4}1|array backing %select{initializer list subobject of local variable|local initializer list}1}0 %select{%3 |}2will be destroyed at the end of the full-expression'
H1685FEE7827D: '临时%select{其地址被用作%select{|隐式}2绑定到%select{%select{|引用}4本地变量的成员|本地%select{变量|引用}4}1|数组后端%select{本地变量的初始化列表子对象|本地初始化列表}1}0 %select{%3 |}2%select{将被销毁在完整表达式结束时|}3'
# "%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must be a string literal or an object with 'data()' and 'size()' member functions"
H320EEB9B1530: '%select{消息|表达式}0 在 %select{静态断言|这个asm操作数}0 必须由常量表达式生成'
# '%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must be produced by a constant expression'
H9571480E2335: '%select{消息|表达式}0 在 %select{静态断言|此asm操作数}0 中必须由常量表达式生成'
# "%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must have a '%select{size|data}1()' member function returning an object convertible to '%select{std::size_t|const char *}1'"
HE077A8EBD022: "%select{消息|表达式}0 在 %select{静态断言|此asm操作数}0 中必须具有返回可转换为 '%select{std::size_t|const char *}1' 的 %select{size|data}1() 成员函数"
# '%select{the message|the expression}0 in %select{this static assertion|this asm operand}0 is not a constant expression'
H1136016D414E: '%select{消息|表达式}0 在 %select{此静态断言|此asm操作数}0 中不是常量表达式'
# '%select{too few|too many}0 template arguments for %select{class template|function template|variable template|alias template|template template parameter|concept|template}1 %2'
HA3BFC0466346: '%select{模板实参不足|模板实参过多}0 对于 %select{类模板|函数模板|变量模板|别名模板|模板模板参数|概念|模板}1 %2'
# '%select{too few|too many}0 template parameters in template %select{|template parameter }1redeclaration'
H2FC8E4427754: '%select{模板参数不足|模板参数过多}0 在模板%select{| 模板参数 }1重声明中'
# '%select{too few|too many}0 template parameters in template template argument'
HEDDF73011D6C: '%select{模板参数太少|模板参数太多}0 在模板模板参数中'
# '%select{too many|too few}0 elements in vector %select{initialization|operand}3 (expected %1 elements, have %2)'
HEB48F48C2E39: '%select{向量初始化|操作数}3 中的元素%select{太多|太少}0（预期%1个元素，但有%2个）'
# '%select{type tag|argument}0 index %1 is greater than the number of arguments specified'
H7C0418F179E9: '%select{类型标记|参数}0 索引%1大于指定参数的数量'
# '%select{typedef|type alias|type alias template}0 redefinition with different types%diff{ ($ vs $)|}1,2'
H7F72DD3ED811: '%select{typedef|type alias|type alias template}0 类型重新定义%diff{ ($ vs $)|}1,2'
# '%select{uninitialized use occurs|variable is captured by block}0 here'
H80571A54148A: '%select{未初始化的使用发生|变量被块捕获}0 此处'
# '%select{unknown|unsupported}0 machine mode %1'
HB579643BB1CB: '%select{未知|不受支持}0 的机器模式%1'
# '%select{unsafe pointer operation|unsafe pointer arithmetic|unsafe buffer access|function introduces unsafe buffer manipulation|unsafe invocation of %1|field %1 prone to unsafe buffer manipulation}0'
HD969AD0BDB13: '%select{不安全指针操作|不安全指针运算|不安全缓冲区访问|函数引入不安全缓冲区操作|调用%1不安全|字段%1易导致不安全缓冲区操作}0'
# "%select{unsupported|duplicate|unknown}0%select{| CPU| tune CPU}1 '%2' in the '%select{target|target_clones|target_version}3' attribute string;"
H8412993B41A2: "%select{不支持|重复|未知}0%select{| CPU| tune CPU}1 '%2' 在 '%select{target|target_clones|target_version}3' 属性字符串中;"
# "%select{unsupported|duplicate|unknown}0%select{| CPU| tune CPU}1 '%2' in the '%select{target|target_clones|target_version}3' attribute string; '%select{target|target_clones|target_version}3' attribute ignored"
H952DC46C8259: "%select{不支持|重复|未知}0%select{| CPU| tune CPU}1 '%2' 在 '%select{target|target_clones|target_version}3' 属性字符串中; 忽略 %select{target|target_clones|target_version}3 属性"
# '%select{using this character in an identifier|starting an identifier with this character}0 is incompatible with C99'
H2BC4F8FF7FD4: '%select{在标识符中使用该字符|以该字符开头的标识符}0 不符合C99规范'
# "%select{values of type|enum values with underlying type}2 '%0' should not be used as format arguments; add an explicit cast to %1 instead"
H74FA7B9CE6BC: "%select{类型|基础类型为的枚举值}2 '%0'不应作为格式参数使用；请显式转换为%1类型"
# '%select{value|type}0-dependent expression passed as an argument to debug command'
HF8F02B43BB62: '%select{值|类型}0 依赖表达式被传递给调试命令'
# '%select{variable|static data member}0 instantiated with function type %1'
HE6193A7D74C4: '%select{变量|静态数据成员}0 实例化为函数类型%1'
# '%select{via initialization of|binding reference}0 variable %select{%2 |}1here'
HB0440A5001E5: '%select{通过初始化|绑定引用}0 变量%select{%2 |}1此处'
# "%select{virtual method|function pointer}0 cannot be inferred '%1'"
H57712FD11644: "%select{虚方法|函数指针}0 无法推断'%1'"
# '%select{void function|void method|constructor|destructor}1 %0 must not return a value'
HE90DDC8579B5: '%select{void函数|void方法|构造函数|析构函数}1 %0 必须不返回值'
# '%select{void function|void method|constructor|destructor}1 %0 should not return a value'
H917D4EA3DC61: '%select{void函数|void方法|构造函数|析构函数}1 %0 不应返回值'
# '%select{wide|Unicode}0 character literals may not contain multiple characters'
HEBA1B65B6166: '%select{宽|Unicode}0 字符文字不能包含多个字符'
# "%select{x86|x86-64}0 'interrupt' attribute only applies to functions that have %select{a 'void' return type|only a pointer parameter optionally followed by an integer parameter|a pointer as the first parameter|a %2 type as the second parameter}1"
H6EAE552C7EA8: "%select{x86|x86-64}0 'interrupt' 属性仅适用于%select{返回类型为void的函数|仅带有可选后续整数参数的指针参数|第一个参数为指针|第二个参数为%2类型}1 的函数"
# "%select{|'%1-%2' }0diagnostics %select{with '%2' severity |}0%select{expected|seen}3 but not %select{seen|expected}3: %4"
H6E1DC1644300: "%select{|'%1-%2' }0诊断%select{具有'%2'严重性|}0%select{预期|检测到}3 但未%select{检测到|预期}3: %4"
# '%select{|a template declaration|an explicit template specialization|an explicit template instantiation}0 can only %select{|declare|declare|instantiate}0 a single entity'
HCEE3630F178B: '%select{|一个模板声明|一个显式模板特化|一个显式模板实例化}0 只能 %select{|声明|声明|实例化}0 单个实体'
# "%select{|captured }1%0 parameter marked 'called_once' is never called"
H5EDD8753404F: "%select{|被捕获的 }1%0 参数标记为'called_once'但从未被调用"
# '%select{|captured }1completion handler is never called'
H31A1FA39F285: '%select{|被捕获的 }1完成处理程序从未被调用'
# "%select{|change to 'snprintf' for explicit bounds checking | buffer pointer and size may not match|string argument is not guaranteed to be null-terminated|'va_list' is unsafe}0"
H071DEF637982: "%select{|改为使用'snprintf'进行显式边界检查 | 缓冲区指针和大小可能不匹配|string参数不保证以空字符终止|'va_list'不安全}0"
# '%select{|direct }0%select{method|property}1 declaration conflicts with previous %select{|direct }2declaration of %select{method|property}1 %3'
H1D02391D3A58: '%select{|直接 }0%select{方法|属性}1 声明与之前的 %select{|直接 }2 声明冲突 %select{方法|属性}1 %3'
# '%select{|empty }0%select{struct|union}1 has size 0 in C, %select{size 1|non-zero size}2 in C++'
HEA8D8C4B49F9: '%select{|空 }0%select{结构体|联合体}1 在C中有大小0，在C++中%select{大小为1|非零大小}2'
# "%select{|implicit }0use of 'this' pointer is only allowed within the evaluation of a call to a 'constexpr' member function"
HE1347141F3D2: '%select{|隐式 }0使用"this"指针仅允许在constexpr成员函数调用的求值过程中使用'
# '%select{|implicitly }1declared %select{private|protected}0 here'
H8D12655CD9C3: '%select{|隐式 }1声明为 %select{私有|保护}0 这里'
# "%select{|incremented }0enumerator value which exceeds the range of 'int' is a C23 extension (%1 is too %select{small|large}2)"
H7317CEFA834D: '%select{|递增的 }0枚举值超出int类型的范围是C23扩展 (%1 过于%select{小|大}2)'
# "%select{|incremented }0enumerator value which exceeds the range of 'int' is incompatible with C standards before C23 (%1 is too %select{small|large}2)"
H02CD4F5E389B: '%select{|递增的 }0枚举值超出int类型的范围与C23之前的标准不兼容 (%1 过于%select{小|大}2)'
# '%select{|member|base class}0 %1 declared here'
H83331E20A1A3: '%select{|成员|基类}0 %1 声明于此'
# '%select{|member}0 using declaration %1 instantiates to an empty pack'
H03EFD19ED92A: '%select{|成员}0 using声明%1 实例化为空包'
# '%select{|non-aggregate }0type %1 cannot be initialized with an initializer list'
H94A9DAA06E2F: '%select{|非聚合 }0类型%1 不能用初始化列表初始化'
# '%select{|overriding }1method cannot be unavailable on %0 when %select{the protocol method it implements|its overridden method}1 is available'
H11BFB9C90008: '%select{|覆盖 }1方法在%0不可用时，当%select{实现的协议方法|覆盖的方法}1 是可用时不允许'
# '%select{|overriding }4method %select{introduced after|deprecated before|obsoleted before}0 %select{the protocol method it implements|overridden method}4 on %1 (%2 vs. %3)'
H3102E4185799: '%select{|覆盖 }4方法%select{在...之后引入|在...之前弃用|在...之前淘汰}0 %select{实现的协议方法|覆盖的方法}4 在%1 (%2 对比 %3)'
# '%select{|pointer to |reference to }0incomplete type %1 is not allowed in exception specification'
HBD4554E2864A: '%select{|指向|对...的引用}0 不完整类型%1 不允许出现在异常说明中'
# "%select{|previous }0'hint' clause with value '%1'"
HBBFA3E1A9C6B: "%select{|之前的 }0'hint'子句值为'%1'"
# "%select{|previous }0directive with no 'hint' clause specified"
H8CE1C8734C39: "%select{|之前的 }0未指定'hint'子句的指令"
# '%select{|previous }0using declaration'
H5AE3701DBB92: '%select{|之前的 }0using声明'
# '%select{|previous }0using-enum declaration'
H5BC63E8C8F5E: '%select{|之前的 }0using-enum声明'
# '%select{|reference to }0sizeless type %1 is not allowed in exception specification'
H3E89611A15B6: '%select{|对 }0大小缺失的类型%1的引用在异常规格中不允许'
# '%select{|second }0%1 token is here'
H00E98F1D44F7: '%select{|第二个 }0%1标记在此处'
# '%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 uses deleted function%select{|: %4}3'
HD806C936F5D9: '%select{|static_cast|reinterpret_cast|dynamic_cast|C风格转换|函数式转换|}0从%1到%2的转换使用了已删除的函数%select{|: %4}3'
# '%select{|success |failure }0memory order argument to atomic operation is invalid'
HFAC869D2863E: '%select{|成功 |失败 }0原子操作的内存顺序参数无效'
# "%select{|umbrella }0header '%1' not found"
H3FDB64D57A92: "%select{|umbrella }0头文件'%1'未找到"
# '%select{|unsafe_unretained|strong|weak}1 property %0 may not also be declared %select{|__unsafe_unretained|__strong|__weak|__autoreleasing}2'
HC9D6BEED9F9F: '%select{|unsafe_unretained|strong|weak}1 属性 %0 可能也不能被声明为 %select{|__unsafe_unretained|__strong|__weak|__autoreleasing}2'
# '%select{||reinterpret_cast||C-style cast||}0 from scalar %1 to vector %2 of different size'
HFF11D1B4EA50: '%select{||reinterpret_cast||C风格转换||}0从标量%1到不同大小的向量%2'
# '%select{||reinterpret_cast||C-style cast||}0 from vector %1 to scalar %2 of different size'
H4BC2B3E593E1: '%select{||reinterpret_cast||C风格转换||}0从向量%1到不同大小的标量%2'
# '%select{||reinterpret_cast||C-style cast||}0 from vector %1 to vector %2 of different size'
H855233AE0D42: '%select{||reinterpret_cast||C风格转换||}0从向量%1到不同大小的向量%2'
# "%select{|||||virtual function called on|dynamic_cast applied to|typeid applied to|construction of|destruction of}0 object '%1' whose dynamic type is not constant"
H292A692F3948: "%select{|||||虚函数调用|dynamic_cast 应用于|typeid 应用于|构造|析构}0 对象 '%1' 其动态类型不是常量"
# "'##' cannot appear at end of __VA_OPT__ argument"
H2B78B6D67ACA: "'##'不能出现在__VA_OPT__参数末尾"
# "'##' cannot appear at end of macro expansion"
H0D880CABAC3F: "'##'不能出现在宏展开末尾"
# "'##' cannot appear at start of __VA_OPT__ argument"
H2F2411264E60: "'##'不能出现在__VA_OPT__参数开头"
# "'##' cannot appear at start of macro expansion"
H49669D0F3359: "'##'不能出现在宏展开开头"
# "'#include <filename>' attaches the declarations to the named module '%0', which is not usually intended; consider moving that directive before the module declaration"
HE8759FB5FF70: "'#include <filename>'将声明附加到名为%0的模块，这通常不是预期行为；建议将该指令移动到模块声明之前"
# "'#pragma %0' can only appear at file scope"
HCE0F9341D433: "'#pragma %0'只能出现在文件作用域"
# "'#pragma %0' can only appear at file scope or at the start of a compound statement"
HD3947EF6D864: "'#pragma %0'只能出现在文件作用域或复合语句开头"
# "'#pragma %0' is not supported on this target - ignored"
H10F342B08150: "'#pragma %0'在此目标上不支持 - 已忽略"
# "'#pragma STDC FENV_ACCESS ON' is illegal when precise is disabled"
H17CE846EF8B0: "'#pragma STDC FENV_ACCESS ON'在precise被禁用时非法"
# "'#pragma alloc_text' is applicable only to functions"
H29BA150C71BF: "'#pragma alloc_text'仅适用于函数"
# "'#pragma alloc_text' is applicable only to functions with C linkage"
H8053A181B977: "'#pragma alloc_text' 仅适用于具有C链接的函数"
# "'#pragma clang arc_cf_code_audited' was not ended within this file"
H3175433AA2FB: "'#pragma clang arc_cf_code_audited' 未在此文件中结束"
# "'#pragma clang assume_nonnull' was not ended within this file"
H344021929D5B: "'#pragma clang assume_nonnull' 未在此文件中结束"
# "'#pragma clang attribute %select{%1.|}0pop' with no matching '#pragma clang attribute %select{%1.|}0push'"
H170B16ACF46E: "'#pragma clang attribute %select{%1.|}0pop' 没有匹配的 '#pragma clang attribute %select{%1.|}0push'"
# "'#pragma clang attribute push' regions ends here"
HF6A5F5655AB0: "'#pragma clang attribute push' 区域在此结束"
# "'#pragma clang attribute' attribute with no matching '#pragma clang attribute push'"
HAAE6327E2566: "'#pragma clang attribute' 属性没有匹配的 '#pragma clang attribute push'"
# "'#pragma comment %0' ignored"
HEB14674C1594: "忽略 '#pragma comment %0'"
# "'#pragma float_control push/pop' can only appear at file or namespace scope or within a language linkage specification"
H053264F8F924: "'#pragma float_control push/pop' 仅可在文件或命名空间作用域内，或在语言链接规范内出现"
# "'#pragma float_control(except, on)' is illegal when precise is disabled"
H28022D025F51: "当 precise 禁用时，'#pragma float_control(except, on)' 是非法的"
# "'#pragma float_control(precise, off)' is illegal when except is enabled"
H922887ACFECE: "当 except 启用时，'#pragma float_control(precise, off)' 是非法的"
# "'#pragma float_control(precise, off)' is illegal when fenv_access is enabled"
HAFA440F76585: "当 fenv_access 启用时，'#pragma float_control(precise, off)' 是非法的"
# "'#pragma init_seg' is only supported when targeting a Microsoft environment"
H4E91F2EF3757: "'#pragma init_seg' 仅在针对Microsoft环境时受支持"
# "'#pragma omp %0' %select{|with '%2' clause }1cannot be an immediate substatement"
HA805BCE4C312: "'#pragma omp %0' %select{|包含 '%2' 子句 }1不能是直接子语句"
# "'#pragma omp %0' directive must appear only in file scope"
H3C04CBDE708E: "'#pragma omp %0' 指令必须仅出现在文件作用域中"
# "'#pragma omp %0' must appear in the scope of the %q1 variable declaration"
HCD521713958F: "'#pragma omp %0' 必须出现在 %q1 变量声明的作用域内"
# "'#pragma omp %0' must precede all references to variable %q1"
HA982E769431D: "'#pragma omp %0' 必须在变量 %q1 的所有引用前出现"
# "'#pragma omp declare %select{simd|variant}0' can only be applied to functions"
HC2DB961C6B39: "'#pragma omp declare %select{simd|variant}0' 仅可应用于函数"
# "'#pragma omp declare variant' cannot be applied for function after first usage; the original function might be used"
H504957D176C7: "'#pragma omp declare variant' 不能在函数首次使用后应用；原始函数可能已被使用"
# "'#pragma omp declare variant' cannot be applied to the function that was defined already; the original function might be used"
HB5A7CD5EEB6F: "'#pragma omp declare variant' 不能应用于已定义的函数；原始函数可能已被使用"
# "'#pragma omp declare variant' does not support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function}0"
H240B964685D1: "'#pragma omp declare variant' 不支持 %select{函数模板|虚函数|推导返回类型|构造函数|析构函数|被删除函数|默认函数|constexpr函数|consteval函数}0"
# "'#pragma omp declare variant' is not compatible with any target-specific attributes"
HDFFC2CD6FA69: "'#pragma omp declare variant' 与任何目标特定属性不兼容"
# "'#pragma omp end assumes' with no matching '#pragma omp begin assumes'"
HAF63C041427E: "未找到对应的 '#pragma omp begin assumes'，但出现了 '#pragma omp end assumes'"
# "'#pragma omp end declare variant' with no matching '#pragma omp begin declare variant'"
HD60959180819: "未找到对应的 '#pragma omp begin declare variant'，但出现了 '#pragma omp end declare variant'"
# "'#pragma unsafe_buffer_usage' was not ended"
H8FB2F039CC57: "'#pragma unsafe_buffer_usage' 未结束"
# "'$' in identifier"
HB5654708DC14: "标识符中包含 '$'"
# "'%%n' specifier not supported on this platform"
HC8B8AD4E064B: "此平台不支持 '%%n' 格式说明符"
# "'%0' %select{length modifier|conversion specifier}1 is not supported by ISO C"
H5FE655A569EF: "ISO C 不支持 '%0' %select{长度修饰符|转换说明符}1"
# "'%0' ABI is not supported with FPU"
H0E4CA678D6B9: "'%0' ABI 与 FPU 不兼容"
# "'%0' action ignored; '%1' action specified previously"
H140C3ABC4AE4: "忽略 '%0' 操作，已指定之前的 '%1' 操作"
# "'%0' and '%1' clause are mutually exclusive and may not appear on the same directive"
H124967FEEE58: "'%0' 和 '%1' 子句是互斥的，不能出现在同一指令中"
# "'%0' argument on '%1' clause is not permitted on a%select{|n orphaned}2 '%3' construct%select{| associated with a '%5' compute construct}4"
H43AC213E21A0: "不允许在%select{|孤立的}2 '%3' 构造体%select{|与 '%5' 计算构造体关联}4中对 '%1' 子句使用 '%0' 参数"
# "'%0' argument to '%1' clause not allowed on a '%2' construct%select{| associated with a '%4' construct}3 that has a '%5' clause"
H08457CF75CEB: "不允许在%select{|与 '%4' 构造体关联}3的 '%2' 构造体中对带有 '%5' 子句的 '%0' 参数使用 '%1' 子句"
# "'%0' as a module map name is deprecated, rename it to %select{module.modulemap|module.private.modulemap}1%select{| in the 'Modules' directory of the framework}2"
H871445ACDF0B: "'%0' 作为模块映射名称已弃用，应重命名为 %select{module.modulemap|module.private.modulemap}1%select{|并在框架的 'Modules' 目录中}2"
# "'%0' attribute cannot be specified on a definition"
H3887172CED45: "无法在定义上指定 '%0' 属性"
# "'%0' call operates on objects of type %1 while the size is based on a different type %2"
H9E506A66F2D3: "'%0' 调用作用于类型 %1 的对象，而大小基于不同类型 %2"
# "'%0' can only be used if the target supports the mfhc1 and mthc1 instructions"
HD98657B082CC: "仅当目标支持 mfhc1 和 mthc1 指令时才能使用 '%0'"
# "'%0' can only be used with the '%1' ABI"
HAC173E806F23: "仅能与 '%1' ABI 一起使用 '%0'"
# "'%0' cannot be a part of nested name specifier; did you mean ':'?"
H6E2E8EF01102: "'%0' 不能作为嵌套名称限定符的一部分；是否应使用 ':'？"
# "'%0' cannot be called with %select{a null pointer|a one-past-the-end pointer|a pointer to an object whose lifetime has not yet begun}1"
H9E6A8072EAD3: "无法用 %select{空指针|超出末尾的指针|生命周期尚未开始的对象的指针}1 调用 '%0'"
# "'%0' cannot be signed or unsigned"
HE82DC08D960E: "'%0' 不能指定为有符号或无符号类型"
# "'%0' cannot be used in an unevaluated context"
HACCAB0092430: "'%0' 不能在未求值的上下文中使用"
# "'%0' cannot be used in the handler of a try block"
HCC6C7DE7C0DC: "'%0' 不能在 try 块的处理器中使用"
# "'%0' cannot be used outside a function"
HF038C50615EF: "'%0' 不能在函数外部使用"
# "'%0' casts have no effect when not using ARC"
H0985DFE3C8AA: "'%0' 类型转换在不使用 ARC 时没有效果"
# "'%0' clause is specified here"
H573F42F97FF4: "'%0' 子句在此处指定"
# "'%0' clause not allowed on a 'kernels loop' construct that has a '%1' clause with a%select{n| 'num'}2 argument"
HA63B4E6AC69A: "'%0' 子句不允许用于具有带有%select{n| 'num'}2参数的'%1'子句的 'kernels loop' 结构"
# "'%0' clause requires 'dispatch' context selector"
H94FAB67C930A: "'%0' 子句需要 'dispatch' 上下文选择器"
# "'%0' clause specifies a loop count greater than the number of available loops"
H13BED1AA5B60: "'%0' 子句指定了比可用循环数量更多的循环计数"
# "'%0' clause used here"
HC259BC00C8FD: "'%0' 子句在此处使用"
# "'%0' clause with '%1' modifier cannot be specified if an 'ordered' clause is specified"
HFFE6A9A75740: "如果指定了 'ordered' 子句，则带有 '%1' 修饰符的 '%0' 子句不能指定"
# "'%0' clauses cannot be mixed with '%1' clause"
H0A2484D8EEB5: "'%0' 子句不能与 '%1' 子句混合使用"
# "'%0' construct is here"
H4E6A1EF91E1B: "'%0' 结构在此处"
# "'%0' declared as a member pointer to a reference of type %1"
HF4FF87D5007C: "'%0' 被声明为指向类型 %1 的引用的成员指针"
# "'%0' declared as a member pointer to void"
HB8704C365E55: "'%0' 被声明为指向 void 的成员指针"
# "'%0' declared as a pointer to a reference of type %1"
H95E780665FDE: "'%0' 被声明为指向类型 %1 的引用的指针"
# "'%0' declared as an array with a negative size"
H44D9A6FDB5F3: "'%0' 被声明为具有负大小的数组"
# "'%0' declared as array of functions of type %1"
HF167BCD9180C: "'%0' 被声明为类型 %1 的函数的数组"
# "'%0' declared as array of references of type %1"
H07B7977DE9AC: "'%0' 被声明为类型 %1 的引用的数组"
# "'%0' directive cannot follow %select{'%2' directive|other expected directives}1"
H81459AA5C045: "'%0' 指令不能跟随 %select{'%2' 指令|其他预期指令}1"
# "'%0' directive found here"
H689CAA47B15F: "'%0' 指令在此处找到"
# "'%0' does not contain a GCC installation"
H5EA2B901E3DD: "'%0' 不包含 GCC 安装"
# "'%0' does not point into a class"
H4C033F9AA617: "'%0' 没有指向一个类"
# "'%0' does not support '-%1'; flag ignored"
H5F193B6442A3: "'%0' 不支持 '-%1'; 标志被忽略"
# "'%0' does not support '-moutline'; flag ignored"
H8FCF49E8EFFE: "'%0' 不支持 '-moutline'; 标志被忽略"
# "'%0' evaluates to a null function pointer"
HC166C9B46BC9: "'%0' 评估为一个空函数指针"
# "'%0' file not found"
HE40852833202: "'%0' 文件未找到"
# '\'%0\' file not found with <angled> %select{include|import}1; use "quotes" instead'
HB65E7D8C29D0: '\'%0\' 文件未找到，使用 <angled> %select{include|import}1 包含；请改用 "quotes"'
# "'%0' file not found, did you mean '%1'?"
HA3BAEA90173D: "'%0' 文件未找到，您是不是指 '%1'？"
# "'%0' function must have a prototype"
H161348B5A00F: "'%0' 函数必须有原型声明"
# "'%0' ignored on this declaration"
H3A73EC6937F0: "'%0' 在此声明中被忽略"
# "'%0' included multiple times, additional include site here"
H67346CC37DF8: "'%0' 被多次包含，此处为额外包含位置"
# "'%0' included multiple times, additional include site in header from module '%1'"
HC2226976DFB3: "'%0' 被多次包含，额外包含位置在模块 '%1' 的头文件中"
# "'%0' invalid for input of type %1"
H0F254F5D0DEC: "'%0' 对类型 %1 的输入无效"
# "'%0' is a C11 extension"
HACD9CD0EB9B2: "'%0' 是 C11 的扩展"
# "'%0' is a C99 extension"
H553903351EEE: "'%0' 是 C99 的扩展"
# "'%0' is a context %select{set|selector|property}1 not a context %select{set|selector|property}2"
H0E6818DF21E4: "'%0' 是上下文 %select{set|selector|property}1 而非上下文 %select{set|selector|property}2"
# "'%0' is a keyword in C++11"
H6E1B6EF2D90A: "'%0' 是 C++11 的关键字"
# "'%0' is a keyword in C++20"
HED77874B7FB4: "'%0' 是 C++20 的关键字"
# "'%0' is a keyword in C23"
H55337290EE76: "'%0' 是 C23 的关键字"
# "'%0' is a keyword in C99"
H305C2462E219: "'%0' 是 C99 的关键字"
# "'%0' is bound to current loop, GCC binds it to the enclosing loop"
H6C2FAF9A98CF: "'%0'绑定到当前循环，而GCC将其绑定到外部循环"
# "'%0' is ignored since it is only supported for HIP"
HAF6605CCA46F: "'%0'被忽略，因为它仅在HIP中支持"
# "'%0' is incompatible with C standards before C11"
H0DA1AA64E023: "'%0'与C11之前的C标准不兼容"
# "'%0' is incompatible with C standards before C23"
HDD86BE78B3D0: "'%0'与C23之前的C标准不兼容"
# "'%0' is invalid in friend declarations"
H3D161449A142: "'%0'在friend声明中无效"
# "'%0' is not a valid Unicode character name"
H469DC75B6244: "'%0'不是有效的Unicode字符名称"
# "'%0' is not a valid builtin name for %1"
H4BF3E4DBB43C: "'%0'不是%1的有效内置名称"
# "'%0' is not a valid context property for the context selector '%1' and the context set '%2'; property ignored"
HEB6F750CA90C: "'%0'不是上下文选择器'%1'和上下文集合'%2'的有效属性；属性被忽略"
# "'%0' is not a valid context selector for the context set '%1'; selector ignored"
H6CA470A4E352: "'%0'不是上下文集合'%1'的有效选择器；选择器被忽略"
# "'%0' is not a valid context set in a `declare variant`; set ignored"
HA1E62D28111D: "'%0'在`declare variant`中不是有效的上下文集合；集合被忽略"
# "'%0' is not a valid object format flag"
H0558CE31CE90: "'%0'不是有效的目标格式标志"
# "'%0' is not permitted on a declaration of a type"
H43ABF8D7D74B: "'%0'不允许用于类型声明"
# "'%0' is not supported in C++ for OpenCL"
HDCEA34FAF8C7: "'%0'在C++的OpenCL中不受支持"
# "'%0' is only allowed on variable declarations"
H6BFADFD542E9: "'%0'仅允许用于变量声明"
# "'%0' is only available in %1"
H468F8034CF09: "'%0'仅在%1中可用"
# "'%0' is used without '-mstack-protector-guard-offset', and there is no default"
H8812B24333D0: "'%0'未与'-mstack-protector-guard-offset'选项一起使用，且没有默认值"
# "'%0' keyword is a C++11 extension"
H23175F3671E1: "'%0'关键字是C++11的扩展"
# "'%0' keyword is incompatible with C++98"
HCFDB7E16EAB8: "'%0'关键字与C++98不兼容"
# "'%0' keyword not permitted with interface types"
HFAA4A308281C: "'%0'关键字不允许与接口类型一起使用"
# "'%0' may overflow; destination buffer in argument %1 has size %2, but the corresponding specifier may require size %3"
H45D6462C38BC: "'%0'可能发生溢出；参数%1中的目标缓冲区大小为%2，但对应的说明符可能需要大小%3"
# "'%0' not supported, please use -iquote instead"
HD03640F49183: "'%0'不受支持，请改用 -iquote"
# "'%0' only applies to %select{function|pointer|Objective-C object or block pointer}1 types; type here is %2"
H76B771A1DA3E: "'%0'仅适用于%select{函数|指针|Objective-C对象或块指针}1类型；此处的类型是%2"
# "'%0' only applies to medium and large code models"
H2B43B16BADDB: "'%0'仅适用于中等和大型代码模型"
# "'%0' option requires target HLSL Version >= 2018%select{| and shader model >= 6.2}1, but HLSL Version is '%2'%select{| and shader model is '%3'}1"
H73FD169C1664: "'%0'选项要求目标HLSL版本 >= 2018%select{|且着色器模型 >= 6.2}1，但HLSL版本是'%2'%select{|且着色器模型是'%3'}1"
# "'%0' parameter can only be used with swiftcall%select{ or swiftasynccall|}1 calling convention%select{|s}1"
H7F6C0A7A9011: "'%0'参数只能与swiftcall%select{或swiftasynccall|}1调用约定%select{|s}1一起使用"
# "'%0' parameter must have pointer%select{| to unqualified pointer}1 type; type here is %2"
HA49C073BB7A8: "'%0'参数必须具有指针%select{|到无限定符指针}1类型；此处的类型是%2"
# "'%0' previously encountered here"
HC082D10D967F: "'%0'之前在这里遇到过"
# "'%0' qualifier is not allowed on a constructor"
HD3C37F48AA10: "'%0'限定符不能用于构造函数"
# "'%0' qualifier is not allowed on a destructor"
H63A821EC7A98: "'%0'限定符不能用于析构函数"
# "'%0' qualifier may not appear after the virtual specifier '%1'"
HC82C66448381: "'%0'限定符不能出现在virtual说明符'%1'之后"
# "'%0' qualifier may not be applied to a reference"
H39DF4A724F57: "'%0'限定符不能应用于引用"
# "'%0' qualifier on function type %1 has no effect"
HCA4F5C288E32: "'%0'限定符对函数类型%1没有影响"
# "'%0' qualifier on function type %1 has no effect and is a Clang extension"
HA82B1E90695B: "'%0'限定符对函数类型%1没有影响，并且是Clang的扩展"
# "'%0' qualifier on omitted return type %1 has no effect"
H226C520C0A5C: "'%0'限定符对省略的返回类型%1没有影响"
# "'%0' qualifier on reference type %1 has no effect"
H9D5F7EA85F79: "'%0'限定符对引用类型%1没有影响"
# "'%0' qualifier%s1 on base class type %2 %plural{1:has|:have}1 no effect"
HB4BF74C2E9A3: "'%0'限定符%s1在基类类型%2 %plural{1:has|:have}1没有影响"
# "'%0' region encountered before requires directive with '%1' clause"
HAC48A5EE380D: "'%0'区域在包含'%1'子句的requires指令之前被遇到"
# "'%0' required by '%1'"
H149191A7D780: "'%0'由'%1'要求"
# "'%0' required for precompiled header not found"
HBDA853057C16: "用于预编译头的'%0'未找到"
# "'%0' size argument is too large; destination buffer has size %1, but size argument is %2"
H1B04445BBECB: "'%0'的大小参数过大；目标缓冲区的大小为%1，但大小参数是%2"
# "'%0' specifier is not allowed outside a class definition"
H496E8612120E: "'%0' 规定符不允许在类定义外部使用"
# "'%0' statement cannot be used in OpenMP for loop"
HB1E296AE95BC: "'%0' 语句不能在OpenMP for循环中使用"
# "'%0' statement cannot be used in OpenMP simd region"
H1C587C7353B1: "'%0' 语句不能在OpenMP simd区域中使用"
# "'%0' type not found; include <omp.h>"
H4CF50F4E769F: "未找到'%0'类型；请包含<omp.h>"
# "'%0' type qualifier%s1 on return type %plural{1:has|:have}1 no effect"
H065A9C128711: "'%0' 类型限定符%s1 在返回类型 %plural{1:具有|:具有}1 无效果"
# "'%0' type specifier is incompatible with C++98"
HB674C3599FA0: "'%0' 类型说明符与C++98不兼容"
# "'%0' variables must have global storage"
H08EBA7A5907F: "'%0' 变量必须具有全局存储"
# "'%0' will always be truncated; specified size is %1, but format string expands to at least %2"
H0AA6DDAAABA2: "'%0' 将始终被截断；指定的大小为%1，但格式字符串扩展到至少%2"
# "'%0' will always evaluate to 'true' in a manifestly constant-evaluated expression"
H75D7A83FFEC6: "'%0' 在显式常量求值表达式中始终会求值为'true'"
# "'%0' will always overflow; destination buffer has size %1, but format string expands to at least %2"
H6C8DA523F6B3: "'%0' 将始终溢出；目标缓冲区的大小为%1，但格式字符串扩展到至少%2"
# "'%0' will always overflow; destination buffer has size %1, but size argument is %2"
H6A8E065AE173: "'%0' 将始终溢出；目标缓冲区的大小为%1，但尺寸参数是%2"
# "'%0' will always overflow; destination buffer has size %1, but the source string has length %2 (including NUL byte)"
H4E1F13141ECB: "'%0' 将始终溢出；目标缓冲区的大小为%1，但源字符串长度为%2（包含NUL字节）"
# "'%0' will return the size of the pointer, not the array itself"
H10D34141626D: "'%0' 将返回指针的大小，而不是数组本身"
# "'%0' within '%1'"
HFD060F45F3E4: "'%0' 在'%1' 内"
# "'%0': selected processor lacks floating point registers"
H5E83058CA4FE: "'%0'：所选处理器缺少浮点寄存器"
# "'%0': unable to pass LLVM bit-code files to linker"
H5B7DB64DAEE9: "'%0'：无法将LLVM位码文件传递给链接器"
# "'%0': unable to use AST files with this tool"
HEA339F2E046F: "'%0'：无法与此工具一起使用AST文件"
# "'%0': unable to use module files with this tool"
H25C074B573CF: "'%0'：无法与此工具一起使用模块文件"
# "'%0(%select{source|sink:vec}1)' clause%select{|s}1 cannot be mixed with '%0(%select{sink:vec|source}1)' clause%select{s|}1"
H081C849E3FF9: "'%0(%select{source|sink:vec}1)' 子句%select{|s}1 不能与 '%0(%select{sink:vec|source}1)' 子句%select{s|}1 混用"
# "'%1' attribute on property %0 does not match the property inherited from %2"
H0392738DA622: "'%1' 属性与属性%0从%2继承的属性不匹配"
# "'%1' cannot be used in %select{a constructor|a destructor|the 'main' function|a constexpr function|a function with a deduced return type|a varargs function|a consteval function}0"
HB2DCA2D92D0E: "'%1' 不能用于 %select{构造函数|析构函数|main函数|constexpr函数|具有推导返回类型的函数|可变参数函数|consteval函数}0"
# "'%select{#|#@}0' is not followed by a macro parameter"
HFFC615C42B6A: "'%select{#|#@}0' 后未跟随宏参数"
# "'%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' not supported: %select{size to copy (%4) is not a multiple of size of element type %3 (%5)|source is not a contiguous array of at least %4 elements of type %3|destination is not a contiguous array of at least %4 elements of type %3}2"
HEE3F2A4E1A36: "'%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' 不受支持：%select{要复制的大小（%4）不是元素类型%3（%5）的倍数|源不是至少%4个%3元素的连续数组|目标不是至少%4个%3元素的连续数组}2"
# "'%select{*|.*}0' specified field %select{width|precision}0 is missing a matching 'int' argument"
H0D1F0E4F63B2: "'%select{*|.*}0' 指定的字段 %select{宽度|精度}0 缺少匹配的'int'参数"
# "'%select{--|++}0' on an object of complex type is a C2y extension"
HDA93C21904C8: "'%select{--|++}0' 对复数类型对象是C2y扩展"
# "'%select{--|++}0' on an object of complex type is incompatible with C standards before C2y"
H20E81B85B020: "'%select{--|++}0' 对复数类型对象与C2y之前的C标准不兼容"
# "'%select{\\|@}0%1' command does not terminate a verbatim text block"
H42F81A2BAA36: "'%select{\\|@}0%1' 命令未终止原始文本块"
# "'%select{\\|@}0%1' command has %plural{0:no|:%2}2 word argument%s2, expected %3"
HBEDC67E6720C: "'%select{\\|@}0%1' 命令有 %plural{0:没有|:%2}2 个单词参数%s2，预期需要 %3 个"
# "'%select{\\|@}0%1' command used in a comment that is attached to a %select{function returning void|constructor|destructor|method returning void}2"
HFBFA65D15A47: "'%select{\\|@}0%1' 命令用于附加到%select{返回void的函数|构造函数|析构函数|返回void的方法}2的注释中"
# "'%select{\\|@}0%1' command used in a comment that is not attached to a function or method declaration"
H9A9CB5F0CECC: "'%select{\\|@}0%1' 命令用于未附加到函数或方法声明的注释中"
# "'%select{\\|@}0%select{classdesign|coclass|dependency|helper|helperclass|helps|instancesize|ownership|performance|security|superclass}1' command should not be used in a comment attached to a non-container declaration"
H63CA64568B3F: "'%select{\\|@}0%select{classdesign|coclass|dependency|helper|helperclass|helps|instancesize|ownership|performance|security|superclass}1' 命令不应用于附加到非容器声明的注释中"
# "'%select{\\|@}0%select{class|interface|protocol|struct|union}1' command should not be used in a comment attached to a non-%select{class|interface|protocol|struct|union}2 declaration"
H2B2D23C85C31: "'%select{\\|@}0%select{class|interface|protocol|struct|union}1' 命令不应用于附加到非%select{class|interface|protocol|struct|union}2声明的注释中"
# "'%select{\\|@}0%select{function|functiongroup|method|methodgroup|callback}1' command should be used in a comment attached to %select{a function|a function|an Objective-C method|an Objective-C method|a pointer to function}2 declaration"
H30965075CCD3: "'%select{\\|@}0%select{function|functiongroup|method|methodgroup|callback}1' 命令应用于附加到%select{函数|函数|Objective-C方法|Objective-C方法|函数指针}2声明的注释中"
# "'%select{\\|@}0param' command used in a comment that is not attached to a function declaration"
HA6D99227D713: "'%select{\\|@}0param' 命令用于未附加到函数声明的注释中"
# "'%select{\\|@}0tparam' command used in a comment that is not attached to a template declaration"
H78D96F6B0A65: "'%select{\\|@}0tparam' 命令用于未附加到模板声明的注释中"
# "'%select{auto|decltype(auto)}0' in return type deduced as %1 here but deduced as %2 in earlier return statement"
HDFEF08FDDF8E: "'%select{auto|decltype(auto)}0' 返回类型在此处推导为%1，但在之前的return语句中推导为%2"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' argument cannot refer to a union member"
HF50BCD9CECE6: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 参数不能引用联合成员"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' argument must be a simple declaration reference"
HF6AC15305460: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 参数必须是简单的声明引用"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' cannot be applied to a union member"
H01022C27C2BB: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 不能应用于联合成员"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' only applies to pointers%select{ or C99 flexible array members|||}0%select{|; did you mean to use 'counted_by'?}1"
H077E0A5BF4C4: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 仅适用于指针%select{或C99柔性数组成员|||}0%select{|；是否应使用'counted_by'?}1"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' requires a non-boolean integer type argument"
H69D52A4DAF87: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 需要一个非布尔整数类型的参数"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' field %0 isn't within the same struct as the annotated %select{pointer|flexible array}2"
HBD3F5637D173: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' 字段 %0 不在与标注的 %select{pointer|flexible array}2 同一个结构体中"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}4' %select{cannot|should not}3 be applied to %select{a pointer with pointee|an array with element}0 of unknown size because %1 is %select{an incomplete type|a sizeless type|a function type|a struct type with a flexible array member%select{|. This will be an error in a future compiler version}3}2"
HEFA740A9E276: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}4' %select{不能|不应}3 应用于 %select{指向未知大小的指针|元素为未知大小的数组}0，因为 %1 是 %select{不完整类型|无尺寸类型|函数类型|带有柔性数组成员的结构体类型%select{|。这将在未来的编译器版本中变为错误}3}2"
# "'%select{if|switch}0' initialization statements are a C++17 extension"
HBFF569602D2E: "'%select{if|switch}0' 初始化语句是 C++17 扩展"
# "'%select{make_unsigned|make_signed}0' is only compatible with non-%select{bool|_BitInt(1)}1 integers and enum types, but was given %2%select{| whose underlying type is %4}3"
H89BC3FB5059E: "'%select{make_unsigned|make_signed}0' 仅兼容非%select{bool|_BitInt(1)}1 整数和枚举类型，但传入了 %2%select{| 其基础类型为 %4}3"
# "'%select{memcpy|wmemcpy}0' between overlapping memory regions"
HF4936F4E6501: "'%select{memcpy|wmemcpy}0' 在重叠内存区域之间操作"
# "'%select{pure|const}0' attribute on function returning 'void'; attribute ignored"
H219A6665B476: "'%select{pure|const}0' 属性应用于返回 'void' 的函数；属性被忽略"
# "'%select{|short|long|long long}0 %1' is invalid"
H4742130B5F6C: "'%select{|short|long|long long}0 %1' 是无效的类型"
# "'&&' of a value and its negation always evaluates to false"
H35E9DA987909: "'&&' 与自身的否定值运算始终计算为 false"
# "'&&' within '||'"
H8790A025A3C5: "'&&' 在 '||' 运算符内使用"
# "'&' cannot precede a capture when the capture default is '&'"
HA416D7E37193: "当捕获默认为 '&' 时，'&' 不能出现在捕获前"
# "'&' must precede a capture when the capture default is '='"
HC2B64117C04B: "当捕获默认为 '=' 时，捕获前必须使用 '&'"
# "'*' query has already been specified"
H24FF63F5C6A0: "'*' 查询已被指定过"
# "'--hip-path' must be specified when offloading to SPIR-V unless '-nogpuinc' is given"
HF39C24E57C93: "当向 SPIR-V 进行设备端编译时（除非指定了 '-nogpuinc'），必须通过 '--hip-path' 指定路径"
# "'->' applied to return value of the operator->() declared here"
H2D7F207160DF: "此处应用了返回值的 '->' 运算符，该运算符在此处声明"
# "'-fopenmp-targets' must be used in conjunction with a '-fopenmp' option compatible with offloading; e.g., '-fopenmp=libomp' or '-fopenmp=libiomp5'"
HECE3FA60C323: "'-fopenmp-targets' 必须与兼容设备端编译的 '-fopenmp' 选项联用；例如 '-fopenmp=libomp' 或 '-fopenmp=libiomp5'"
# "'-fsanitize=memtag-stack' requires hardware support (+memtag). For Armv8 or Armv9, try compiling with -march=armv8a+memtag or -march=armv9a+memtag"
H3869C74238EE: "'-fsanitize=memtag-stack' 需要硬件支持（+memtag）。对于 Armv8 或 Armv9，尝试使用 -march=armv8a+memtag 或 -march=armv9a+memtag 编译"
# "'-ftrivial-auto-var-init-max-size=*' is used without '-ftrivial-auto-var-init=zero' or '-ftrivial-auto-var-init=pattern'"
H85D7452F85FC: "在未指定 '-ftrivial-auto-var-init=zero' 或 '-ftrivial-auto-var-init=pattern' 时，无法使用 '-ftrivial-auto-var-init-max-size=*'"
# "'-ftrivial-auto-var-init-max-size=*' only accepts positive integers (in bytes)"
H15368DD22E8B: "'-ftrivial-auto-var-init-max-size=*' 只接受正整数（以字节为单位）"
# "'-ftrivial-auto-var-init-stop-after=*' is used without '-ftrivial-auto-var-init=zero' or '-ftrivial-auto-var-init=pattern'"
HA64F3C5CF11D: "在未指定 '-ftrivial-auto-var-init=zero' 或 '-ftrivial-auto-var-init=pattern' 时，无法使用 '-ftrivial-auto-var-init-stop-after=*'"
# "'-ftrivial-auto-var-init-stop-after=*' only accepts positive integers"
H964D5FF3D330: "'-ftrivial-auto-var-init-stop-after=*' 只接受正整数"
# "'-fuse-ld=' taking a path is deprecated; use '--ld-path=' instead"
H24009BC2E029: "'-fuse-ld=' 接受路径的功能已弃用；请改用 '--ld-path= '"
# "'-mbranch-protection=' option is incompatible with the '%0' architecture"
H4CC02B48C139: "'-mbranch-protection= ' 选项与 '%0' 架构不兼容"
# "'-mindirect-jump=%0' is unsupported with the '%1' architecture"
HA019BCF52E06: "'-mindirect-jump=%0' 不支持 '%1' 架构"
# "'-x %0' after last input file has no effect"
H37D74D222DAD: "在最后一个输入文件之后的 '-x %0' 无效"
# "'...' as the only parameter of a function is incompatible with C standards before C23"
H0778011D458B: "函数的唯一参数为 '...' 与 C23 之前的 C 标准不兼容"
# "'...' in this location creates a C-style varargs function%select{, not a function parameter pack|}0"
HDE7D8371A836: "在此位置使用 '...' 会创建一个 C 样式可变参数函数%select{，而不是函数参数包|}0"
# "'...' must %select{immediately precede declared identifier|be innermost component of anonymous pack declaration}0"
H636262C7094A: "'...' 必须 %select{ 紧接声明的标识符之前 | 作为匿名包声明的最内层组件 }0"
# "'/*' within block comment"
HF2D384BEFA1C: "块注释内的 '/*'"
# "'/U%0' treated as the '/U' option"
HE813F64217D5: "将 '/U%0' 视为 '/U' 选项"
# "':' without preceding '?'"
H8AFE0C8D8DEE: "缺少前置 '?' 的 ':'"
# "'<::' is treated as digraph '<:' (aka '[') followed by ':' in C++98"
H79B7386C3992: "在 C++98 中，'<::' 被视为双字符符号 '<:'（即 '['）后接 ':'"
# "'<=>' is a single token in C++20; add a space to avoid a change in behavior"
HA94282EE55ED: "在 C++20 中 '<=>' 是单个标记；添加空格以避免行为变化"
# "'<=>' operator is incompatible with C++ standards before C++20"
H95F1D52E2E7F: "'<=>' 运算符与 C++20 之前的 C++ 标准不兼容"
# "'= %select{default|delete}0' is a function definition and must occur in a standalone declaration"
H500D10ACAD58: "'= %select{default|delete}0' 是函数定义，必须出现在独立声明中"
# "'= delete' with a message is a C++2c extension"
H31210BBF787E: "带有消息的 '= delete' 是 C++2c 扩展"
# "'= delete' with a message is incompatible with C++ standards before C++2c"
HF4121BB98E1E: "带有消息的 '= delete' 与 C++2c 之前的 C++ 标准不兼容"
# "'@encode' of incomplete type %0"
H26BBB8B07598: "不完全类型 %0 的 '@encode'"
# "'@end' appears where closing brace '}' is expected"
H0D104C2A47DE: "在预期闭合大括号 '}' 的位置出现 '@end'"
# "'@end' must appear in an Objective-C context"
H53F73799BBFE: "'@end' 必须出现在 Objective-C 上下文中"
# "'NSObject' attribute is for pointer types only"
HB79535A35025: 'NSObject 属性仅适用于指针类型'
# "'NSObject' attribute may be put on a typedef only; attribute is ignored"
H5749529C7AA1: 'NSObject 属性只能放在 typedef 上；属性被忽略'
# "'[[%select{nodiscard|gnu::warn_unused_result}0]]' attribute ignored when applied to a typedef; consider using '__attribute__((warn_unused_result))' or '[[clang::warn_unused_result]]' instead"
HC050BA19FE21: "当应用于 typedef 时忽略 [[%select{nodiscard|gnu::warn_unused_result}0]] 属性；建议改用 '__attribute__((warn_unused_result))' 或 '[[clang::warn_unused_result]]'"
# "'[[carries_dependency]]' attribute only allowed on parameter in a function declaration or lambda"
HA6D310EC7345: '[[carries_dependency]] 属性只能用在函数声明或 lambda 的参数上'
# "'[]' after delete interpreted as 'delete[]'; add parentheses to treat this as a lambda-expression"
H9FAF75D55EEF: "delete 后的 '[]' 被解释为 'delete[]'；添加括号以将其视为 lambda 表达式"
# "'_BitInt' %select{vector|matrix}0 element width must be %select{a power of 2|at least as wide as 'CHAR_BIT'}1"
H0C14DAF989FF: "_BitInt %select{向量|矩阵}0 的元素宽度必须为 %select{2的幂|至少与 'CHAR_BIT' 一样宽}1"
# "'_BitInt' in %select{C17 and earlier|C++}0 is a Clang extension"
HDE7EEC66FEFB: '%select{C17 及更早版本|C++}0 中的 _BitInt 是 Clang 扩展'
# "'_BitInt' suffix for literals is a C23 extension"
HA6733F109D23: '字面量的 _BitInt 后缀是 C23 扩展'
# "'_BitInt' suffix for literals is a Clang extension"
HE33869F03EE8: '字面量的 _BitInt 后缀是 Clang 扩展'
# "'_BitInt' suffix for literals is incompatible with C standards before C23"
H8F9C2C09F088: '字面量的 _BitInt 后缀与 C23 之前的 C 标准不兼容'
# "'_Complex %0' is invalid"
HF4E888A73841: "'_Complex %0' 是无效的"
# "'_ExtInt' is deprecated; use '_BitInt' instead"
H6A2C7F4FE8E7: '_ExtInt 已弃用；请改用 _BitInt'
# "'_Noreturn' can only appear on functions"
H8C4082088BE9: '_Noreturn 仅能用于函数'
# "'_Noreturn' keyword must precede function declarator"
HC448318DE5F1: '_Noreturn 关键字必须出现在函数说明符之前'
# "'_Sat' specifier is only valid on '_Fract' or '_Accum', not '%0'"
H43A3B4233E86: "_Sat 限定符仅适用于 '_Fract' 或 '_Accum'，而非 '%0'"
# "'_Static_assert' with no message is a C23 extension"
H1BCF5D7E02AE: '无消息的 _Static_assert 是 C23 扩展'
# "'_Static_assert' with no message is incompatible with C standards before C23"
H977D55CE0649: '无消息的 _Static_assert 与 C23 之前的 C 标准不兼容'
# "'__FLT_EVAL_METHOD__' cannot be expanded inside a scope containing '#pragma clang fp eval_method'"
H2CAB7A2D4110: "在包含 '#pragma clang fp eval_method' 的作用域内无法展开 '__FLT_EVAL_METHOD__'"
# "'__auto_type' is a GNU extension"
H2094509BC6E5: '__auto_type 是 GNU 扩展'
# "'__builtin_bit_cast' %select{source|destination}0 type must be trivially copyable"
H90D0B71921CD: '__builtin_bit_cast %select{源|目标}0 类型必须是可简单复制的'
# "'__builtin_choose_expr' requires a constant expression"
H090BF417F6DF: "'__builtin_choose_expr' 需要一个常量表达式"
# "'__builtin_counted_by_ref' argument cannot have side-effects"
HD566565DD11F: "'__builtin_counted_by_ref' 参数不能有副作用"
# "'__builtin_counted_by_ref' argument must reference a flexible array member"
HABF270462F6F: "'__builtin_counted_by_ref' 参数必须引用一个柔性数组成员"
# "'__builtin_ms_va_start' used in System V ABI function"
H007690BB92E1: "在 System V ABI 函数中使用了 '__clang_arm_builtin_alias' 属性"
# "'__clang__' is a predefined macro name, not an attribute scope specifier; did you mean '_Clang' instead?"
HE8F991CDE8C6: "'__clang__' 是预定义的宏名称，而非属性作用域；是否应改为 '_Clang'？"
# "'__clang_arm_builtin_alias' attribute can only be applied to an ARM builtin"
H79EABB0EF1E5: "'__clang_arm_builtin_alias' 属性只能应用于 ARM 内置函数"
# "'__clang_arm_mve_strict_polymorphism' attribute can only be applied to an MVE/NEON vector type"
H202E8786A308: "'__clang_arm_mve_strict_polymorphism' 属性只能应用于 MVE/NEON 向量类型"
# "'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support for __declspec attributes"
H465DF3E43560: "'__declspec' 属性未启用；请使用 '-fdeclspec' 或 '-fms-extensions' 启用对 __declspec 属性的支持"
# "'__declspec(dllexport)' cannot be applied to more than one default constructor in %0"
HB67031034443: "'__declspec(dllexport)' 不能应用于 %0 中的多个默认构造函数"
# "'__declspec(thread)' applied to variable that already has a thread-local storage specifier"
HFE6629E646D9: "已为带有线程本地存储说明符的变量应用了 '__declspec(thread)'"
# "'__funcref' attribute can only be applied to a function pointer type"
H5101424932DE: "'__funcref' 属性只能应用于函数指针类型"
# "'__kindof' specifier cannot be applied to non-object type %0"
HBB66D4C1FC38: "无法将 '__kindof' 规范应用于非对象类型 %0"
# "'__kindof' type specifier must precede the declarator"
H111C48694838: "'__kindof' 类型说明符必须出现在声明符之前"
# "'__leave' statement not in __try block"
HA19FB1CE432F: "'__leave' 语句不在 __try 块中"
# "'__local' variable cannot have an initializer"
H0B1BBFD1CDEA: "'__local' 变量不能带有初始化器"
# "'__pixel' must be preceded by '__vector'.  '%0' declaration specifier not allowed here"
H88B3B9C40157: "'__pixel' 必须由 '__vector' 前导。不允许在此处使用 '%0' 声明说明符"
# "'__super' cannot be used with a using declaration"
HE7865E9E15F7: "'__super' 不能与 using 声明一起使用"
# "'__thread' before '%0'"
H4E940DC3AE07: "'__thread' 位于 '%0' 之前"
# "'abi_tag' %0 missing in original declaration"
H1628165A1258: "原始声明中缺少 'abi_tag' %0"
# "'abi_tag' attribute on %select{non-inline|anonymous}0 namespace ignored"
HDBC2CCB057F1: "%select{非内联|匿名}0命名空间的'abi_tag'属性被忽略"
# "'abstract' keyword is a Microsoft extension"
HA16E3E3ED791: "'abstract'关键字是Microsoft扩展"
# "'adjust_arg' argument %0 used in multiple clauses"
H05E9C9F203D8: "'adjust_arg'参数%0在多个子句中被使用"
# "'align_value' attribute requires integer constant"
H6853424EF803: "'align_value'属性需要整型常量"
# "'alignas' is incompatible with C++98"
H0BBFE28F35BF: "'alignas'与C++98不兼容"
# "'aligned' attribute requires integer constant"
H1ADA356A8681: "'aligned'属性需要整型常量"
# "'alignof' on an incomplete array type is a C2y extension"
HFD6D41C433A2: "'alignof'用于不完整数组类型是C2y扩展"
# "'alignof' on an incomplete array type is incompatible with C standards before C2y"
HF644B202EC9A: "'alignof'用于不完整数组类型与C2y之前的标准不兼容"
# "'append_args' is not allowed with varargs functions"
H99449471B7D4: "不可与变长参数函数同时使用'append_args'"
# "'assign' property of object type may become a dangling reference; consider using 'unsafe_unretained'"
H7256F2B86929: "'assign'对象类型属性可能导致悬垂引用；建议使用'unsafe_unretained'"
# "'atomic capture' with a compound statement only supports two statements"
H0E46970C2D96: "'atomic capture'配合复合语句仅支持两个语句"
# "'auto' as a functional-style cast is incompatible with C++ standards before C++23"
HD4DCD08E6C51: "作为函数式类型转换的'auto'与C++23之前的标准不兼容"
# "'auto' deduced as 'id' in declaration of %0"
HD22AA217F352: "'auto'在%0的声明中推导为'id'类型"
# "'auto' return without trailing return type; deduced return types are a C++14 extension"
H2CC514506858: "无显式返回类型的'auto'返回值；类型推导是C++14扩展"
# "'auto' storage class specifier is not permitted in C++11, and will not be supported in future releases"
H51939B968318: "'auto'存储类说明符在C++11中已被弃用，未来版本将不再支持"
# "'auto' storage class specifier is redundant and incompatible with C++11"
HFAD8EB4C5407: "'auto'存储类说明符是冗余的，并与C++11不兼容"
# "'auto' type specifier is a %select{C++11|HLSL 202y}0 extension"
H96C499C3C66C: "'auto'类型说明符是%select{C++11|HLSL 202y}0扩展"
# "'auto' type specifier is incompatible with C++98"
HA4F3AA6BB021: "'auto'类型说明符与C++98不兼容"
# "'auto' variable template instantiation is not allowed"
H7677E31876EE: "不允许对'auto'变量模板进行实例化"
# "'begin' and 'end' returning different types (%0 and %1) is a C++17 extension"
H440F964925D8: "'begin'和'end'返回不同类型（%0和%1）是C++17扩展"
# "'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17"
HCE5BB9C433E6: "'begin'和'end'返回不同类型（%0和%1）与C++17之前的标准不兼容"
# "'break' is bound to loop, GCC binds it to switch"
HB56827FEFDD0: "'break' 与循环绑定，GCC 将其与 switch 绑定"
# "'break' statement not in loop or switch statement"
HD351562F6355: "'break' 语句不在循环或 switch 语句中"
# "'break' will never be executed"
H6E907B3877AE: "'break' 将永远不会被执行"
# "'callback' argument at position %0 references unavailable implicit 'this'"
HFC4B047896FC: "位置 %0 的 'callback' 参数引用了不可用的隐式 'this'"
# "'callback' attribute argument %0 is not a known function parameter"
H5112D2E8FE1B: "'callback' 属性参数 %0 不是已知的函数参数"
# "'callback' attribute callee does not have function type"
H11C2E7DC48A0: "'callback' 属性的调用方没有函数类型"
# "'callback' attribute callee may not be variadic"
H5339D3799089: "'callback' 属性的调用方不能是可变参数的"
# "'callback' attribute specifies invalid callback callee"
HAE51B1A6C397: "'callback' 属性指定了无效的回调调用方"
# "'callback' attribute specifies no callback callee"
HC67CEF8B86D2: "'callback' 属性未指定回调调用方"
# "'called_once' attribute only applies to function-like parameters"
HFCB51789AAF0: "'called_once' 属性仅适用于函数式参数"
# "'case' statement not in switch statement"
H3C29CC73E754: "'case' 语句不在 switch 语句中"
# "'char8_t' type specifier is incompatible with C++ standards before C++20"
H6EF68EF28349: "'char8_t' 类型说明符与 C++20 之前的 C++ 标准不兼容"
# "'cleanup' argument %select{|%1 |%1 }0is not a %select{||single }0function"
HF9B0713C400E: "'cleanup' 参数 %select{|%1 |%1 }0 不是一个 %select{||单一 }0 函数"
# "'cleanup' function %0 must take 1 parameter"
H70C0FCE6BEDE: "'cleanup' 函数 %0 必须接受 1 个参数"
# "'cleanup' function %0 parameter has %diff{type $ which is incompatible with type $|incompatible type}1,2"
H24491DE4E886: "'cleanup' 函数 %0 的参数具有 %diff{类型 $ 与类型 $ 不兼容|不兼容类型}1,2"
# "'cmse_nonsecure_entry' cannot be applied to functions with internal linkage"
H36BD2CDFCAC5: "'cmse_nonsecure_entry' 不能应用于具有内部链接的函数"
# "'co_await' modifier can only be applied to range-based for loop"
H23B6AEBD1B5B: "'co_await' 修饰符只能应用于基于范围的 for 循环"
# "'const' attribute imposes more restrictions; 'pure' attribute ignored"
HAC8EEAA61CD9: "'const' 属性施加了更多限制；忽略 'pure' 属性"
# "'consteval' specifier is incompatible with C++ standards before C++20"
HFAB40415D777: "'consteval' 规定与 C++20 之前的 C++ 标准不兼容"
# "'constexpr' can only be used in variable declarations"
HCCD21640DBE9: "'constexpr' 仅可在变量声明中使用"
# "'constexpr' non-static member function will not be implicitly 'const' in C++14; add 'const' to avoid a change in behavior"
H23AE1DDB6BF2: "'constexpr'非静态成员函数在C++14中将不会隐式为'const'；添加const以避免行为变化"
# "'constexpr' on lambda expressions is a C++17 extension"
H99E246301B16: "lambda表达式上的'constexpr'是C++17扩展"
# "'constexpr' specifier is incompatible with C++98"
H26D17B863D82: "'constexpr'说明符与C++98不兼容"
# "'constinit' specifier added after initialization of variable"
H941EB6451F6C: "'constinit'说明符在变量初始化后添加"
# "'constinit' specifier is incompatible with C++ standards before C++20"
HA94D78D91751: "'constinit'说明符与C++20之前的C++标准不兼容"
# "'constinit' specifier missing on initializing declaration of %0"
H55C3572EEC7C: "%0的初始化声明缺少'constinit'说明符"
# "'continue' statement not in loop statement"
HCD539EA88B8F: "'continue'语句不在循环语句中"
# "'copy' attribute must be specified for the block property when -fobjc-gc-only is specified"
H87791A0AEA62: "当指定-fobjc-gc-only时，块属性必须指定'copy'属性"
# "'counted_by' cannot refer to the flexible array member %0"
H5B04880F56A4: "'counted_by'不能引用柔性数组成员%0"
# "'counted_by' on arrays only applies to C99 flexible array members"
HB17E489D7021: "'counted_by'仅适用于C99柔性数组成员"
# "'cpu_dispatch' function redeclared with different CPUs"
HCA2FB0047F16: "'cpu_dispatch'函数用不同CPU重新声明"
# "'decltype' type specifier is incompatible with C++98"
H06E59DDEED89: "'decltype'类型说明符与C++98不兼容"
# "'decltype(auto)' can only be used as a return type in a function declaration"
H5356DF2FE6D3: "'decltype(auto)'只能用作函数声明的返回类型"
# "'decltype(auto)' cannot be combined with other type specifiers"
H139F443827AC: "'decltype(auto)'不能与其他类型说明符组合使用"
# "'decltype(auto)' not allowed here"
HA795F2923798: "'decltype(auto)'在此处不允许"
# "'decltype(auto)' type specifier is a C++14 extension"
H7E1DB4CB833F: "'decltype(auto)'类型说明符是C++14扩展"
# "'decltype(auto)' type specifier is incompatible with C++ standards before C++14"
HA38CAC8829B9: "'decltype(auto)'类型说明符与C++14之前的C++标准不兼容"
# "'default' statement not in switch statement"
H1133498536DD: "'default'语句不在switch语句中"
# "'defined' cannot appear within this context"
HDAE80537A1D3: "'defined'不能出现在此上下文中"
# "'defined' cannot be used as a macro name"
HB4BA3900B80E: "'defined'不能用作宏名称"
# "'delete%select{|[]}0' applied to a pointer that was allocated with 'new%select{[]|}0'; did you mean 'delete%select{[]|}0'?"
H84CC0C534191: "'delete%select{|[]}0' 应用于由 'new%select{[]|}0' 分配的指针；是否应改为 'delete%select{[]|}0'？"
# "'delete' applied to a pointer-to-array type %0 treated as 'delete[]'"
H011BFAE8BB84: "将指针数组类型 %0 作为 'delete[]' 处理"
# "'delete' cannot delete objects of type %0 in address space '%1'"
H7E66A4AF7B26: "无法在地址空间 '%1' 中删除类型 %0 的对象"
# "'depend' clause for 'ordered' is deprecated; use 'doacross' instead"
HB07DCDAB27B1: "'depend' 子句用于 'ordered' 已弃用；请改用 'doacross'"
# "'depend' clause requires the 'targetsync' interop type"
H2DD7E54EBF24: "'depend' 子句需要 'targetsync' 互操作类型"
# "'deprecated' attribute on anonymous namespace ignored"
HE49B32CE23AF: "匿名命名空间上的 'deprecated' 属性被忽略"
# "'device_type(%0)' does not match previously specified 'device_type(%1)' for the same declaration"
HDE923438E688: "'device_type(%0)' 与同一声明之前指定的 'device_type(%1)' 不匹配"
# "'diagnose_if' is a clang extension"
H6ABE610AE6BE: "'diagnose_if' 是 Clang 扩展"
# "'dllexport' attribute ignored on explicit instantiation definition"
H5570C9EC211D: "显式实例化定义上的 'dllexport' 属性被忽略"
# "'enable_if' is a clang extension"
HF8D51A54A3FE: "'enable_if' 是 Clang 扩展"
# "'explicit' can only appear on non-static member functions"
H4ED84C1B6695: "'explicit' 仅可用于非静态成员函数"
# "'explicit' can only be applied to a constructor or conversion function"
H31AF261810E7: "'explicit' 仅可应用于构造函数或转换函数"
# "'explicit' can only be specified inside the class definition"
H4954093357D9: "'explicit' 仅可在类定义内部指定"
# "'explicit' is not permitted on top-level modules"
HDAE06689A152: "顶级模块中不允许使用 'explicit'"
# "'extern' variable has an initializer"
HB91B40E25B4C: "'extern'变量有初始值设定项"
# "'extern' variable may not be referenced by '%0' clause on an OpenACC 'declare' directive"
H270234BE5B42: "外部变量可能无法被 OpenACC 'declare' 指令的 '%0' 子句引用"
# "'flush' directive with memory order clause '%0' cannot have the list"
HC2158D6851BB: "带有内存顺序子句 '%0' 的 'flush' 指令不能有列表"
# "'for co_await' belongs to CoroutineTS instead of C++20, which is deprecated"
H6DA54D0F5428: "'for co_await' 属于 CoroutineTS 而非 C++20，已被弃用"
# "'friend' must appear first in a non-function declaration"
HEBE4422274B2: "'friend' 必须出现在非函数声明的开头"
# "'friend' used outside of class"
HABD952B07FCB: "在类外部使用 'friend'"
# "'gnu_inline' attribute requires function to be marked 'inline', attribute ignored"
HEDCF2C7F36F0: "'gnu_inline' 属性要求函数被标记为 'inline'，该属性被忽略"
# "'gnu_inline' attribute without 'extern' in C++ treated as externally available, this changed in Clang 10"
H021467CD0886: "'gnu_inline' 属性在 C++ 中若未带 'extern' 则被视为外部可用，此行为在 Clang 10 版本后有所更改"
# "'hybrid_patchable' is ignored on functions without external linkage"
H0ADF7398ED3A: "'hybrid_patchable' 在没有外部链接性的函数上被忽略"
# "'inline' can only appear on functions%select{| and non-local variables}0"
H89E78E1738F9: "'inline' 只能出现在函数%select{|和非局部变量}0 上"
# "'inscan' modifier can be used only in 'omp for', 'omp simd', 'omp for simd', 'omp parallel for', or 'omp parallel for simd' directive"
HD994FA838907: "'inscan' 修饰符只能在 'omp for'、'omp simd'、'omp for simd'、'omp parallel for' 或 'omp parallel for simd' 指令中使用"
# "'internal_linkage' attribute on a non-static local variable is ignored"
H66A8BF53EA8F: "非静态局部变量上的 'internal_linkage' 属性被忽略"
# "'lifetime_capture_by' argument references itself"
H3627CC1FAD24: "'lifetime_capture_by' 参数引用自身"
# "'lifetime_capture_by' argument references unavailable implicit 'this'"
HCCCF5641FC93: "'lifetime_capture_by' 参数引用不可用的隐式 'this'"
# "'lifetime_capture_by' attribute argument %0 is not a known function parameter; must be a function parameter, 'this', 'global' or 'unknown'"
H3A8F776F3ADB: "'lifetime_capture_by' 属性参数 %0 不是已知的函数参数；必须是函数参数、'this'、'global' 或 'unknown'"
# "'lifetime_capture_by' attribute specifies no capturing entity"
HA61E4C8D2E68: "'lifetime_capture_by' 属性未指定任何捕获实体"
# "'lifetimebound' attribute cannot be applied to a %select{constructor|destructor}0"
H67DD72C3F644: "'lifetimebound' 属性无法应用于 %select{构造函数|析构函数}0"
# "'lifetimebound' attribute cannot be applied to a parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'"
H7AF0F9960FBE: "'lifetimebound' 属性无法应用于返回 void 类型函数的参数；是否应使用 'lifetime_capture_by(X)'"
# "'lifetimebound' attribute cannot be applied to an implicit object parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'"
H246C1F79D057: "'lifetimebound' 属性无法应用于返回 void 类型函数的隐式对象参数；是否应使用 'lifetime_capture_by(X)'"
# "'lifetimebound' attribute cannot be applied; %select{non-|static |explicit object }0member function has no implicit object parameter"
H4EDB6AB20113: "'lifetimebound' 属性无法应用；%select{非-|静态 |显式对象 }0 成员函数没有隐式对象参数"
# "'linear' clause cannot be specified along with 'ordered' clause with a parameter"
H20416EEA599F: "'linear' 子句不能与带有参数的 'ordered' 子句同时指定"
# "'long long' is a C++11 extension"
HC63DB1FBE144: "'long long' 是 C++11 扩展"
# "'long long' is an extension when C99 mode is not enabled"
H90F12D1B1D4D: "'long long' 在未启用 C99 模式时属于扩展"
# "'long long' is incompatible with C++98"
H0DAB29466D2C: "'long long' 与 C++98 不兼容"
# "'main' cannot be a multiversioned function"
HAFF8B40A53DE: "'main' 不能是多版本化函数"
# "'main' is not allowed to be declared %select{constexpr|consteval}0"
H13F25D825A17: "'main' 不允许被声明为 %select{constexpr|consteval}0"
# "'main' is not allowed to be declared _Noreturn"
HE455B9A59591: "'main' 不允许被声明为 _Noreturn"
# "'main' is not allowed to be declared inline"
HBC0A4A59C65E: "'main' 不允许被声明为 inline"
# "'main' is not allowed to be declared static"
HB1B95BDA01B7: "'main' 不允许被声明为 static"
# "'main' is not allowed to be declared variadic"
HD3EE247E6A72: "'main' 不允许被声明为可变参数函数"
# "'main' is not allowed to be deleted"
HB0C6AFB93EDB: "'main' 不允许被声明为 deleted"
# "'main' must return 'int'"
HD54CCE2AF684: "'main' 必须返回 'int'"
# '\'main\' should not be \'extern "%select{C|C++}0"\''
H19102C631788: '\'main\' 不应声明为 \'extern "%select{C|C++}0"\''
# "'main' should not be declared static"
H9A6B59304912: "'main' 不应被声明为 static"
# "'malloc' argument %0 must take a pointer type as its first argument"
HEF17CC57A675: "'malloc' 参数 %0 的首个参数必须是指针类型"
# "'malloc' argument %select{for deallocator |%1 |%1 }0is not a %select{||single }0function"
HC684E8204794: "'malloc' 参数 %select{用于释放器 |%1 |%1 }0 不是 %select{||单一}0 函数"
# "'malloc' argument '%0' refers to non-pointer type %1 of %2"
HFD06C554D4E6: "'malloc' 参数 '%0' 引用了 %2 的非指针类型 %1"
# "'mig_server_routine' attribute only applies to routines that return a kern_return_t"
HF1C5C16FC7E6: "'mig_server_routine' 属性仅适用于返回 kern_return_t 的例程"
# "'module' declaration found while building header unit"
HA86B9DC6C734: "构建头单元时检测到 'module' 声明"
# "'module' declaration found while building module from module map"
H880BB7F53078: "从模块映射构建模块时检测到 'module' 声明"
# "'module;' introducing a global module fragment can appear only at the start of the translation unit"
H617DC2BE71CE: "'module;' 引入全局模块片段只能出现在翻译单元的开头"
# "'musttail' attribute for this call is impossible because %select{long calls cannot be tail called on PPC|indirect calls cannot be tail called on PPC|external calls cannot be tail called on PPC}0"
H14240DA28AAD: "'musttail' 属性对此调用不可能，因为 %select{在 PPC 上无法尾调用长调用|在 PPC 上无法尾调用间接调用|在 PPC 上无法尾调用外部调用}0"
# "'musttail' attribute is not supported on AIX"
H92717FE13CEF: "AIX 不支持 'musttail' 属性"
# "'mutable' and 'const' cannot be mixed"
H6CE01BCA1797: "'mutable' 和 'const' 不能混用"
# "'mutable' can only be applied to member variables"
HC1CD8F78BDE1: "'mutable' 只能应用于成员变量"
# "'mutable' cannot be applied to functions"
H9B6452717014: "'mutable' 不能应用于函数"
# "'mutable' cannot be applied to references"
H7CCDA0B2596A: "'mutable'不能应用于引用"
# "'mutable' on a reference type is a Microsoft extension"
H6E975C04AF4E: "引用类型上的'mutable'是Microsoft扩展"
# "'mutexinoutset' modifier not allowed in 'depend' clause on 'taskwait' directive"
H54D9DFD0A59D: "'taskwait'指令的'depend'子句中不能使用'mutexinoutset'修饰符"
# "'new' cannot allocate an array of %0 with no explicit ownership"
H01CEEA4215DD: "'new'不能分配未显式指定所有权的%0类型数组"
# "'new' cannot allocate object of variably modified type %0"
HB68377C1CB34: "'new'不能分配可变长度类型%0的对象"
# "'new' cannot allocate objects of type %0 in address space '%1'"
H8F2EE8209986: "'new'不能在'%1'地址空间中分配类型%0的对象"
# "'new' expression with placement arguments refers to non-placement 'operator delete'"
H9A938FDFCB36: "带有placement参数的'new'表达式指向非placement的'operator delete'"
# "'nocf_check' attribute ignored; use -fcf-protection to enable the attribute"
HCD98AFA044EC: "'nocf_check'属性被忽略；请使用-fcf-protection选项启用该属性"
# "'noderef' can only be used on an array or pointer type"
H265BDBEEC1EC: "'noderef'只能用于数组或指针类型"
# "'noexcept' can only be used in a compound requirement (with '{' '}' around the expression)"
H88CA64B4E3F6: "'noexcept'只能用于复合需求（需用'{' '}'包裹表达式）"
# "'nonmonotonic' modifier can only be specified with 'dynamic' or 'guided' schedule kind"
H60F2BCD19874: "'nonmonotonic'修饰符只能与'dynamic'或'guided'调度类型一起使用"
# "'nonnull' attribute applied to function with no pointer arguments"
H0D4CBB499E30: "'nonnull'属性应用于无指针参数的函数"
# "'nonnull' attribute when used on parameters takes no arguments"
H8544A5398585: "用在参数上的'nonnull'属性不需要参数"
# "'nothrow' attribute conflicts with exception specification; attribute ignored"
HA43C7748DBD1: "'nothrow'属性与异常规范冲突；属性被忽略"
# "'nowait' clause is here"
H4C9748BD1A0B: "'nowait'子句在此处"
# "'nullptr' is a C23 extension"
H0CCA94E13259: "'nullptr'是C23扩展"
# "'nullptr' is incompatible with C++98"
HA3F1CF3D3055: "'nullptr'与C++98不兼容"
# "'objc_bridge(id)' is only allowed on structs and typedefs of void pointers"
H19339C3149E3: "'objc_bridge(id)'只能用于void指针的结构体或类型定义"
# "'objc_class_stub' attribute cannot be specified on a class that does not have the 'objc_subclassing_restricted' attribute"
H131E98846FD9: "未声明'objc_subclassing_restricted'属性的类不能使用'objc_class_stub'属性"
# "'objc_designated_initializer' attribute only applies to init methods of interface or class extension declarations"
H0C4330D28BB6: "'objc_designated_initializer'属性仅适用于接口或类扩展声明的初始化方法"
# "'objc_direct' attribute cannot be applied to %select{methods|properties}0 declared in an Objective-C protocol"
H0E0D013ED449: "'objc_direct' 属性不能应用于 Objective-C 协议中声明的 %select{方法|属性}0"
# "'objc_externally_retained' can only be applied to local variables %select{of retainable type|with strong ownership}0"
H863E7A12B731: "'objc_externally_retained' 仅能用于 %select{可保留类型的局部变量|具有强所有权的局部变量}0"
# "'objc_independent_class' attribute may be put on Objective-C object pointer type only; attribute is ignored"
H917C3A1684AC: "'objc_independent_class' 属性只能应用于 Objective-C 对象指针类型；该属性被忽略"
# "'objc_independent_class' attribute may be put on a typedef only; attribute is ignored"
HCF5FB9401D67: "'objc_independent_class' 属性只能应用于 typedef；该属性被忽略"
# "'omp_interop_t' must be defined when 'append_args' clause is used; include <omp.h>"
H584E24086261: "'omp_interop_t' 在使用 'append_args' 子句时必须被定义；请包含 <omp.h>"
# "'ompx_attribute' clause only allows 'amdgpu_flat_work_group_size', 'amdgpu_waves_per_eu', and 'launch_bounds'; %0 is ignored"
H15379B8D06F4: "'ompx_attribute' 子句仅允许 'amdgpu_flat_work_group_size', 'amdgpu_waves_per_eu' 和 'launch_bounds'；%0 被忽略"
# "'ompx_bare' clauses requires explicit grid size via 'num_teams' and 'thread_limit' clauses"
HC78DCADADB1C: "'ompx_bare' 子句需要通过 'num_teams' 和 'thread_limit' 子句显式指定网格大小"
# "'operator new' provided by %0 is not usable with the function signature of %1"
HC75862C47BD1: "%0 提供的 'operator new' 与 %1 的函数签名不兼容"
# "'operator->' declared here produces an object of type %0"
HC1D7E6DA4A9D: "在这里声明的 'operator->' 会产生类型为 %0 的对象"
# "'ordered' clause with a parameter cannot be specified in '#pragma omp %0' directive"
HE291A06801DB: "带有参数的 'ordered' 子句不能在 '#pragma omp %0' 指令中指定"
# "'ordered' clause%select{| with specified parameter}0"
H337028DA61A4: "'ordered' 子句%select{| 带指定参数}0"
# "'ordered' directive %select{without any clauses|with 'threads' clause}0 cannot be closely nested inside ordered region with specified parameter"
HB16FD1003ED0: "'ordered' 指令%select{无任何子句|带有 'threads' 子句}0 不能紧密嵌套在带有指定参数的有序区域内部"
# "'ordered' directive with '%0' clause cannot be closely nested inside ordered region without specified parameter"
H1845D44BB3DE: "带有 '%0' 子句的 'ordered' 指令不能紧密嵌套在无指定参数的有序区域内部"
# "'overloadable' function %0 must have a prototype"
HA041210B9619: "'overloadable' 函数 %0 必须具有原型"
# "'ownership_returns' attribute index does not match; here it is %0"
H1C0451B398DB: "'ownership_returns' 属性索引不匹配；此处为 %0"
# "'ownership_returns' attribute only applies to functions that return a pointer"
HE96B6120100D: "'ownership_returns' 属性仅适用于返回指针的函数"
# "'ownership_takes' attribute class does not match; here it is '%0'"
H2E44647C4A59: "'ownership_takes' 属性类不匹配；此处为 '%0'"
# "'packed' attribute was ignored on bit-fields with single-byte alignment in older versions of GCC and Clang"
H8DB05E11AD0A: "在旧版 GCC 和 Clang 中，'packed' 属性会忽略单字节对齐的位段"
# "'reduction' clause cannot be used with 'nogroup' clause"
H186A32581806: "'reduction' 子句不能与 'nogroup' 子句一起使用"
# "'reduction' clause not allowed with '#pragma omp loop bind(teams)'"
H4981CB6A6643: "'reduction' 子句不能与 '#pragma omp loop bind(teams)' 共同使用"
# "'reduction' clause with 'inscan' modifier is used here"
HE04EBCC11985: "带有 'inscan' 修饰符的 'reduction' 子句在此处使用"
# "'reduction' clause with 'task' modifier allowed only on non-simd parallel or worksharing constructs"
HD0FEE7231060: "带有 'task' 修饰符的 'reduction' 子句仅允许用于非SIMD并行或工作共享构造"
# "'register' storage class specifier is deprecated and incompatible with C++17"
HDBC08F071224: "'register' 存储类说明符已弃用，并且与 C++17 不兼容"
# "'register' storage specifier on @catch parameter will be ignored"
H4232960B8CCE: "@catch 参数上的 'register' 存储说明符将被忽略"
# "'regparm' is not valid on this platform"
H1E534F14C852: "'regparm' 在此平台上无效"
# "'regparm' parameter must be between 0 and %0 inclusive"
H63349C70781C: "'regparm' 参数必须在 0 到 %0 之间（含两端）"
# "'reinterpret_cast' %select{from|to}3 class %0 %select{to|from}3 its %select{virtual base|base at non-zero offset}2 %1 behaves differently from 'static_cast'"
HF87527FE7FBB: "'reinterpret_cast' 将 %select{来自|到}3 类 %0 %select{到|来自}3 其 %select{虚基类|非零偏移基类}2 %1 的行为与 'static_cast' 不同"
# "'require_constant_initialization' attribute added after initialization of variable"
HCCF005312D01: "变量初始化后添加了 'require_constant_initialization' 属性"
# "'restrict' qualifier on an array of pointers is a C23 extension"
H831A2BF01322: "指针数组上的 'restrict' 限定符是 C23 扩展"
# "'restrict' qualifier on an array of pointers is incompatible with C standards before C23"
H7AB582A89AF4: "指针数组上的 'restrict' 限定符与 C23 之前的标准不兼容"
# "'return' will never be executed"
HF9D8B2478204: "'return' 将永远不会被执行"
# "'sealed' keyword is a Microsoft extension"
H2371564F3064: "'sealed' 关键字是 Microsoft 扩展"
# "'selectany' can only be applied to data items with external linkage"
H0D95115281D5: "'selectany' 仅可应用于具有外部链接性的数据项"
# "'sentinel' attribute only supported for variadic %select{functions|blocks}0"
H0C7CDE5CC83E: "'sentinel' 属性仅支持可变参数的 %select{函数|代码块}0"
# "'sentinel' attribute requires named arguments"
HB4DB8DB54C63: "'sentinel' 属性需要命名参数"
# "'sentinel' parameter 1 less than zero"
HE854964454A6: "'sentinel' 参数 1 小于零"
# "'sentinel' parameter 2 not 0 or 1"
H99541E948450: "'sentinel' 参数 2 不是 0 或 1"
# "'size' argument to bzero is '0'"
H50A840FAEA15: "传递给 bzero 的 'size' 参数为 '0'"
# "'size_t' suffix for literals is a C++23 extension"
HE55B1E186F37: "字面量的 'size_t' 后缀是 C++23 扩展"
# "'size_t' suffix for literals is a C++23 feature"
HFE4E8B889F8C: "字面量的 'size_t' 后缀是 C++23 特性"
# "'size_t' suffix for literals is incompatible with C++ standards before C++23"
H01C26A9D5D7B: "'size_t'后缀的字面量与C++23之前的C++标准不兼容"
# "'static' can only be specified inside the class definition"
HC2C3574A2AC5: "'static'只能在类定义内部指定"
# "'static' function %0 declared in header file should be declared 'static inline'"
HAC6B8325923D: "在头文件中声明的'static'函数%0应声明为'static inline'"
# "'static' may not be used with an unspecified variable length array size"
H8C886B8B17D3: "'static'不能与未指定的可变长度数组大小一起使用"
# "'static' may not be used without an array size"
H3CD973765C05: "'static'在没有数组大小时不能使用"
# "'static' member function %0 overrides a virtual function in a base class"
H917973A36E2C: "'static'成员函数%0覆盖了基类中的虚函数"
# "'static_assert' declarations are incompatible with C++98"
HEBCFD6945359: "'static_assert'声明与C++98标准不兼容"
# "'static_assert' with a user-generated message is a C++26 extension"
HFCA41F0C6554: "带有用户生成消息的'static_assert'是C++26扩展"
# "'static_assert' with a user-generated message is incompatible with C++ standards before C++26"
H71F257CCE8FF: "带有用户生成消息的'static_assert'与C++26之前的C++标准不兼容"
# "'static_assert' with no message is a C++17 extension"
H89070CD2F991: "无消息的'static_assert'是C++17扩展"
# "'static_assert' with no message is incompatible with C++ standards before C++17"
HFE8F37E6AE5C: "无消息的'static_assert'与C++17之前的C++标准不兼容"
# "'std::allocator<...>::deallocate' used to delete a null pointer"
HF2B279909DBC: "'std::allocator<...>::deallocate'被用来删除空指针"
# "'std::source_location::__impl' must be standard-layout and have only two 'const char *' fields '_M_file_name' and '_M_function_name', and two integral fields '_M_line' and '_M_column'"
HCA27D3915F0B: "'std::source_location::__impl'必须是标准布局类型，并且只有两个'const char *'类型的字段'_M_file_name'和'_M_function_name'，以及两个整数类型的字段'_M_line'和'_M_column'"
# "'std::source_location::__impl' was not found; it must be defined before '__builtin_source_location' is called"
HD0F806FB73A8: "'std::source_location::__impl'未找到；它必须在调用'__builtin_source_location'之前被定义"
# "'super' is only valid in a method body"
HB06D73D4C0E7: "'super'仅在方法体内有效"
# "'swift_async' completion handler parameter must have block type returning 'void', type here is %0"
H9874890FB098: "'swift_async'完成处理程序参数必须具有返回'void'的块类型，此处类型为%0"
# "'swift_error_result' parameter must follow 'swift_context' parameter"
HFA5F4F66F83B: "'swift_error_result'参数必须跟在'swift_context'参数之后"
# "'swift_indirect_result' parameters must be first parameters of function"
H624EF03C7676: "'swift_indirect_result'参数必须是函数的第一个参数"
# "'switch' missing 'default' label"
H855B85E209CE: "'switch'缺少'default'标签"
# "'sycl_kernel' attribute only applies to a function template with at least two template parameters"
H5AFFA7408711: "'sycl_kernel'属性仅适用于至少包含两个模板参数的函数模板"
# "'sycl_kernel_entry_point' attribute cannot be added to a function after the function is defined"
H018E12D5A5B2: "'sycl_kernel_entry_point' 属性不能在函数定义后添加到该函数"
# "'sycl_kernel_entry_point' attribute cannot be applied to a %select{non-static member function|variadic function|deleted function|defaulted function|constexpr function|consteval function|function declared with the 'noreturn' attribute|coroutine|function defined with a function try block}0"
H86CAEB999295: "'sycl_kernel_entry_point' 属性不能应用于 %select{非静态成员函数|可变参数函数|已删除函数|默认实现函数|constexpr 函数|consteval 函数|带有 'noreturn' 属性声明的函数|协程|使用函数 try 块定义的函数}0"
# "'sycl_kernel_entry_point' attribute only applies to functions with a 'void' return type"
H99CA3F9B2DC2: "'sycl_kernel_entry_point' 属性仅适用于返回类型为 'void' 的函数"
# "'sycl_kernel_entry_point' attribute only applies to functions with a non-deduced 'void' return type"
H14251E8B39CA: "'sycl_kernel_entry_point' 属性仅适用于具有非推导 'void' 返回类型的函数"
# "'sycl_kernel_entry_point' kernel name argument conflicts with a previous declaration"
HFAE6DB6B8BBB: "'sycl_kernel_entry_point' 内核名称参数与之前的声明冲突"
# "'sycl_kernel_entry_point' kernel name argument does not match prior declaration%diff{: $ vs $|}0,1"
H6714A3237372: "'sycl_kernel_entry_point' 内核名称参数与之前的声明不匹配%diff{: $ vs $|}0,1"
# "'target_clones' attribute does not match previous declaration"
HBD2CF88C376B: "'target_clones' 属性与之前的声明不匹配"
# "'target_clones' multiversioning requires a default target"
HCC23909A82CE: "'target_clones' 多版本化需要默认目标"
# "'template' cannot be used after a declarative nested name specifier"
H7173607CA62C: "'template' 不能用在声明性嵌套名称限定符之后"
# "'template' keyword not permitted after 'using' keyword"
H026D09D01933: "不允许在 'using' 关键字之后使用 'template' 关键字"
# "'template' keyword not permitted here"
HF55CDE212145: "此处不允许使用 'template' 关键字"
# "'template' keyword not permitted in destructor name"
H67CEB40C2F65: "不允许在析构函数名称中使用 'template' 关键字"
# "'template' keyword outside of a template"
H5580CDE2DB12: "在模板外部使用 'template' 关键字"
# "'template<>' header not required for explicitly-specialized class %0 declared here"
H3FF5BAF37ECE: "显式特化的类 %0 声明此处不需要 'template<>' 头部"
# "'this' argument to member function %0 has type %1, but function is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}2"
HB5D291C13072: "成员函数 %0 的 'this' 参数类型为 %1，但函数未标记为 %select{const|restrict|const 或 restrict|volatile|const 或 volatile|volatile 或 restrict|const、volatile 或 restrict}2"
# "'this' argument to member function %0 is an %select{lvalue|rvalue}1, but function has %select{non-const lvalue|rvalue}2 ref-qualifier"
H0AF4BFFD004C: "成员函数 %0 的 'this' 参数是 %select{lvalue|rvalue}1 类型，但函数具有 %select{非 const lvalue|rvalue}2 引用限定符"
# "'this' cannot be %select{implicitly |}0captured in this context"
H0697D44E3441: "'this' 在此上下文中不能%select{隐式|}0被捕获"
# "'this' cannot be captured by reference"
H13B6762030CD: "'this' 不能通过引用来捕获"
# "'this' cannot be%select{| implicitly}0 used in a static member function declaration"
H4C9AC15A6831: "静态成员函数声明中%select{|隐式}0不能使用 'this'"
# "'this' pointer cannot be null in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0"
HC979F6DEC864: "'this' 指针在符合 C++ 标准的代码中不能为 null；该比较可能被假定始终评估为 %select{true|false}0"
# "'this' pointer cannot be null in well-defined C++ code; pointer may be assumed to always convert to true"
HE4633A40CE28: "'this' 指针在定义良好的 C++ 代码中不能为 null；该指针可能被假定始终转换为 true"
# "'this' pointer references not allowed in naked functions"
H95FED6FF2C73: "不允许在裸函数中引用 'this' 指针"
# "'trivial_abi' cannot be applied to %0"
H39CEA0BB8E5A: "'trivial_abi' 无法应用于 %0"
# "'trivial_abi' is disallowed on %0 because %select{its copy constructors and move constructors are all deleted|it is polymorphic|it has a base of a non-trivial class type|it has a virtual base|it has a __weak field|it has a field of a non-trivial class type}1"
HD222FF73C208: "'trivial_abi' 因以下原因被禁止应用于 %0：%select{其拷贝构造函数和移动构造函数均被删除|它是多态的|它具有非平凡类类型的基类|它具有虚拟基类|它具有 __weak 字段|它具有非平凡类类型的字段}1"
# "'true' is not defined, evaluates to 0"
HEC6C8880A6A3: "'true' 未定义，将计算为 0"
# "'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression"
H2191B1B324E8: "'type_tag_for_datatype' 属性要求初始化器必须是一个 %select{整数|积分}0 常量表达式"
# "'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression that can be represented by a 64 bit integer"
HD8F7C3D572F8: "'type_tag_for_datatype' 属性要求初始化器必须是一个 %select{整数|积分}0 常量表达式，并且可以由 64 位整数表示"
# "'typeid' of incomplete type %0"
H9D618623D4E9: "对不完整类型 %0 使用 'typeid'"
# "'typeid' of variably modified type %0"
HB7FBFC93B3FA: "对可变长度类型 %0 使用 'typeid'"
# "'typename' is redundant; base classes are implicitly types"
HD8EB6D904937: "'typename' 是冗余的；基类会隐式视为类型"
# "'typename' keyword used on a non-type"
HEFF0F4A3C4F6: "'typename' 关键字用在非类型上"
# "'typename' occurs outside of a template"
H0EAA185DE534: "'typename' 在模板外部出现"
# "'unavailable' availability overrides all other availability information"
H321E5EA6571D: "'unavailable' 可用性覆盖所有其他可用性信息"
# "'using namespace' is not allowed in classes"
H133BFD711C94: "不允许在类中使用 'using namespace'"
# "'using_if_exists' attribute cannot be applied to an inheriting constructor"
H551D8C76B087: "'using_if_exists' 属性不能应用于继承构造函数"
# "'va_start' cannot be used in a captured statement"
H7AC0FC921988: "无法在捕获的语句中使用 'va_start'"
# "'va_start' cannot be used outside a function"
HFCBDF5268E7D: "无法在函数外部使用 'va_start'"
# "'va_start' used in %select{System V|Win64}0 ABI function"
HCA2FE8C64692: "在 %select{System V|Win64}0 ABI 函数中使用 'va_start'"
# "'va_start' used in function with fixed args"
HDCEB40407EDC: "在具有固定参数的函数中使用 'va_start'"
# "'vec_step' requires built-in scalar or vector type, %0 invalid"
H2D0A081561E0: "'vec_step' 需要内置标量或向量类型，%0 无效"
# "'virtual' can only appear on non-static member functions"
HB1449ED6BD56: "'virtual'只能出现在非静态成员函数上"
# "'virtual' can only be specified inside the class definition"
HC2C042A27D12: "'virtual'只能在类定义内部指定"
# "'virtual' cannot be specified on member function templates"
H345B16C9EDA3: "'virtual'不能用于成员函数模板上"
# "'void' as parameter must not have type qualifiers"
H3B7FE1A42F0E: "作为参数的'void'不能带有类型限定符"
# "'void' must be the first and only parameter if specified"
H7DDAB71DFE28: "如果指定了'void'，它必须是唯一的且第一个参数"
# "'||' of a value and its negation always evaluates to true"
H067D990351EF: "一个值与其否定的'||'运算结果始终为真"
# "'~' in destructor name should be after nested name specifier"
H85ED3FE9838A: "析构函数名称中的'~'应位于嵌套名称限定符之后"
# "(skipping %0 'operator->'%s0 in backtrace)"
H3980AA6C4367: "(跳过回溯中的%0 'operator->'%s0)"
# '(skipping %0 call%s0 in backtrace; use -fconstexpr-backtrace-limit=0 to see all)'
HD7D8BC5DDF54: '(跳过回溯中的%0个调用%s0；使用-fconstexpr-backtrace-limit=0显示所有内容)'
# '(skipping %0 context%s0 in backtrace; use -ftemplate-backtrace-limit=0 to see all)'
H1BB10F671BF7: '(跳过回溯中的%0个上下文%s0；使用-ftemplate-backtrace-limit=0显示所有内容)'
# '--rtlib=libgcc requires --unwindlib=libgcc'
HED8A5F89C398: '--rtlib=libgcc需要同时指定--unwindlib=libgcc'
# '-E or -x required when input is from standard input'
H5AC04D68943E: '当输入来自标准输入时，需要指定-E或-x选项'
# '-O4 is equivalent to -O3'
H0B5239D5C711: '-O4等同于-O3'
# '-Wa,--allow-experimental-crel must be specified to use -Wa,--crel. CREL is experimental and uses a non-standard section type code'
HB2A451FA1760: '使用-Wa,--crel时必须指定-Wa,--allow-experimental-crel。CREL是实验性功能，使用非标准的节类型代码'
# '-dealloc is being overridden in a category'
H75DBC0C062A1: '-dealloc在分类中被重载'
# '-dependency-file requires at least one -MT or -MQ option'
HF99E1B6F31F8: '-dependency-file需要至少一个-MT或-MQ选项'
# '-emit-llvm cannot be used when linking'
H8745DC614FEB: '链接时不能使用-emit-llvm'
# '-fdelayed-template-parsing is deprecated after C++20'
HD52CE72E55C9: 'C++20之后，-fdelayed-template-parsing已弃用'
# '-fembed-bitcode is not supported on versions of iOS prior to 6.0'
HD9B9277DB1F5: '在iOS 6.0之前的版本中不支持-fembed-bitcode'
# '-fexperimental-omit-vtable-rtti call only be used with -fno-rtti'
H27AC8E91BEE0: '-fexperimental-omit-vtable-rtti只能与-fno-rtti一起使用'
# "-fglobal-isel support for the '%0' architecture is incomplete"
HB8576FBD6C6A: "对架构 '%0' 的 -fglobal-isel 支持尚未完成"
# '-fglobal-isel support is incomplete for this architecture at the current optimization level'
HD08F381A1C6F: '当前优化级别下，对此架构的 -fglobal-isel 支持尚未完成'
# '-fjmc works only for ELF; option ignored'
H862E3BB749F5: '-fjmc 仅适用于 ELF；选项被忽略'
# '-fobjc-arc is not supported on platforms using the legacy runtime'
HE6B9338AE9F6: '使用旧版运行时的平台不支持 -fobjc-arc'
# '-fobjc-arc is not supported on versions of OS X prior to 10.6'
H0AF526E18958: 'OS X 10.6 之前的版本不支持 -fobjc-arc'
# '-fobjc-weak is not supported in Objective-C garbage collection'
H7AD62E69E380: '在 Objective-C 垃圾回收中不支持 -fobjc-weak'
# '-fobjc-weak is not supported on the current deployment target'
H062C1F6DCD65: '当前部署目标不支持 -fobjc-weak'
# '-fsanitize-address-field-padding applied to %0'
H3C21F4C44A7E: '对 %0 应用 -fsanitize-address-field-padding'
# '-fsanitize-address-field-padding ignored for %0 because it %select{is not C++|is packed|is a union|is trivially copyable|has trivial destructor|is standard layout|is in a ignorelisted file|is ignorelisted}1'
H6C62B9F141CF: '因 %0 %select{不是 C++|是已打包的|是联合体|可简单复制|有平凡析构函数|是标准布局|位于忽略列表文件中|已忽略}1，故忽略其 -fsanitize-address-field-padding'
# "-ftest-module-file-extension argument '%0' is not of the required form 'blockname:major:minor:hashed:user info'"
HA7F31D279886: "-ftest-module-file-extension 参数 '%0' 不符合必需的格式 'blockname:major:minor:hashed:user info'"
# '-ftrivial-auto-var-init-stop-after=%0 has been enabled to limit the number of times ftrivial-auto-var-init=%1 gets applied.'
HA5103A32F2CB: '已启用 -ftrivial-auto-var-init-stop-after=%0 以限制应用 ftrivial-auto-var-init=%1 的次数。'
# '-mcmse is not supported for %0'
HBC9BABD34806: '%0 不支持 -mcmse'
# '-mharden-sls is only supported on armv7-a or later'
H370C2A9E9085: '-mharden-sls 仅支持 armv7-a 或更高版本'
# '-mtocdata option is ignored for %0 because %1'
HFF374450D777: '因 %1，故忽略 %0 的 -mtocdata 选项'
# '-mxcoff-roptr is not supported with -shared'
H6DCDD2D9C271: '与 -shared 一起使用时，不支持 -mxcoff-roptr'
# '-mxcoff-roptr is supported only with -fdata-sections'
H64F8AE7E83F9: '仅在与 -fdata-sections 一起使用时支持 -mxcoff-roptr'
# '-verify prefixes must start with a letter and contain only alphanumeric characters, hyphens, and underscores'
H52220FBA1BD4: '-verify 前缀必须以字母开头，并且仅包含字母数字字符、连字符和下划线'
# '// comments are not allowed in this language'
HC63D7ED8A253: '// 注释在此语言中不允许'
# '/arm64EC has been overridden by specified target: %0; option ignored'
HD52B23C67DCF: '指定的目标 %0 覆盖了 /arm64EC；选项被忽略'
# '32-bit targets are not supported when building for Mac Catalyst'
H2B5ECA150DDF: '构建 Mac Catalyst 时，不支持 32 位目标'
# '?: operator with omitted middle operand cannot be mangled'
H3E44EE9DABB8: '?: 操作符省略中间操作数时无法进行名称编码'
# '@%0 must be followed by a number to form an NSNumber object'
HDF1E414372F2: '@%0 必须后跟数字以形成 NSNumber 对象'
# "@catch parameter cannot have storage specifier '%0'"
HAEB289D52AD8: "@catch 参数不能使用存储说明符 '%0'"
# '@catch parameter declarator cannot be qualified'
H9BAC8F95B81C: '@catch 参数说明符不能带有限定符'
# '@catch parameter is not a pointer to an interface type'
HE87FCFF30D0A: '@catch 参数不是接口类型的指针'
# '@defs is not supported in Objective-C++'
H64B526C3172C: '@defs 在 Objective-C++ 中不受支持'
# '@implementation cannot have type parameters'
HA936A031AC88: '@implementation 不能包含类型参数'
# '@implementation declaration cannot be protocol qualified'
H4CA986D1E0F8: '@implementation 声明不能带有协议限定符'
# "@import of module '%0' in implementation of '%1'; use #import"
H16AC87FD7968: "@import 模块 '%0' 在 '%1' 的实现中使用；请改用 #import"
# '@protocol is using a forward protocol declaration of %0'
H0D6847EE9BAD: '@protocol 使用了 %0 的前向协议声明'
# '@selector expression formed with direct selector %0'
HB5C475EA47ED: '@selector 表达式使用直接选择子 %0'
# '@selector expression formed with potentially direct selector %0'
H7FC0DE89B5F4: '@selector 表达式使用潜在直接选择子 %0'
# '@synchronized requires an Objective-C object type (%0 invalid)'
H4E94A0FBFD2A: '@synchronized 需要 Objective-C 对象类型 (%0 无效)'
# "@synthesize not allowed in a category's implementation"
HAD49CB90931E: '@synthesize 不允许在分类的实现中使用'
# '@synthesize not allowed on a class property %0'
H37538A67AC33: '@synthesize 不允许用于类属性 %0'
# '@throw (rethrow) used outside of a @catch block'
HAB2C03614B94: '@throw (重新抛出) 未在 @catch 块中使用'
# '@throw requires an Objective-C object type (%0 invalid)'
HF85FCC60471E: '@throw 需要 Objective-C 对象类型 (%0 无效)'
# '@try statement without a @catch and @finally clause'
H0097E9BE678E: '@try 语句缺少 @catch 和 @finally 子句'
# "ABI '%0' is not supported for '%1'"
H7FF392C86EBF: "ABI '%0' 不支持 '%1' 的使用"
# "ABI '%0' is not supported on CPU '%1'"
H1189F24D3D62: "ABI '%0' 在 CPU '%1' 上不受支持"
# 'API notes replacement type %0 has a different size from original type %1'
HB87A25B6CDE7: 'API注释中的替换类型%0与原始类型%1的大小不同'
# 'ARC %select{unused|__unsafe_unretained|__strong|__weak|__autoreleasing}0 lifetime qualifier on return type is ignored'
H4E4E8ED8984D: 'ARC忽略返回类型上的%select{未使用的|__unsafe_unretained|__strong|__weak|__autoreleasing}0生命周期限定符'
# 'ARC forbids %select{implementation|synthesis}0 of %1'
HC91D535AD424: 'ARC禁止%select{实现|合成}0 %1'
# 'ARC forbids explicit message send of %0'
H35558B925DCC: 'ARC禁止显式发送%0消息'
# 'ARC forbids flexible array members with retainable object type'
HBA6CEB1E81A4: 'ARC禁止使用可保留对象类型的柔性数组成员'
# 'ARC forbids synthesizing a property of an Objective-C object with unspecified ownership or storage attribute'
H8E9C79FD3192: 'ARC禁止合成一个未指定所有权或存储属性的Objective-C对象属性'
# 'ARC forbids use of %0 in a @selector'
H9E100CA24C33: 'ARC禁止在@selector中使用%0'
# "AST file '%0' was compiled for the %1 '%2' but the current translation unit is being compiled for target '%3'"
HCADF9CC20080: "AST文件'%0'是为%1 '%2'编译的，但当前翻译单元的目标是'%3'"
# "AST file '%0' was not built as a module"
HF2D0BB327E40: "AST文件'%0'未作为模块构建"
# "AST file '%2' was compiled with module cache path '%0', but the path is currently '%1'"
H5B70E03C1FF3: "AST文件'%2'是使用模块缓存路径'%0'编译的，但当前路径是'%1'"
# "AVX vector %select{return|argument}0 of type %1 without '%2' enabled changes the ABI"
HA1797A0B7AA1: 'AVX向量%select{return|argument}0的类型%1在未启用%2时会改变ABI'
# "AddressSanitizer doesn't support linking with debug runtime libraries yet"
H46222370DDE7: 'AddressSanitizer目前不支持与调试运行时库链接'
# 'C does not support default arguments'
H9634D9BB0DF6: 'C不支持默认参数'
# 'C requires #line number to be less than %0, allowed as extension'
H2FF7FD761591: 'C要求#line的行号小于%0，作为扩展允许'
# 'C requires a comma prior to the ellipsis in a variadic function type'
HF2B9DE1954B1: 'C需要在可变函数类型中的省略号前有逗号'
# "C++ ABI '%0' is not supported on target triple '%1'"
H00336F051C87: "C++ ABI '%0'在目标三元组'%1'上不受支持"
# 'C++ operator %0 (aka %1) used as a macro name'
H2A2A24E029F0: 'C++运算符%0（别名%1）被用作宏名'
# 'C++11 only allows consecutive left square brackets when introducing an attribute'
H2040F8CA0C12: 'C++11仅允许在引入属性时连续使用左方括号'
# 'C++98 requires an accessible copy constructor for class %2 when binding a reference to a temporary; was %select{private|protected}0'
H89F3A4330FF6: 'C++98要求当绑定到临时对象时，类%2需要可访问的拷贝构造函数；当前是%select{private|protected}0'
# 'C99 forbids casting nonscalar type %0 to the same type'
H26E6559D43AC: 'C99禁止将非标量类型%0显式转换为自身'
# 'C99 forbids conditional expressions with only one void side'
HD3A412BC601A: 'C99 禁止只带有单个 void 类型操作数的条件表达式'
# 'CF object of type %0 is bridged to %1, which is not an Objective-C class'
H41EE49AD057C: '类型%0的CF对象被桥接到非Objective-C类%1'
# 'CFString literal is not a string constant'
H89C093890935: 'CFString 字面量不是字符串常量'
# 'CIR module verification error before running CIR-to-CIR passes'
H045DC8C3B34D: '运行 CIR-to-CIR 之前 CIR 模块验证失败'
# 'CIR-to-CIR transformation failed'
H9F8DAC16F05E: 'CIR-to-CIR 转换失败'
# "CPU '%0' does not support '%1' execution mode"
H489FB3B6F514: "CPU '%0' 不支持 '%1' 执行模式"
# 'CPU list contains duplicate entries; attribute ignored'
H40F374760829: 'CPU 列表包含重复条目；属性被忽略'
# 'CUDA device code does not support va_arg'
H3A59FE235409: 'CUDA 设备代码不支持 va_arg'
# 'CUDA device code does not support variadic functions'
H218B98CDADDE: 'CUDA 设备代码不支持可变参数函数'
# 'CUDA does not support global %0 for __device__ functions'
H8DC2F94408E4: 'CUDA 不支持在 __device__ 函数中使用全局 %0'
# 'CUDA offload target is supported only along with --emit-llvm'
H1424A8C5858B: 'CUDA offload 目标需与 --emit-llvm 选项同时使用'
# 'CUDA older than 10.0 does not support .alias'
H4BD47BC9C21A: '10.0 之前的 CUDA 版本不支持 .alias'
# "CUDA special function '%0' must have scalar return type"
H4386F29D7C1C: "CUDA 特殊函数 '%0' 必须有标量返回类型"
# 'CUDA version %0 is only partially supported'
HABB5F3AD45B9: 'CUDA 版本 %0 仅部分支持'
# 'CUDA version%0 is newer than the latest%select{| partially}1 supported version %2'
HC8470F3A3C10: 'CUDA 版本%0 比最新%select{| 部分}1 支持的版本 %2 更新'
# "Clang permits use of type 'double' regardless pragma if 'cl_khr_fp64' is supported"
H36E837B04A86: "Clang 允许在支持 'cl_khr_fp64' 时无论 #pragma 设置都使用 'double' 类型"
# 'ClangIR code gen Not Yet Implemented: %0'
HC54E3E6A2065: 'ClangIR 代码生成尚未实现: %0'
# 'ClangIR code gen Not Yet Implemented: %0: %1'
H56E1FD5A9575: 'ClangIR 代码生成尚未实现: %0: %1'
# 'Error collecting HIP undefined fatbin symbols: %0'
H8A6EDE3371D0: '读取 HIP 未定义 fatbin 符号时出错: %0'
# 'Error in reading profile %0: %1'
H431D01FCD538: '读取配置文件 %0 时出错: %1'
# 'FIX-IT applied suggested code changes'
H19B769DF31D9: 'FIX-IT 已应用建议的代码更改'
# 'FIX-IT detected an error it cannot fix'
HD809189A8863: 'FIX-IT 检测到无法修复的错误'
# 'FIX-IT detected errors it could not fix; no output will be generated'
HEE3E7F0F9BA0: 'FIX-IT 检测到无法修复的错误；将不会生成输出'
# 'FIX-IT unable to apply suggested code changes'
H2B4E9FB21753: 'FIX-IT 无法应用建议的代码更改'
# 'FIX-IT unable to apply suggested code changes in a macro'
H3E3C2FB702A6: 'FIX-IT 无法在宏中应用建议的代码更改'
# 'Fuchsia API Level prohibits specifying a minor or sub-minor version'
H73A16BC6357D: 'Fuchsia API 级别禁止指定次要或子次要版本'
# 'GCC does not allow %0 attribute in this position on a function definition'
H6258B157AA4F: 'GCC 不允许在此位置在函数定义上使用%0属性'
# 'GCC does not allow an attribute in this position on a function declaration'
H6328F86D9296: 'GCC 不允许在此位置在函数声明上使用属性'
# 'GCC does not allow the %0 attribute to be written on a type'
HAF18361FDD0D: 'GCC 不允许将%0属性应用于类型'
# "GCC does not allow the 'cleanup' attribute argument to be anything other than a simple identifier"
HB0EE895D3D5D: "GCC 要求'cleanup'属性参数只能是简单标识符"
# 'GCC does not allow variable declarations in for loop initializers before C99'
HD212EAC451BD: '在C99之前，GCC 不允许在for循环初始化器中声明变量'
# 'GCC requires a function with the %0 attribute to be variadic'
H4044A123EF83: 'GCC 要求带有%0属性的函数必须是可变参数函数'
# 'GNU decimal type extension not supported'
HE1719E002830: 'GNU十进制类型扩展未被支持'
# 'GNU vector conditional operand cannot be %select{void|a throw expression}0'
H5DF13110207F: 'GNU向量条件操作数不能是%select{void|throw表达式}0'
# 'GNU-style inline assembly is disabled'
H2E56E6455BF0: '已禁用GNU风格的内联汇编'
# 'GNUstep Objective-C runtime version %0 incompatible with target binary format'
HBFB3FAB065B9: 'GNUstep Objective-C运行时版本%0与目标二进制格式不兼容'
# "GPU arch %0 is supported by CUDA versions between %1 and %2 (inclusive), but installation at %3 is %4; use '--cuda-path' to specify a different CUDA install, pass a different GPU arch with '--cuda-gpu-arch', or pass '--no-cuda-version-check'"
HA444373A0822: "GPU架构%0在CUDA %1到%2版本（含）中受支持，但%3处的安装版本为%4；请使用'--cuda-path'指定其他CUDA安装路径，或通过'--cuda-gpu-arch'指定不同GPU架构，或使用'--no-cuda-version-check'禁用版本检查"
# 'HIP does not support OpenMP target directives; directive has been ignored'
H0DF90C6E349C: 'HIP 不支持OpenMP目标指令；该指令已被忽略'
# "HLSL code generation is unsupported for target '%0'"
HE92A9C826849: "不支持为目标'%0'生成HLSL代码"
# 'HLSL resource needs to have [[hlsl::resource_class()]] attribute'
HAC100FF02618: 'HLSL资源需要具有[[hlsl::resource_class()]]属性'
# "HTML end tag '%0' is forbidden"
H685A0F5F60EA: "HTML结束标签'%0'是被禁止的"
# 'HTML end tag does not match any start tag'
H04F1BAAABD62: 'HTML结束标签与任何开始标签不匹配'
# "HTML start tag '%0' closed by '%1'"
H5D28040DFF0A: "HTML开始标签'%0'被'%1'关闭"
# "HTML start tag prematurely ended, expected attribute name or '>'"
HB396911AC86C: "HTML开始标签提前结束，期望属性名或'>'"
# "HTML tag '%0' requires an end tag"
HC3A525011E51: "HTML标签'%0'需要结束标签"
# 'HTML tag started here'
H3CB5C9051AF3: 'HTML标签从这里开始'
# 'IBOutletCollection properties should be copy/strong and not assign'
H91B04B0AEDF0: 'IBOutletCollection属性应使用copy/strong而非assign'
# 'ISO C does not allow indirection on operand of type %0'
HC4C25916B558: 'ISO C不允许对类型%0的操作数进行间接访问'
# "ISO C does not support '~' for complex conjugation of %0"
H592FB210723A: "ISO C不支持使用'~'对%0进行复数共轭"
# "ISO C forbids forward references to 'enum' types"
H3A2E43246AF1: "ISO C禁止向前引用'enum'类型"
# "ISO C forbids taking the address of an expression of type 'void'"
H5DC6DC421D10: "ISO C不允许为类型'void'的表达式取地址"
# "ISO C requires a named parameter before '...'"
HAAD7320B82D0: 'ISO C要求在"..."之前有一个命名参数'
# 'ISO C requires a translation unit to contain at least one declaration'
HD453AE5DFC44: 'ISO C要求翻译单元中至少包含一个声明'
# 'ISO C++ considers this destructor name lookup to be ambiguous'
H51664244F36F: 'ISO C++认为此析构函数名查找存在歧义'
# 'ISO C++ does not allow %select{an attribute list|%0}1 to appear here'
H6EEF885F4392: 'ISO C++不允许在此处出现%select{属性列表|%0}1'
# 'ISO C++ does not allow %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 because it casts away qualifiers, even though the source and destination types are unrelated'
HA24736A782D5: 'ISO C++不允许在此处使用%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0从%1到%2进行转换，因为该转换会丢弃限定符，即使源类型和目标类型无关'
# "ISO C++ does not permit the 'bool' keyword after 'concept'"
HED15AAEA01CD: "ISO C++禁止在'concept'之后使用'bool'关键字"
# "ISO C++ forbids forward references to 'enum' types"
H565E6A76B7E7: "ISO C++禁止向前引用'enum'类型"
# "ISO C++ only allows ':' in member enumeration declaration to introduce a fixed underlying type, not an anonymous bit-field"
HD765E30339DE: "ISO C++仅允许在成员枚举声明中使用':'来引入固定的基础类型，而不是匿名位字段"
# 'ISO C++ requires a definition in this translation unit for %select{function|variable}0 %q1 because its type does not have linkage'
HCF564C1243BB: 'ISO C++要求为%select{函数|变量}0 %q1在当前翻译单元中提供定义，因为其类型没有链接性'
# 'ISO C++ requires field designators to be specified in declaration order; field %1 will be initialized after field %0'
HF7272CADD93F: 'ISO C++ 要求字段设计符按声明顺序指定；字段 %1 将在字段 %0 之后初始化'
# "ISO C++ requires the name after '::~' to be found in the same scope as the name before '::~'"
H1B12535D9EA0: "ISO C++ 要求'::~'之后的名称与'::~'之前的名称处于同一作用域"
# "ISO C++ specifies that qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context, despite preceding %select{'typename'|'template'}2 keyword"
H0AEAB31369D3: "ISO C++ 规定在此上下文中，对%0的限定引用是一个构造函数名称而非%select{模板名称|类型}1，尽管前面有%select{'typename'|'template'}2关键字"
# 'ISO C++ standards before C++17 do not allow new expression for type %0 to use list-initialization'
H36A45BAF91C7: 'ISO C++17之前的版本不允许类型%0的new表达式使用列表初始化'
# 'ISO C++11 does not allow access declarations; use using declarations instead'
H949947FDD999: 'ISO C++11 不允许使用访问声明；请改用using声明'
# 'ISO C++11 does not allow conversion from string literal to %0'
HDCEA926F7FF8: 'ISO C++11 不允许将字符串字面量转换为%0'
# 'ISO C++11 requires a parenthesized pack declaration to have a name'
H70DD46DED2FB: 'ISO C++11 要求括号化的打包声明必须具有名称'
# "ISO C++17 does not allow 'register' storage class specifier"
HFBD7E25436E2: 'ISO C++17 不允许使用"register"存储类说明符'
# 'ISO C++17 does not allow a decomposition group to be empty'
H38C9A47FB6B4: 'ISO C++17 不允许分解组为空'
# 'ISO C++17 does not allow dynamic exception specifications'
HDA1158B635F1: 'ISO C++17 不允许使用动态异常规格说明'
# 'ISO C++17 does not allow incrementing expression of type bool'
H8CE1E8E6EA54: 'ISO C++17 不允许对bool类型的表达式进行递增操作'
# "ISO C++20 considers use of overloaded operator '%0' (with operand types %1 and %2) to be ambiguous despite there being a unique best viable function%select{ with non-reversed arguments|}3"
HE2B331A9C128: 'ISO C++20 认为此处使用重载的运算符"%0"（操作数类型为%1和%2）存在歧义，尽管存在一个具有非反转参数的唯一最佳可行函数%select{ |}3'
# "ISO C++20 requires return type of selected 'operator==' function for rewritten '%1' comparison to be 'bool', not %0"
H96DD21560E53: 'ISO C++20 要求重写后的"%1"比较所选的"operator=="函数的返回类型应为"bool"，而非%0'
# 'ISO C90 does not allow subscripting non-lvalue array'
HB75A7925DCA5: 'ISO C90 不允许对非常量左值数组进行下标访问'
# 'ISO C99 requires whitespace after the macro name'
HDC593F4C1475: 'ISO C99 要求宏名称后必须有空白字符'
# 'LMUL argument must be in the range [0,3] or [5,7]'
H3949F7728682: 'LMUL 参数必须在范围 [0,3] 或 [5,7] 内'
# 'LTO requires -fuse-ld=lld'
H1F6F6CBC7560: 'LTO 需要使用 -fuse-ld=lld 选项'
# 'MS-style inline assembly is not available: %0'
H730B2A8B0BD8: 'Microsoft风格的内联汇编不可用：%0'
# 'Mangling number exceeds limit (65535)'
HB23269E224B2: '编码的数字超过限制（65535）'
# 'NVPTX target requires CUDA 9.2 or above; CUDA %0 detected'
HC81CA29CBF97: 'NVPTX 目标需要 CUDA 9.2 或更高版本；检测到 CUDA %0'
# 'Neon vector size must be 64 or 128 bits'
H97DBFE49CD6B: 'NEON向量大小必须为64或128位'
# 'No offloading entry generated while offloading is mandatory.'
H4E35CC32EE7C: '强制卸载时未生成卸载条目。'
# 'OBJECT_MODE setting %0 is not recognized and is not a valid setting'
HEC8A063EC23B: 'OBJECT_MODE设置%0无法识别，且不是有效设置'
# 'Objective-C GC does not allow weak variables on the stack'
H501EF197353A: 'Objective-C垃圾回收机制不允许在栈上使用弱变量'
# 'Objective-C declarations may only appear in global scope'
HBE7743C7A3D5: 'Objective-C声明只能出现在全局作用域中'
# 'Objective-C index expression has incomplete class type %0'
H3BF9CC2B38D9: 'Objective-C索引表达式具有不完整类类型%0'
# 'Objective-C message has incomplete result type %0'
HA58AB6CD0922: 'Objective-C消息具有不完整的结果类型%0'
# 'Objective-C methods as coroutines are not yet supported'
H197AF4BB9670: 'Objective-C方法作为协程尚未得到支持'
# 'Objective-C object of type %0 is bridged to %1, which is not valid CF object'
HC21532E95928: '类型%0的Objective-C对象被桥接到无效的CF对象%1'
# 'Offloading entry for declare target variable %0 is incorrect: the address is invalid.'
H44B1C3BF0A67: '声明目标变量%0的卸载条目不正确：地址无效。'
# 'Offloading entry for declare target variable is incorrect: the address is invalid.'
H3668F9F00CF1: '声明目标变量的卸载条目不正确：地址无效。'
# 'Offloading entry for target region in %0 is incorrect: either the address or the ID is invalid.'
HB922AD26B2CB: '在%0中的目标区域卸载条目不正确：地址或ID无效。'
# "OpenACC %select{clause '%1'|directive '%2'|sub-array bound}0 requires expression of integer type (%3 invalid)"
H24F0AB7B1FF3: "OpenACC %select{子句'%1'|指令'%2'|子数组边界}0需要整型表达式（%3无效）"
# "OpenACC '%0' clause cannot appear on the same '%2' construct as a '%1' clause %select{inside a compute construct with a|and a}3 'num_gangs' clause with more than one argument"
H86F6667DC7E5: "OpenACC '%0'子句不能与同一'%2'结构中的'%1'子句%select{在带有|和}3 'num_gangs'子句（参数超过一个时）共存"
# "OpenACC '%0' clause on a 'declare' directive is not allowed at global or namespace scope"
H0D95AB23A6A9: "在全局或命名空间作用域中不允许在'declare'指令的'%0'子句上使用"
# "OpenACC '%0' construct can only be applied to a 'for' loop"
H7F39DD2F9D48: "OpenACC '%0'结构必须应用于一个'for'循环"
# "OpenACC '%0' construct must have a terminating condition"
HA5F584B3696E: "OpenACC '%0'结构必须有一个终止条件"
# "OpenACC '%0' construct must have at least one %1 clause"
H5108FA0063F8: "OpenACC '%0'结构必须至少包含一个%1子句"
# "OpenACC '%0' construct must have initialization clause in canonical form ('var = init' or 'T var = init')"
HB6396996D535: "OpenACC '%0'结构必须以规范形式包含初始化子句（'var = init'或'T var = init'）"
# "OpenACC '%0' variable must monotonically increase or decrease ('++', '--', or compound assignment)"
H4842B31AA1BD: "OpenACC '%0'变量必须单调递增或递减（使用'++'、'--'或复合赋值）"
# "OpenACC '%1' clause %select{|with more than 1 argument }0may not appear on a '%2' construct with a '%3' clause%select{ with more than 1 argument|}0"
HE77D7FA4A4F6: "OpenACC '%1' 子句 %select{|带有超过1个参数的 }0不能出现在带有 '%3' 子句%select{ 带有超过1个参数的|}0的 '%2' 构造中"
# "OpenACC '%1' clause cannot appear more than once on a '%0' directive"
H22BA6A918DDE: "OpenACC '%1' 子句在 '%0' 指令上不能出现多次"
# "OpenACC '%1' clause is not valid on '%0' directive"
H226495157F78: "OpenACC '%1' 子句在 '%0' 指令上无效"
# "OpenACC 'collapse' clause loop count must be a %select{constant expression|positive integer value, evaluated to %1}0"
HF187F732137C: "OpenACC 'collapse' 子句循环计数必须是 %select{常量表达式|正整数值，计算为 %1}0"
# "OpenACC 'gang' clause may have at most one %select{unnamed or 'num'|'dim'|'static'}0 argument"
HC064C4557CFE: "OpenACC 'gang' 子句最多可以有一个 %select{未命名或'num'|'dim'|'static'}0 参数"
# "OpenACC 'reduction' composite variable must not have non-scalar field"
H9A717A5BB65E: "OpenACC 'reduction' 组合变量不能包含非标量字段"
# "OpenACC 'reduction' variable must be a composite of scalar types; %1 %select{is not a class or struct|is incomplete|is not an aggregate}0"
HD35F9CAD567D: "OpenACC 'reduction'变量必须是标量类型的聚合；%1%select{不是类或结构体|类型不完整|不是聚合类型}0"
# "OpenACC 'reduction' variable must be of scalar type, sub-array, or a composite of scalar types;%select{| sub-array base}1 type is %0"
HEC7D1B479B8F: "OpenACC 'reduction' 变量必须是标量类型、子数组或标量类型的组合;%select{|子数组基}1类型是 %0"
# "OpenACC 'reduction' variable must have the same operator in all nested constructs (%0 vs %1)"
H28C388119D4E: "OpenACC 'reduction' 变量在所有嵌套构造中必须使用相同的运算符 (%0 与 %1 冲突)"
# "OpenACC 'tile' clause size expression must be %select{an asterisk or a constant expression|positive integer value, evaluated to %1}0"
HA638C30812B2: "OpenACC 'tile' 子句尺寸表达式必须是 %select{星号或常量表达式|正整数值，计算为 %1}0"
# "OpenACC 'update' construct may not appear in place of the statement following a%select{n if statement| while statement| do statement| switch statement| label statement}0"
H3E931AFE1E4E: "OpenACC 'update' 构造不能出现在%select{if语句后的|while语句后的|do语句后的|switch语句后的|标签语句后的}0语句位置"
# "OpenACC clause '%0' may not appear on the same construct as a '%1' clause on a '%2' construct"
HFD5E5BF152EC: "OpenACC '%0' 子句不能与 '%1' 子句出现在同一 '%2' 构造中"
# "OpenACC clause '%0' may not follow a '%1' clause in a '%2' construct"
H3810BDC5F66B: "OpenACC '%0' 子句不能在 '%2' 构造中跟随 '%1' 子句"
# "OpenACC clause '%0' on '%1' construct conflicts with previous data dependence clause"
HD0EC8D82D89C: "OpenACC '%0' 子句在 '%1' 构造中与之前的数据依赖子句冲突"
# "OpenACC clause name '%0' is a deprecated clause name and is now an alias for '%1'"
H0277741A1F9D: "OpenACC 子句名称 '%0' 是已弃用的子句名称，现为 '%1' 的别名"
# "OpenACC construct '%0' cannot be used here; it can only be used in a statement context"
HCF6F4162FC42: "OpenACC 构造 '%0' 不能在此处使用；它只能在语句上下文中使用"
# "OpenACC construct 'routine' with implicit function not yet implemented, pragma ignored"
H861502AB5841: "OpenACC 构造 'routine' 带有隐式函数尚未实现，pragma 被忽略"
# "OpenACC construct 'self' has no effect when an 'if' clause evaluates to true"
H4B8F857AB30C: "OpenACC 构造 'self' 在 'if' 子句求值为真时无效"
# 'OpenACC integer expression has incomplete class type %0'
H5F66C1830606: 'OpenACC 整数表达式具有不完整类类型 %0'
# 'OpenACC integer expression requires explicit conversion from %0 to %1'
H20507033806F: 'OpenACC 整数表达式需要将 %0 显式转换为 %1'
# "OpenACC routine name '%0' does not name a function"
H5802CAE72248: "OpenACC例行程序名称'%0'未命名一个函数"
# "OpenACC routine name '%0' names a set of overloads"
HEC7D774C632B: "OpenACC例行程序名称'%0'指向一组重载函数"
# 'OpenACC sub-array %select{lower bound|length}0 evaluated to a value (%1) that would be out of the range of the subscripted array size of %2'
HD993EBC2FF56: 'OpenACC子数组%select{下界|长度}0计算得到的值(%1)超出了所下标数组%2的大小范围'
# 'OpenACC sub-array %select{lower bound|length}0 evaluated to negative value %1'
H9C42001B0E35: 'OpenACC子数组%select{下界|长度}0计算得到负值%1'
# 'OpenACC sub-array base is of incomplete type %0'
H568C42694CA4: 'OpenACC子数组基类型为不完全类型%0'
# 'OpenACC sub-array cannot be of function type %0'
H1F4C209C1D7A: 'OpenACC子数组不能是函数类型%0'
# 'OpenACC sub-array length is unspecified and cannot be inferred because the subscripted value is %select{not an array|an array of unknown bound}0'
H3D8516DAE66C: 'OpenACC子数组长度未指定且无法推断，因为所下标值为%select{非数组|未知边界的数组}0'
# 'OpenACC sub-array specified range [%0:%1] would be out of the range of the subscripted array size of %2'
H7C8F28679BDB: 'OpenACC子数组指定范围[%0:%1]超出了所下标数组%2的大小范围'
# 'OpenACC sub-array subscripted value is not an array or pointer'
H64A7517C6764: 'OpenACC子数组所下标值不是数组或指针'
# "OpenACC variable %select{in 'use_device' clause|on 'declare' construct}0 is not a valid variable name or array name"
H5FFA8811F2EF: "OpenACC变量%select{'use_device'子句中的|'declare'结构中的}0不是一个有效的变量名或数组名"
# 'OpenACC variable in cache directive is not a valid sub-array or array element'
H0DEC3018E66D: 'OpenACC在cache指令中的变量不是一个有效的子数组或数组元素'
# 'OpenACC variable is not a valid variable name, sub-array, array element,%select{| member of a composite variable,}0 or composite variable member'
HA8B26141C7C6: 'OpenACC变量不是一个有效的变量名、子数组、数组元素%select{|或复合变量的成员,}0或复合变量成员'
# 'OpenCL extension %0 is core feature or supported optional core feature - ignoring'
H1E2DAA7C8DD9: 'OpenCL扩展%0是核心特性或支持的可选核心特性 - 忽略'
# 'OpenCL extension %0 unknown or does not require pragma - ignoring'
HB7D9C7E097C0: 'OpenCL扩展%0未知或不需要#pragma - 忽略'
# 'OpenMP array shaping operation is not allowed here'
H6B78DAFB84E5: 'OpenMP数组成形操作在此处不允许'
# 'OpenMP captured regions are not yet supported in %select{streaming functions|functions with ZA state|functions with ZT0 state}0'
HBFAEB31DF5F3: 'OpenMP捕获区域在%select{流函数|具有ZA状态的函数|具有ZT0状态的函数}0中尚未支持'
# "OpenMP clause '%0' is only available as extension, use '-fopenmp-extensions'"
H7D732B734761: "OpenMP子句'%0'仅作为扩展可用，请使用'-fopenmp-extensions'"
# 'OpenMP constructs may not be nested inside a simd region%select{| except for ordered simd, simd, scan, or atomic directive}0'
HC65424272817: 'OpenMP结构不能嵌套在simd区域内%select{|，除非是ordered simd、simd、scan或atomic指令}0'
# 'OpenMP constructs may not be nested inside an atomic region'
HE2C47884F9E6: 'OpenMP结构不能嵌套在原子区域内'
# "OpenMP extension clause '%0' only allowed with '#pragma omp %1'"
HB7695EC8B674: "OpenMP扩展子句'%0'仅允许与'#pragma omp %1'一起使用"
# 'OpenMP iterator is not allowed here'
HB9668BC52F3C: 'OpenMP迭代器不允许在这里使用'
# 'OpenMP loop iteration variable cannot have more than 64 bits size and will be narrowed'
H85A842BD8107: 'OpenMP循环迭代变量的大小不能超过64位，将被截断'
# "OpenMP offloading target '%0' is similar to target '%1' already specified; will be ignored"
H66F93F9F54F1: "OpenMP卸载目标'%0'与已指定的'%1'目标相似；将被忽略"
# 'OpenMP only allows an ordered construct with the simd clause nested in a simd construct'
H52C83AA3C087: 'OpenMP仅允许将带有simd子句的ordered结构嵌套在simd结构中'
# 'OpenMP support in flang is still experimental'
HA42DEF114A36: 'flang中的OpenMP支持仍处于实验阶段'
# "OpenMP target architecture '%0' pointer size is incompatible with host '%1'"
HF18160FDA94C: "OpenMP目标架构'%0'的指针大小与主机'%1'不兼容"
# "OpenMP target is invalid: '%0'"
H6461D2D7A8F6: "无效的OpenMP目标：'%0'"
# 'PCH was compiled with different VFS overlay files than are currently in use'
H6654F3AEB3F7: 'PCH是使用与当前不同的VFS覆盖文件编译的'
# 'Pascal string is too long'
HDF5B602956C9: 'Pascal字符串过长'
# "RISC-V interrupt attribute '%0' requires extension '%1'"
H6CFF2777C071: "RISC-V中断属性'%0'需要扩展'%1'"
# "RISC-V type %0 requires the '%1' extension"
HD2DE400562E4: "RISC-V类型%0需要'%1'扩展"
# 'ROPI is not compatible with c++'
HF729D02F7368: 'ROPI与C++不兼容'
# "SDK does not contain 'libarclite' at the path '%0'; try increasing the minimum deployment target"
HBB626BB3124D: "SDK在路径'%0'中不包含'libarclite'；尝试提高最低部署目标"
# "SDK settings were ignored as 'SDKSettings.json' could not be parsed"
HF609237E0BEB: "由于无法解析'SDKSettings.json'，SDK设置被忽略"
# "SEH '__try' is not supported on this target"
H06D89FCA39AA: "SEH '__try'在此目标上不受支持"
# 'SVE vector type %0 cannot be used in a non-streaming function'
H9A5DD8A133CA: 'SVE向量类型%0不能在非流式函数中使用'
# 'SVE vector type %0 cannot be used in a target without sve'
H9A595E01748A: 'SVE向量类型%0不能在没有sve的目标中使用'
# 'SourceLocation in file %0 at offset %1 is invalid'
H2A6519004798: '文件%0中偏移量%1处的SourceLocation无效'
# 'The clause simdlen must fit the %0-bit lanes in the architectural constraints for SVE (min is 128-bit, max is 2048-bit, by steps of 128-bit)'
H637FD9B0F74C: 'simdlen子句必须符合SVE架构约束中的%0位通道（最小为128位，最大为2048位，步长为128位）'
# 'The clause simdlen(1) has no effect when targeting aarch64.'
H28E8D9873AFA: '当目标为aarch64时，simdlen(1)子句无效'
# 'The value specified in simdlen must be a power of 2 when targeting Advanced SIMD.'
HAAC03787F717: 'simdlen指定的值在针对Advanced SIMD目标时必须是2的幂。'
# 'Unexpected vftable component type %0 for component number %1'
H40151C08E668: '组件号%1的vftable组件类型%0意外'
# 'WebAssembly reference type not allowed in exception specification'
H14B705277A94: 'WebAssembly引用类型不允许在异常说明中使用'
# 'WebAssembly table cannot be declared within a function'
H085E37C320EB: 'WebAssembly表不能在函数内部声明'
# 'WebAssembly table must be static'
H23C0F2D20589: 'WebAssembly表必须是静态的'
# '[[]] attributes are a C++11 extension'
H8246F8EB1C38: '[[ ]]属性是C++11扩展'
# '[[]] attributes are a C23 extension'
H65C81736C143: '[[ ]]属性是C23扩展'
# '[[]] attributes are incompatible with C standards before C23'
HFCBAAA359BD9: '[[ ]]属性与C23之前的C标准不兼容'
# '[[]] attributes are incompatible with C++ standards before C++11'
H963EC793AF1E: '[[ ]]属性与C++11之前的C++标准不兼容'
# '[no]neon is not accepted as modifier, please use [no]simd instead'
H34DCBA8F9AA1: '[no]neon不能作为修饰符使用，请改用[no]simd'
# '\\%0 used with no following hex digits'
H4ACD9688DA19: '\\%0使用时未跟随十六进制数字'
# "\\%0 used with no following hex digits; treating as '\\' followed by identifier"
H34C9A007F8A0: "\\%0使用时未跟随十六进制数字；将视为'\\'后跟标识符"
# '^^ is a reserved operator in OpenCL'
H0C0A23A57F10: '^^在OpenCL中是保留运算符'
# '_Atomic cannot be applied to %select{incomplete |array |function |reference |atomic |qualified |sizeless ||integer |}0type %1 %select{|||||||which is not trivially copyable||in C23}0'
H323CC2CB8E5D: '_Atomic不能应用于%select{不完整 |数组 |函数 |引用 |原子 |限定 |无尺寸 ||整数 |}0类型%1 %select{|||||||无法被简单复制||在C23中}0'
# '_Pragma takes a parenthesized string literal'
HC3D115F3D6CB: '_Pragma需要一个括号包围的字符串字面量'
# '__VA_ARGS__ can only appear in the expansion of a C99 variadic macro'
HA5D98E4DA6FF: '__VA_ARGS__只能在C99可变参数宏的展开中出现'
# '__VA_OPT__ can only appear in the expansion of a variadic macro'
HCDC494FE863F: '__VA_OPT__只能在可变参数宏的展开中出现'
# '__VA_OPT__ cannot be nested within its own replacement tokens'
H7C3979F48311: '__VA_OPT__不能嵌套在其自身的替换标记中'
# '__arm_agnostic("sme_za_state") cannot share ZA state with its caller'
H3F5679E58734: '__arm_agnostic("sme_za_state")不能与其调用者共享ZA状态'
# '__arm_agnostic("sme_za_state") is not supported together with __arm_new("za") or __arm_new("zt0")'
H1551D9BB8B08: '__arm_agnostic("sme_za_state")不能与__arm_new("za")或__arm_new("zt0")一起使用'
# '__asm used with no assembly instructions'
H8FE87A3A5F53: '__asm在没有汇编指令的情况下使用'
# '__block attribute not allowed on declaration with a variably modified type'
H10FB78A8E9A5: '__block属性不允许在具有变长修改类型的声明中使用'
# '__block attribute not allowed, only allowed on local variables'
HE188099287CD: '__block属性不允许使用，仅允许在局部变量上使用'
# '__block variable %0 cannot be captured in a %select{lambda expression|captured statement}1'
HD7DB9752FAAD: '__block变量%0不能被捕获到%select{lambda表达式|被捕获的语句}1中'
# '__builtin_btf_type_id argument %0 not a constant'
H48F1BECDC866: '__builtin_btf_type_id参数%0不是常量'
# '__builtin_longjmp is not supported for the current target'
H53A6EFDFCD17: '__builtin_longjmp不支持当前目标平台'
# "__builtin_mul_overflow does not support 'signed _BitInt' operands of more than %0 bits"
H24B9AB05270A: "__builtin_mul_overflow不支持超过%0位的'signed _BitInt'操作数"
# '__builtin_preserve_enum_value argument %0 invalid'
H341194DCABD7: '__builtin_preserve_enum_value参数%0无效'
# '__builtin_preserve_enum_value argument %0 not a constant'
HCADD1D27CE0B: '__builtin_preserve_enum_value参数%0不是常量'
# '__builtin_preserve_field_info argument %0 not a constant'
HA3DE67421A5E: '__builtin_preserve_field_info参数%0不是常量'
# '__builtin_preserve_field_info argument %0 not a field access'
H153927D1D427: '__builtin_preserve_field_info参数%0不是一个字段访问'
# '__builtin_preserve_type_info argument %0 invalid'
H92B5B29F2F9A: '__builtin_preserve_type_info参数%0无效'
# '__builtin_preserve_type_info argument %0 not a constant'
H57FE08B33075: '__builtin_preserve_type_info参数%0不是常量'
# '__builtin_setjmp is not supported for the current target'
H08E9B75B93D5: '__builtin_setjmp不支持当前目标平台'
# '__constant__, __device__, and __managed__ are not allowed on non-static local variables'
H4A2DC7998EB3: '不允许在非静态局部变量上使用__constant__、__device__和__managed__'
# '__declspec attribute %0 is not supported'
H4B7BDD3DADC0: '__declspec属性%0不受支持'
# '__declspec attributes must be an identifier or string literal'
HBBCBBEE3784E: '__declspec属性必须是标识符或字符串字面量'
# '__final is a GNU extension, consider using C++11 final'
H9019DE700CF0: '__final是GNU扩展，建议使用C++11的final'
# '__grid_constant__ is only allowed on const-qualified kernel parameters'
HDE081328BF07: '__grid_constant__仅允许在const限定的内核参数上使用'
# '__has_warning expected option name (e.g. "-Wundef")'
H96068DA3D4D1: '__has_warning期望选项名称（例如“-Wundef”）'
# '__shared__ local variables not allowed in %select{__device__|__global__|__host__|__host__ __device__}0 functions'
H0BA8A02BD0B3: '__shared__ 局部变量不允许在 %select{__device__|__global__|__host__|__host__ __device__}0 函数中使用'
# "__shared__ variable %0 cannot be 'extern'"
H76DC43AF246B: "__shared__ 变量 %0 不能是 'extern'"
# '__sync builtin operation must have natural alignment (consider using __atomic)'
HFAE067F4A98D: '__sync 内置操作必须具有自然对齐（考虑使用 __atomic）'
# '__weak attribute cannot be specified on a field declaration'
HAD92983EAEB2: '__weak 属性不能指定在字段声明上'
# '__weak attribute cannot be specified on an automatic variable when ARC is not enabled'
HC15AE9021482: '__weak 属性在未启用 ARC 时不能指定在自动变量上'
# '`#pragma const_seg` for section %1 will not apply to %0 due to the presence of a %select{mutable field||non-trivial constructor|non-trivial destructor}2'
H8811D5F6122A: "'#pragma const_seg'为%1节将不适用于%0，因为存在%select{可变字段||非平凡构造函数|非平凡析构函数}2"
# 'a %select{function|block}0 declaration without a prototype is deprecated %select{in all versions of C|}0'
HA427D7F1B8D9: '没有原型的 %select{函数|块}0 声明在所有 C 版本中已弃用 %select{ | 和在 C23 中不受支持}0'
# "a %select{pack indexing|'decltype'}0 specifier cannot be used in a declarative nested name specifier"
H505B17716528: '无法在声明式嵌套名称限定符中使用 %select{打包索引|decltype}0 规范符'
# 'a concept definition cannot refer to itself'
H3304727AB46C: '概念定义不能引用自身'
# 'a constant expression cannot modify an object that is visible outside that expression'
H91A285505D66: '常量表达式不能修改在该表达式外部可见的对象'
# 'a declarative nested name specifier cannot name an alias template'
H09803710CDAC: '声明式嵌套名称限定符不能命名别名模板'
# 'a firstprivate variable with incomplete type %0'
H893794AB5FB9: '具有不完整类型的 firstprivate 变量 %0'
# 'a friend declaration that befriends a template must contain exactly one type-specifier'
HDEE648B4A187: '友元声明若要 befriending 模板必须恰好包含一个类型说明符'
# 'a function %select{declaration|definition}0 without a prototype is deprecated in all versions of C %select{and is not supported in C23|and is treated as a zero-parameter prototype in C23, conflicting with a %select{previous|subsequent}2 %select{declaration|definition}3}1'
HB3E1938E8933: '没有原型的函数 %select{声明|定义}0 在所有 C 版本中已弃用 %select{ | 并在 C23 中被视为零参数原型}1，这会与 %select{之前的|后续的}2 %select{声明|定义}3 冲突'
# 'a function type is not allowed here'
HE650A35390C3: '此处不允许使用函数类型'
# 'a getter method is needed to perform a compound assignment on a property'
HEDE5FCF91532: '执行属性的复合赋值需要 getter 方法'
# 'a lambda expression cannot appear in this context'
H979A7AF92A65: 'lambda 表达式在此上下文中不允许'
# 'a lambda expression may not appear inside of a constant expression'
HB0755DD5F929: 'lambda 表达式不能出现在常量表达式内部'
# 'a lambda parameter cannot shadow an explicitly captured entity'
H65FE428CB516: 'lambda 参数不能隐藏显式捕获的实体'
# 'a lambda with an explicit object parameter cannot be mutable'
HF1252DDC6E4B: '具有显式对象参数的 lambda 不能是 mutable'
# 'a lastprivate variable with incomplete type %0'
H8324467E21DA: '类型不完整的lastprivate变量%0'
# 'a linear variable with incomplete type %0'
HE61951ED0B99: '类型不完整的线性变量%0'
# 'a module can only be re-exported as another top-level module'
H272C723A8726: '模块只能作为另一个顶层模块重新导出'
# 'a non-type template parameter cannot have type %0'
H4D4081CB8796: '非类型模板参数不能具有类型%0'
# 'a non-type template parameter cannot have type %0 before C++20'
HEEE0AA3066FD: '在C++20之前，非类型模板参数不能具有类型%0'
# 'a parameter list without types is only allowed in a function definition'
H52BB0DED62AC: '不带类型的参数列表仅允许在函数定义中使用'
# 'a parameter pack may not be accessed at an out of bounds index'
H3E85B76262B3: '参数包不能在越界索引处被访问'
# 'a private variable with incomplete type %0'
H0A7C86E8874A: '类型不完整的私有变量%0'
# 'a randomized struct can only be initialized with a designated initializer'
H4615845B3A9F: '随机化结构体只能使用指定初始化器进行初始化'
# 'a reduction list item with incomplete type %0'
H06AA7BC953CB: '类型不完整的规约列表项%0'
# 'a requires expression cannot have an explicit object parameter'
H86B74E3E67C6: 'requires表达式不能包含显式对象参数'
# 'a requires expression must contain at least one requirement'
HA35998709F70: 'requires表达式必须包含至少一个约束条件'
# "a space is required between a right angle bracket and an equals sign (use '> =')"
H9BFA1E21C4F4: '右尖括号和等号之间需要空格（使用"> =")'
# "a space is required between consecutive right angle brackets (use '> >')"
H529B67153B9E: '连续的右尖括号之间需要空格（使用"> >")'
# 'a static lambda cannot have any captures'
H2E5388A18076: '静态lambda不能有任何捕获'
# 'a static_assert declaration cannot be a template'
HA1124669302F: 'static_assert声明不能是模板'
# 'a template argument list is expected after a name prefixed by the template keyword'
HF4A21ADFAB4E: '模板关键字前缀的名称后面需要跟随模板参数列表'
# 'a type named %0 is hidden by a declaration in a different namespace'
H26CC1C864C4C: '名称%0的类型被其他命名空间的声明所隐藏'
# 'a type specifier is required for all declarations'
HA2239D7DA67E: '所有声明都需要指定类型说明符'
# 'a typedef cannot be a template'
H878607247E5C: 'typedef不能是模板'
# 'absolute value function %0 given an argument of type %1 but has parameter of type %2 which may cause truncation of value'
H2B4AC1EEC989: '绝对值函数%0 的参数类型为%2，但传入的实参类型为%1，可能导致数值被截断'
# "abstract class is marked '%select{final|sealed}0'"
H9546D737D23E: "抽象类被标记为'%select{final|sealed}0'"
# 'access declarations are deprecated; use using declarations instead'
H3431BA5113E5: '访问声明已弃用；请改用using声明'
# 'access qualifier %0 cannot be used for %1 %select{|prior to OpenCL C version 2.0 or in version 3.0 and without __opencl_c_read_write_images feature}2'
HC43552CB1BAC: '访问限定符%0不能用于%1 %select{|prior to OpenCL C version 2.0 or in version 3.0 and without __opencl_c_read_write_images feature}2'
# 'access qualifier can only be used for pipe and image type'
HCF9598AD42BA: '访问限定符只能用于管道和图像类型'
# 'access specifier can only have annotation attributes'
H00A8BDFCED49: '访问说明符只能具有注解属性'
# 'access specifiers are a clang HLSL extension'
H23D01BBD184F: '访问说明符是clang的HLSL扩展'
# 'accessing a member of an atomic structure or union is undefined behavior'
H1C0790EC0EC6: '访问原子结构或联合的成员属于未定义行为'
# 'accessing inaccessible direct base %0 of %1 is a Microsoft extension'
H76AFA5796E64: '访问%1 的不可访问直接基类%0 是Microsoft的扩展'
# "acquiring %0 '%1' requires negative capability '%2'"
HC095E2CF1B84: "获取%0 '%1' 需要负面能力'%2'"
# "acquiring %0 '%1' that is already held"
H4DA573668147: "尝试获取已持有的%0 '%1'"
# 'action %0 not compiled in'
HA82E8BAC3ED2: '未编译动作%0'
# "active '%0' clause defined here"
H5264E053D9D8: "此处定义了活动'%0'子句"
# 'add \'__arm_preserves("za")\' to the callee if it preserves ZA'
HD939B5A83F36: '如果被调用函数保留ZA寄存器，请添加\'__arm_preserves("za")\''
# "add 'constexpr'"
H48500D7C1CF8: "添加'constexpr'"
# "add 'export' here if this is intended to be a module interface unit"
H8499B2C3202C: "如果这是模块接口单元，请在此添加'export'"
# "add 'module;' to the start of the file to introduce a global module fragment"
H1399A9153C66: "在文件开头添加'module;'以引入全局模块片段"
# "add 'typename' to treat this using declaration as a type"
H2514B140BEE5: "添加'typename'以将此using声明视为类型"
# "add 'u8' prefix to form a 'char8_t' string literal"
H8C73CF0B8333: "添加'u8'前缀以形成char8_t字符串字面量"
# "add 'void' to the parameter list to turn an old-style K&R function declaration into a prototype"
H460C61046151: "在参数列表中添加'void'将旧式K&R函数声明转换为原型"
# "add a '@synthesize' directive"
H11A117C94448: "添加 '@synthesize' 指令"
# 'add a deduction guide to suppress this warning'
H4B93D4018373: '添加一个推导指引以抑制此警告'
# 'add a deprecation attribute to the declaration to silence this warning'
HE29FCC14DCE0: '在声明中添加弃用属性以消除此警告'
# 'add a pair of parentheses to declare a variable'
H9B65CA134C28: '添加一对括号以声明变量'
# 'add a super class to fix this problem'
HD3A4A44147E8: '添加一个父类以修复此问题'
# 'add a variable name to declare a %0 initialized with %1'
HBF079F80BA92: '添加一个变量名以声明用 %1 初始化的 %0'
# "add an explicit capture of 'this' to capture '*this' by reference"
H44758706CE87: "添加对 'this' 的显式捕获以通过引用捕获 '*this'"
# 'add an explicit instantiation declaration to suppress this warning if %q0 is explicitly instantiated in another translation unit'
HA69020D4B8A0: '如果 %q0 在另一个翻译单元中显式实例化，则添加显式实例化声明以抑制此警告'
# 'add enclosing parentheses to perform a function-style cast'
H3C4C77285B3F: '添加外围括号以执行函数式类型转换'
# 'add explicit braces to avoid dangling else'
H912E67080844: '添加显式的大括号以避免悬垂 else'
# "add parentheses after the '!' to evaluate the %select{comparison|bitwise operator}0 first"
H7D8E708D64E0: '在 "!" 后添加括号以先计算 %select{比较运算符|位运算符}0'
# 'add parentheses around left hand side expression to silence this warning'
HB1B6850C2A11: '在左侧表达式周围添加括号以消除此警告'
# "add the %select{'require_constant_initialization' attribute|'constinit' specifier}0 to the initializing declaration here"
HFE1D4C8144BF: '在此初始化声明处添加 %select{ "require_constant_initialization" 属性|"constinit" 标识符}0'
# 'adding %0 to %1 might cause circular dependency in container'
H157957572465: '将 %0 添加到 %1 可能会在容器中引发循环依赖'
# 'adding %0 to a string does not append to the string'
H98175222693E: '将 %0 添加到字符串不会追加字符串'
# 'adding %0 to a string pointer does not append to the string'
HE53429791B46: '将 %0 添加到字符串指针不会追加字符串'
# 'addition of default argument on redeclaration makes this constructor a %select{default|copy|move}0 constructor'
H540EC7EBFA01: '重新声明中添加默认参数会使此构造函数成为 %select{默认|拷贝|移动}0 构造函数'
# 'address argument to atomic builtin cannot be const-qualified (%0 invalid)'
H05DD72B70C0D: '原子内置函数的地址参数不能是 const 限定的 (%0 无效)'
# 'address argument to atomic builtin must be a pointer %select{|to a non-zero-sized object }1(%0 invalid)'
H25FC8322E786: '原子内置函数的地址参数必须是 %select{指向非零大小对象的|}1指针 (%0 无效)'
# 'address argument to atomic builtin must be a pointer to 1,2,4,8 or 16 byte type (%0 invalid)'
H8F0926664FBC: '原子内置函数的地址参数必须是指向 1、2、4、8 或 16 字节类型的指针 (%0 无效)'
# 'address argument to atomic builtin must be a pointer to integer or pointer (%0 invalid)'
H05518FC9E223: '原子内置函数的地址参数必须是指向整型或指针的指针（%0 无效）'
# 'address argument to atomic builtin must be a pointer to integer, floating-point or pointer (%0 invalid)'
H4BE1CF542714: '原子内置函数的地址参数必须是指向整型、浮点型或指针的指针（%0 无效）'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer (%1 invalid)'
H45F0D7833F1F: '原子操作的地址参数必须是指向%select{|原子 }0整型的指针（%1 无效）'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer or pointer (%1 invalid)'
HD792403A7931: '原子操作的地址参数必须是指向%select{|原子 }0整型或指针的指针（%1 无效）'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer or supported floating point type (%1 invalid)'
H645D002EEC1B: '原子操作的地址参数必须是指向%select{|原子 }0整型或受支持的浮点类型的指针（%1 无效）'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer, pointer or supported floating point type (%1 invalid)'
HF8B6B0144FE9: '原子操作的地址参数必须是指向%select{|原子 }0整型、指针或受支持的浮点类型的指针（%1 无效）'
# 'address argument to atomic operation must be a pointer to _Atomic type (%0 invalid)'
HED971913A5AB: '原子操作的地址参数必须是指向_Atomic类型的指针（%0 无效）'
# 'address argument to atomic operation must be a pointer to a trivially-copyable type (%0 invalid)'
H0F2B276FBFF5: '原子操作的地址参数必须是指向平凡可复制类型的指针（%0 无效）'
# 'address argument to atomic operation must be a pointer to non-%select{const|constant}0 _Atomic type (%1 invalid)'
H77D9C30AD097: '原子操作的地址参数必须是指向非%select{const|constant}0 _Atomic类型的指针（%1 无效）'
# 'address argument to atomic operation must be a pointer to non-const type (%0 invalid)'
HA961ACF648B8: '地址参数必须是指向非const类型的指针（%0 无效）'
# 'address argument to load or store exclusive builtin must be a pointer to 1,2,4 or 8 byte type (%0 invalid)'
H7473631C7DCE: '加载或存储内置函数的地址参数必须是指向1、2、4或8字节类型的指针（%0 无效）'
# 'address argument to nontemporal builtin must be a pointer (%0 invalid)'
H15C0E2A98779: '非临时性内置函数的地址参数必须是指向指针（%0 无效）'
# 'address argument to nontemporal builtin must be a pointer to integer, float, pointer, or a vector of such types (%0 invalid)'
H411242986562: '非临时性内置函数的地址参数必须是指向整型、浮点型、指针或此类类型的向量的指针（%0 无效）'
# 'address non-type template argument cannot be surrounded by parentheses'
HE4169B7F3BE1: '地址非类型模板实参不能被括号包围'
# "address of %select{'%1'|function '%1'|array '%1'|lambda function pointer conversion operator}0 will always evaluate to 'true'"
H17F3EBE2635E: "%select{'%1'函数|函数'%1'|数组'%1'|lambda函数指针转换运算符}0的地址始终会评估为'true'"
# 'address of %select{bit-field|vector element|property expression|register variable|matrix element}0 requested'
HD8B1334D046A: '请求了%select{位段|向量元素|属性表达式|寄存器变量|矩阵元素}0的地址'
# "address of non-static constexpr variable %0 may differ on each invocation of the enclosing function; add 'static' to give it a constant address"
HE51DD27041F6: "非静态constexpr变量%0的地址在每次调用包含函数时可能不同；添加'static'使其具有常量地址"
# 'address of overloaded function %0 cannot be cast to type %1'
H358904EBF6FD: '重载函数%0的地址不能被转换为类型%1'
# 'address of overloaded function %0 cannot be converted to type %1'
HCCA08BC04209: '重载函数%0的地址无法转换为类型%1'
# 'address of overloaded function %0 cannot be static_cast to type %1'
HE4591559B0BB: '重载函数%0的地址不能被static_cast转换为类型%1'
# 'address of overloaded function %0 does not match required type %1'
H11264D1F1C79: '重载函数%0的地址与所需类型%1不匹配'
# 'address of overloaded function %0 is ambiguous'
H33C49268724E: '重载函数%0的地址存在歧义'
# 'address space is larger than the maximum supported (%0)'
HFA6456E815BE: '地址空间大于最大支持值（%0）'
# 'address space is negative'
H7DA3DAA44B98: '地址空间为负数'
# 'address taken in non-type template argument for template parameter of reference type %0'
HD465BC48688F: '引用类型模板参数%0的非常量模板实参中获取了地址'
# 'address-of operator cannot be applied to a call to a function with unknown return type'
HA9D761CAF77E: '无法对返回类型未知的函数调用应用地址取用运算符（address-of operator）'
# "after modifying system headers, please delete the module cache at '%0'"
H01FFB29D96B3: "修改系统头文件后，请删除位于'%0'的模块缓存"
# 'aggregate initialization of type %0 from a parenthesized list of values is a C++20 extension'
H6B5CF381E65A: '使用带括号的值列表对类型%0进行聚合初始化是C++20扩展'
# 'aggregate initialization of type %0 with user-declared constructors is incompatible with C++20'
HC24621DDDD5F: '具有用户声明构造函数的类型%0的聚合初始化与C++20不兼容'
# 'alias declaration cannot be a pack expansion'
H7E12EB8475DC: '别名声明不能是模板参数包扩展'
# 'alias declaration in this context is a C++23 extension'
H91EDBE36B117: '此上下文中的别名声明是C++23扩展'
# 'alias declaration in this context is incompatible with C++ standards before C++23'
HC4280923DB99: '此上下文中的别名声明与C++23之前的语言标准不兼容'
# 'alias declarations are a C++11 extension'
HE9649A76CF28: '别名声明是C++11扩展'
# 'alias declarations are incompatible with C++98'
H47305448BB21: '别名声明与C++98标准不兼容'
# 'alias definition of %0 after tentative definition'
HBC2E292F4F78: '在尝试定义之后对%0进行别名声明'
# 'alias to a variable in a common section is not allowed'
H93F6002973E0: '不允许引用常见段中的变量的别名'
# 'aliases are not supported on darwin'
H41CBE942EE33: 'Darwin系统不支持别名'
# "aligned %select{allocation|deallocation}0 function of type '%1' is %select{only|not}4 available on %2%select{ %3 or newer|}4"
H9703DDF7875E: '类型为%1的对齐%select{分配|释放}0函数在%2%select{ %3或更高版本|}4%select{仅|不}4可用'
# 'aligned clause will be ignored because the requested alignment is not a power of 2'
HC3A503B9038C: '将忽略对齐子句，因为请求的对齐值不是2的幂次'
# 'alignment (%0) of thread-local variable %1 is greater than the maximum supported alignment (%2) for a thread-local variable on this target'
H9951DC0F93CA: '目标平台上线程局部变量的最大支持对齐值为%2，但线程局部变量%1的对齐值(%0)超过了该限制'
# "alignment is not a power of 2 in '%0'"
HB7B2FF437212: "在'%0'中对齐值不是2的幂次"
# 'alignment of 16 bytes for a struct member is not binary compatible with IBM XL C/C++ for AIX 16.1.0 or older'
H79A5A88D17D7: '结构体成员的16字节对齐方式与AIX 16.1.0或更早版本的IBM XL C/C++不兼容'
# 'alignof expressions are incompatible with C++98'
H5F21C338A420: 'alignof表达式与C++98不兼容'
# 'all paths through this function will call itself'
H40E0BDFB048F: '通过此函数的所有路径都将调用自身'
# "allocate directive specifies %select{default|'%1'}0 allocator while previously used %select{default|'%3'}2"
HC639234B285B: "分配指令指定了%select{默认|'%1'}0分配器，而之前使用了%select{默认|'%3'}2"
# 'allocated size %0 is not a multiple of size %1 of element type %2'
H279696362CDE: '分配的大小%0不是元素类型%2大小%1的倍数'
# "allocated with 'new%select{[]|}0' here"
H1AA44259E5AA: "此处使用'new%select{[]|}0'分配"
# 'allocating an object of abstract class type %0'
H07CDBA71F9A5: '尝试分配抽象类类型%0的对象'
# 'allocation of %select{incomplete|sizeless}0 type %1'
HD40A80B2E772: '分配了%select{不完整|无大小}0类型%1'
# 'allocation performed here was not deallocated%plural{0:|: (along with %0 other memory leak%s0)}0'
H04A2F923450C: '此处分配的内存未被释放%plural{0:|:（以及 %0 其他内存泄漏%s0）}0'
# "allocator must be specified in the 'uses_allocators' clause"
H6A6EDC2E2834: "必须在'uses_allocators'子句中指定分配器"
# "allocator with the 'thread' trait access has unspecified behavior on '%0' directive"
HDC686C65C1AA: "'%0'指令具有'thread'特性时分配器行为未定义"
# "allocators used in 'uses_allocators' clause cannot appear in other data-sharing or data-mapping attribute clauses"
H3D9F65EE1204: "'uses_allocators'子句中使用的分配器不能出现在其他数据共享或数据映射属性子句中"
# "allowable client missing from %0: '%1'"
H1792F22F4481: "%0中缺少允许的客户端：'%1'"
# "allowable clients do not match: '%0' (provided) vs '%1' (found)"
H73C7C1046F8D: "允许的客户端不匹配：'%0'（提供）与'%1'（找到）"
# "already inside '#pragma clang arc_cf_code_audited'"
H490BE327E34C: "已在'#pragma clang arc_cf_code_audited'作用域内"
# "already inside '#pragma clang assume_nonnull'"
H59F0A861C85D: "已在'#pragma clang assume_nonnull'作用域内"
# "already inside '#pragma unsafe_buffer_usage'"
H94EE60235FE3: "已在'#pragma unsafe_buffer_usage'作用域内"
# 'also accessed here'
H4EBEB7641C26: '此处也被访问'
# 'also found'
HAE6F7F952B68: '也找到'
# 'always_inline function %0 has new za state'
H42D69F5E4613: 'always_inline 函数 %0 有了新的 za 状态'
# 'always_inline function %0 has new zt0 state'
HC0C33866F167: 'always_inline 函数 %0 有了新的 zt0 状态'
# 'always_inline function %1 and its caller %0 have mismatching %2 attributes'
H623539F9CF4D: 'always_inline 函数 %1 及其调用者 %0 的 %2 属性不匹配'
# 'always_inline function %1 and its caller %0 have mismatching %2 attributes, inlining may change runtime behaviour'
H784367C8E6F8: 'always_inline 函数 %1 及其调用者 %0 的 %2 属性不匹配，内联可能导致运行时行为变化'
# "always_inline function %1 requires target feature '%2', but would be inlined into function %0 that is compiled without support for '%2'"
H6E58755C709F: "always_inline 函数 %1 需要目标特性 '%2'，但会被内联到未支持 '%2' 的函数 %0 中"
# 'ambiguity is between a regular call to this operator and a call with the argument order reversed'
H5C4216FCB55D: '歧义存在于对该运算符的常规调用和参数顺序颠倒的调用之间'
# 'ambiguous candidate function with reversed arguments'
H1A80B7778D2B: '具有反转参数的歧义候选函数'
# 'ambiguous cast from base %0 to derived %1:%2'
H7F294DF4B6DC: '从基类 %0 到派生类 %1 的强制转换存在歧义：%2'
# 'ambiguous constructor call when %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1'
H33854A224B06: '在%select{复制变量|复制参数|初始化模板参数|返回对象|初始化语句表达式结果|抛出对象|复制成员子对象|复制数组元素|分配对象|复制临时对象|初始化基类子对象|初始化向量元素|捕获值}0类型 %1 的情况下，构造函数调用存在歧义'
# 'ambiguous conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2'
H1B069BDA73DD: '从 %1 到 %2 的 %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 转换存在歧义'
# 'ambiguous conversion from derived class %0 to base class %1:%2'
H64259C430314: '从派生类 %0 到基类 %1 的强制转换存在歧义：%2'
# 'ambiguous conversion from pointer to member of %select{base|derived}0 class %1 to pointer to member of %select{derived|base}0 class %2:%3'
H3B96453BA992: '从%select{基|派生}0类 %1 的成员指针到%select{派生|基}0类 %2 的成员指针的强制转换存在歧义：%3'
# 'ambiguous conversion from type %0 to an integral or unscoped enumeration type'
H78D40490F0F2: '将类型 %0 转换为整数类型或未命名枚举类型的强制转换存在歧义'
# 'ambiguous conversion of array size expression of type %0 to an integral or enumeration type'
H568A4E6CFAC2: '数组大小表达式类型 %0 转换为整数或枚举类型的强制转换存在歧义'
# 'ambiguous conversion of delete expression of type %0 to a pointer'
HCF8DE9DD6D85: 'delete 表达式类型 %0 转换为指针的强制转换存在歧义'
# 'ambiguous deduction for template arguments of %0'
HE14C8899D7D7: '对 %0 的模板参数推导存在歧义'
# 'ambiguous expansion of macro %0'
H401A5AED8233: '宏 %0 的展开存在歧义'
# "ambiguous marker '%0' is defined here"
HF269BA6422ED: "歧义标记 '%0' 是在这里定义的"
# 'ambiguous member function specialization %q0 of %q1'
H6A3405722F76: '%q1 的成员函数特化 %q0 存在歧义'
# 'ambiguous partial specializations of %0'
HDEE2005B7D3C: '%0 的部分特化存在歧义'
# "ambiguous reference to placeholder '_', which is defined multiple times"
HBD26597B24D2: "对占位符 '_' 的引用存在歧义，该占位符被多次定义"
# 'ambiguous use of internal linkage declaration %0 defined in multiple modules'
HE31133550012: '在多个模块中定义的内部链接声明 %0 使用存在歧义'
# 'ambiguous vftable component for %0 introduced via covariant thunks; this is an inherent limitation of the ABI'
HB0361B37BEF3: '通过协变跳转引入的 %0 的虚函数表组件存在歧义；这是ABI的固有局限性'
# 'an array type is not allowed here'
HCA0201F3FA96: '此处不允许数组类型'
# 'an attribute list cannot appear here'
H49F3FA1B7ED5: '此处不能出现属性列表'
# 'an attribute specifier sequence attached to a structured binding declaration is a C++2c extension'
H9EBA62889A30: '附加到结构化绑定声明的属性说明符序列是C++2c扩展'
# 'an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c'
H3AB5357520EE: '附加到结构化绑定声明的属性说明符序列与C++2c之前的C++标准不兼容'
# 'an explicit object parameter can only appear as the first parameter of a member function'
HB251EBFE2CF5: '显式对象参数只能作为成员函数的第一个参数出现'
# 'an explicit object parameter can only appear as the first parameter of the %select{function|lambda}0'
H7FA58E3ABF3F: '显式对象参数只能作为%select{函数|lambda}0的第一个参数出现'
# 'an explicit object parameter cannot appear in a %select{constructor|destructor}0'
H75A07B3C23F5: '显式对象参数不能出现在%select{构造函数|析构函数}0中'
# 'an explicit object parameter cannot appear in a %select{static|virtual|non-member}0 %select{function|lambda}1'
HF679F4DDA00F: '显式对象参数不能出现在%select{静态|虚|非成员}0 %select{函数|lambda}1中'
# "an explicitly-defaulted %select{copy|move}0 assignment operator may not have 'const'%select{, 'constexpr'|}1 or 'volatile' qualifiers"
HC61798127DDC: "显式默认的%select{复制|移动}0赋值运算符不能带有'const'%select{, 'constexpr'|}1或'volatile'限定符"
# 'an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be variadic'
HE8693CE23671: '显式默认的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0不能是可变参数'
# 'an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot have default arguments'
H41B0D6AF186A: '显式默认的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0不能有默认参数'
# 'an initializer for a delegating constructor must appear alone'
H5506BF1F155E: '委托构造函数的初始化器必须单独出现'
# 'an inline asm block cannot have an operand which is a bit-field'
HD4AB7ACF49E9: '内联汇编块不能有位字段操作数'
# 'an unevaluated string literal cannot be a user-defined literal'
H7294D821E112: '未求值的字符串字面量不能是用户自定义字面量'
# 'an unevaluated string literal cannot have an encoding prefix'
HFC8ECFF25368: '未求值的字符串字面量不能带有编码前缀'
# "analyzer constraint manager 'z3' is only available if LLVM was built with -DLLVM_ENABLE_Z3_SOLVER=ON"
H156EC948497C: "分析器约束管理器'z3'仅当LLVM用-DLLVM_ENABLE_Z3_SOLVER=ON编译时可用"
# "analyzer-config option '%0' has a key but no value"
H5FB74FAA9043: "分析器配置选项'%0'有键但无值"
# "analyzer-config option '%0' should contain only one '='"
HC4A2A9D28ED1: "'analyzer-config'选项 '%0' 应该只包含一个'='"
# 'angle brackets contain both a %select{type|protocol}0 (%1) and a %select{protocol|type}0 (%2)'
H6C951E1E776A: '尖括号同时包含了一个%select{类型|协议}0（%1）和一个%select{协议|类型}0（%2）'
# 'angle-bracketed include <%0> cannot be aliased to double-quoted include "%1"'
H6DC7B4C3CA94: '尖括号包含的头文件<%0>不能被别名为双引号包含的头文件“%1”'
# 'annotate %select{%1|anonymous %1}0 with an availability attribute to silence this warning'
H1B283AC48C5C: '为%select{%1|匿名%1}0添加一个可用性属性以消除此警告'
# "annotating the 'if %select{constexpr|consteval}0' statement here"
HE2CC6E318B60: "在此处注释'if %select{constexpr|consteval}0'语句"
# 'annotating the infinite loop here'
H4CC614D1531D: '在此处注释无限循环'
# 'anonymous %select{structs|structs and classes}0 must be %select{struct or union|class}0 members'
HFBD532892EC0: '匿名%select{结构体|结构体和类}0必须是%select{结构体或联合|类}0成员'
# 'anonymous %select{structs|unions}0 are a Microsoft extension'
HFF401250AB40: '匿名%select{结构体|联合}0是Microsoft扩展'
# 'anonymous %select{struct|union}0 can only contain non-static data members'
H31B46249C247: '匿名%select{结构体|联合}0只能包含非静态数据成员'
# "anonymous %select{struct|union}0 cannot be '%1'"
HF58A2EC09112: "匿名%select{结构体|联合}0不能是'%1'"
# 'anonymous %select{struct|union}0 cannot contain a %select{private|protected}1 data member'
HA1E08BDB3E65: '匿名%select{结构体|联合}0不能包含%select{私有|受保护}1数据成员'
# 'anonymous bit-field cannot have a default member initializer'
H71090C776F50: '匿名位字段不能有默认成员初始化器'
# 'anonymous bit-field cannot have qualifiers'
H6D3AB87CE804: '匿名位字段不能有限定符'
# 'anonymous bit-field has negative width (%0)'
HFC2DC27C32DA: '匿名位字段具有负宽度（%0）'
# 'anonymous bit-field has non-integral type %0'
HCAEF6F6FBF6D: '匿名位字段具有非整数类型%0'
# 'anonymous namespace begins here'
H131F22F8B917: '匿名命名空间在此处开始'
# 'anonymous namespaces cannot be exported'
HD9CECEFAA4C6: '匿名命名空间无法被导出'
# 'anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition'
H4E07DEF6B927: '匿名的非C兼容类型通过%select{typedef|alias}0声明为链接目的命名；在定义之前添加一个标签名此处以建立链接'
# 'anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration; add a tag name here'
H5233EEEB5041: '匿名的非C兼容类型通过%select{typedef|alias}0声明为链接目的命名；此处添加一个标签名'
# 'anonymous property is not supported'
HBEA1F99304A4: '匿名属性不受支持'
# 'anonymous structs are a C11 extension'
H1E3F733CCCB4: '匿名结构体是C11的扩展'
# 'anonymous structs are a GNU extension'
H006E53420443: '匿名结构体是GNU扩展'
# 'anonymous types declared in an anonymous %select{struct|union}0 are an extension'
H3F386C85263B: '匿名%select{结构体|联合}0中的匿名类型是扩展功能'
# 'anonymous union at class scope must not have a storage specifier'
H7518631D05B0: '类作用域中的匿名联合不能有存储说明符'
# 'anonymous unions are a C11 extension'
HDFE9E6E6FE09: '匿名联合是C11的扩展'
# "anonymous unions at namespace or global scope must be declared 'static'"
H3FE1C37A16FD: "命名空间或全局作用域中的匿名联合必须声明为'static'"
# "application of '%select{alignof|sizeof}1' to interface %0 is not supported on this architecture and platform"
H7F7758BA5771: "对接口%0应用'%select{alignof|sizeof}1'在此架构和平台上不受支持"
# 'applying attribute %0 to a declaration is deprecated; apply it to the type instead'
H1F568760A093: '将属性%0应用于声明已被弃用；请将其应用于类型'
# "architecture '%0' does not support '%1' execution mode"
H341F2DD78603: "架构'%0'不支持'%1'执行模式"
# "architectures do not match: '%0' (provided) vs '%1' (found)"
H1E0CF63FB0D6: "架构不匹配：'%0'（指定）与'%1'（检测到）"
# 'argument %0 is not an unqualified class type'
H5DB23C0A38DF: '参数%0不是未限定的类类型'
# 'argument %0 must be constant integer 1 or -1'
H4812A4DC04E0: '参数%0必须是常量整数1或-1'
# 'argument %0 of type %1 with mismatched bound'
HDE368B7DDAF1: '类型%1的参数%0具有不匹配的边界'
# 'argument %0 to %1 must be a 2-bit unsigned literal (i.e. 0, 1, 2 or 3)'
HD2DEDD810BB8: '传递给%1的参数%0必须是2位无符号字面量（即0、1、2或3）'
# "argument %0 to 'preferred_name' attribute is not a typedef for a specialization of %1"
H873B3444BA19: "'preferred_name'属性的参数%0不是%1的特化类型的typedef"
# 'argument %0 value should represent a contiguous bit field'
H004B84FF9E91: '参数%0的值应表示连续的位字段'
# "argument '%0' is deprecated%select{|, use '%2' instead}1"
H549CE16A2419: '参数‘%0’已弃用%select{|，请改用‘%2’}1'
# "argument '%0' is deprecated, %1"
HFF8BB35E32E8: '参数‘%0’已弃用，%1'
# "argument '%0' requires profile-guided optimization information"
HE99C51820EC7: '参数‘%0’需要基于轮廓的优化信息'
# "argument '%select{X|Y|Z}0' to numthreads attribute cannot exceed %1"
H50D13BA82E10: 'numthreads属性的参数%select{X|Y|Z}0不能超过%1'
# "argument '-Ofast' is deprecated; use '-O3 -ffast-math -fstack-arrays' for the same behavior, or '-O3 -fstack-arrays' to enable only conforming optimizations"
HBBD3AEA705D1: "参数 '-Ofast' 已弃用；请改用 '-O3 -ffast-math -fstack-arrays' 实现相同行为，或使用 '-O3 -fstack-arrays' 仅启用符合标准的优化"
# "argument '-Ofast' is deprecated; use '-O3 -ffast-math' for the same behavior, or '-O3' to enable only conforming optimizations"
H9474F0404E53: "参数 '-Ofast' 已弃用；请改用 '-O3 -ffast-math' 实现相同行为，或使用 '-O3' 仅启用符合标准的优化"
# "argument may not have 'void' type"
HC935448BE70B: "参数不能使用 'void' 类型"
# 'argument must be a function'
H4B920E91F120: '参数必须是函数'
# 'argument must be a string literal%select{| of char type}0'
HE9E2C9450B76: '参数必须是字符串字面量%select{|的char类型}0'
# "argument not in expected state; expected '%0', observed '%1'"
H081944E631B6: "参数不在预期状态；预期 '%0'，实际观察到 '%1'"
# "argument of OpenMP clause '%0' must reference the same object in all threads"
HD18A730DC43E: "OpenMP 子句 '%0' 的参数在所有线程中必须引用同一对象"
# 'argument of a linear clause should be of integral or pointer type, not %0'
HDE23CDEBD40A: '线性子句的参数应为整数类型或指针类型，而非 %0'
# 'argument of a reduction clause of a %0 construct must not appear in a firstprivate clause on a task construct'
HE3DB6952581D: '%0 构造的 reduction 子句的参数不得出现在 task 构造的 firstprivate 子句中'
# 'argument of aligned clause should be array%select{ or pointer|, pointer, reference to array or reference to pointer}1, not %0'
H3A22487A8E2A: 'aligned 子句的参数应为数组%select{或指针|、指针、数组引用或指针引用}1，而非 %0'
# 'argument required after attribute'
HE013B38B3C7C: '属性后需要参数'
# 'argument sensitivity is %select{unspecified|private|public|sensitive}0, but it should be %select{unspecified|private|public|sensitive}1'
H086D890B37E5: '参数敏感性为 %select{未指定|私有|公共|敏感}0，但应为 %select{未指定|私有|公共|敏感}1'
# 'argument should be a multiple of %0'
H17E1DE63FD3F: '参数应为 %0 的倍数'
# 'argument should be a power of 2'
H41CDA1F42637: '参数应为 2 的幂'
# 'argument should be an 8-bit value shifted by a multiple of 8 bits'
H3C662F06BF97: '参数应为向右移动 8 位的 8 位值'
# 'argument should be an 8-bit value shifted by a multiple of 8 bits, or in the form 0x??FF'
H188AFDB4C91E: '参数应为向右移动 8 位的 8 位值，或格式为 0x??FF'
# 'argument should be the value 0, 90, 180 or 270'
H8AAE066502E7: '参数应为 0、90、180 或 270'
# 'argument should be the value 90 or 270'
HE33BB0F80B1B: '参数应为 90 或 270'
# 'argument to #pragma section is not valid for this target: %0'
HC2C201A8E9D6: '#pragma section 的参数对当前目标无效: %0'
# 'argument to %0 must be a constant integer'
H66325C1A3398: '%0 的参数必须是常量整数'
# "argument to %select{'code_seg'|'section'}1 attribute is not valid for this target: %0"
H35898B1EF5C2: "属性 %select{'code_seg'|'section'}1 的参数对当前目标无效： %0"
# "argument to '#pragma unroll' should not be in parentheses in CUDA C/C++"
HBE77A0717D85: "CUDA C/C++ 中 '#pragma unroll' 的参数不应加括号"
# "argument to '%0' clause must be a %select{non-negative|strictly positive}1 integer value"
H93740956E9C9: '%0 子句的参数必须是%select{非负|严格正}1整数值'
# "argument to '%0' is missing (expected %1 value%s1)"
HEA17C0D34C2C: '%0 的参数缺失（应为%1值%s1）'
# "argument to 'gang' clause dimension must be %select{a constant expression|1, 2, or 3: evaluated to %1}0"
H970EFD35B5B1: "'gang' 子句的维度参数必须是%select{常量表达式|1、2或3：计算得到%1}0"
# "argument to 'operator<=>' %select{cannot be narrowed from type %1 to %2|evaluates to %1, which cannot be narrowed to type %2}0"
HAE154D16E74A: 'operator<=> 的参数%select{不能将类型%1转换为更窄的类型%2|计算结果为类型%1，不能转换为更窄的类型%2}0'
# "argument to 'sizeof' in %0 call is the same pointer type %1 as the %select{destination|source}2; expected %3 or an explicit length"
H35BB4F2B1E83: '在%0 调用中的sizeof参数与%select{目标|源}2的指针类型%1相同；期望%3或显式长度'
# 'argument to __builtin_longjmp must be a constant 1'
HE5F0C7B028D7: '__builtin_longjmp 的参数必须是常量1'
# 'argument to __builtin_verbose_trap must %select{be a pointer to a constant string|not contain $}0'
HADE59279CC5F: '__builtin_verbose_trap 的参数必须%select{是指向常量字符串的指针|不包含$}0'
# "argument to atomic builtin of type '_BitInt' is not supported"
HB64B7DD3183B: '_BitInt 类型的原子内置函数参数不受支持'
# 'argument to ptrauth_sign_constant must refer to a global variable or function'
HC3F35A99F4A4: 'ptrauth_sign_constant 的参数必须引用全局变量或函数'
# "argument type %0 doesn't match specified %1 type tag %select{that requires %3|}2"
H3BF4CB740E62: '参数类型%0 与指定的%1类型标签%select{需要%3|}2不匹配'
# 'argument type %0 is incomplete'
HAB2CACB541C5: '参数类型%0 是不完整的'
# 'argument type %0 is not a real floating point type'
H00F62D550C19: '参数类型%0 不是真实的浮点类型'
# "argument unused during compilation: '%0'"
HA1050D6985F0: "编译期间未使用的参数：'%0'"
# 'argument value %0 is outside the valid range [%1, %2]'
HB96DE207738E: '参数值%0 超出有效范围[%1, %2]'
# 'argument value %0 will result in undefined behaviour'
H274A3E69FEAC: '参数值%0 将导致未定义行为'
# 'arguments are of different types%diff{ ($ vs $)|}0,1'
HE1B214C1584C: '参数类型不同%diff{ ($ vs $)|}0,1'
# "arguments of '#pragma omp %0' cannot be of reference type %1"
HF10A8B7C87FB: '#pragma omp %0 的参数不能是引用类型%1'
# "arguments of '#pragma omp %0' must have %select{global storage|static storage duration}1"
H6F3268D97079: '#pragma omp %0 的参数必须具有%select{全局存储|静态存储持续时间}1'
# "arguments of OpenMP clause '%0' for 'min' or 'max' must be of %select{scalar|arithmetic}1 type"
HCCCABB9B57BC: "'min'或'max'的OpenMP子句'%0'的参数必须是%select{标量|算术}1类型"
# "arguments of OpenMP clause '%0' in '#pragma omp %2' directive cannot be of variably-modified type %1"
HCB3B0D762A59: "在'#pragma omp %2'指令中，OpenMP子句'%0'的参数不能是可变修改类型%1"
# "arguments of OpenMP clause '%0' with bitwise operators cannot be of floating type"
H7CE92A7D3184: "带有位运算符的OpenMP子句'%0'的参数不能是浮点类型"
# 'arguments to __annotation must be wide string constants'
H123CD58AB412: '__annotation的参数必须是宽字符串常量'
# "arithmetic involving unrelated objects '%0' and '%1' has unspecified value"
H620CC2CD5C97: "涉及无关对象'%0'和'%1'的算术运算具有未指定的值"
# 'arithmetic on a null pointer treated as a cast from integer to pointer is a GNU extension'
HBFE8701B60FF: '将空指针视为整数到指针转换的算术运算是一个GNU扩展'
# 'arithmetic on a pointer to %select{an incomplete|sizeless}0 type %1'
H81F0120B9A69: '对%select{不完整|无大小}0类型%1的指针进行算术运算'
# 'arithmetic on addresses of potentially overlapping literals has unspecified value'
H84236342B8A2: '对可能重叠的字面量地址进行算术运算具有未指定的值'
# 'arithmetic on pointer to interface %0, which is not a constant size for this architecture and platform'
H9C9B045DAD4E: '对指针进行算术运算，该指针指向接口%0，而该接口在此架构和平台上不是固定大小'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to void'
H58D09A5B5E7F: '对%select{一个|}0 void%select{|s}0指针进行算术运算'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to void is a GNU extension'
HB4BACD25A732: '对%select{一个|}0 void%select{|s}0指针进行算术运算是一个GNU扩展'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2'
H1FD9A476B84E: '对%select{一个|}0指向%select{该|}2函数类型%select{|s}2 %1%select{|和%3}2的%select{|s}0指针进行算术运算'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2 is a GNU extension'
H94DE585BA344: '对%select{一个|}0指向%select{该|}2函数类型%select{|s}2 %1%select{|和%3}2的%select{|s}0指针进行算术运算是一个GNU扩展'
# 'array %0 declared here'
HD94D934376D0: '此处声明的数组%0'
# "array 'new' cannot have initialization arguments"
H5708CAC5AB7B: "数组'new'不能有初始化参数"
# 'array argument is too small; %select{contains %0 elements|is of size %0}2, callee requires at least %1'
H8A66ED6F9EE3: '数组参数太小；%select{包含%0个元素|大小为%0}2，被调用者至少需要%1'
# 'array backing %select{initializer list subobject of the allocated object|the allocated initializer list}0 will be destroyed at the end of the full-expression'
H7FC8ADC3508D: '%select{分配对象的已分配初始化列表|初始化列表子对象}0的数组后端将在完整表达式结束时被销毁'
# 'array bound cannot be deduced from a default member initializer'
H6E170EF5C23C: '无法从默认成员初始化器推导出数组边界'
# 'array designator cannot initialize non-array type %0'
H0BB48B48E929: '数组指定符无法初始化非数组类型%0'
# 'array designator index (%0) exceeds array bounds (%1)'
HF8952A3F237D: '数组指定符索引(%0)超出数组边界(%1)'
# 'array designator range [%0, %1] is empty'
HFAC24EA6FC3D: '数组指定符范围 [%0, %1] 为空'
# "array designator value '%0' is negative"
H02A61A71BE5A: "数组指定符值 '%0' 为负数"
# 'array designators are a C99 extension'
H09604E6E8FF6: '数组指定符是C99的扩展'
# 'array has %select{incomplete|sizeless}0 element type %1'
H513D9739D1E9: '数组的元素类型%1%select{不完整|无大小}0'
# 'array index %0 is before the beginning of the array'
HE66AD6A3EEDD: '数组索引%0在数组的起始位置之前'
# 'array index %0 is past the end of the array (that has type %1%select{|, cast to %3}2)'
HB32CD52AC2F7: '数组索引%0超出数组末尾（该数组类型为%1%select{|，转换为 %3}2）'
# 'array index %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)'
H8C89DC3E13D9: '地址空间%1位中的数组包含%2位（%3字节）元素，索引%0超出最大%4元素%s5'
# 'array initializer must be an initializer list%select{| or string literal| or wide string literal}0'
H4C9486DBC430: '数组初始化器必须是初始化列表%select{|或字符串字面量|或宽字符串字面量}0'
# 'array is too large (%0 elements)'
H898DDC47DE13: '数组过大（包含%0个元素）'
# 'array of %0 type is invalid in OpenCL'
H394630398D52: 'OpenCL中%0类型的数组无效'
# 'array of abstract class type %0'
HD205577BDFE7: '类型为%0的抽象类数组'
# 'array of interface %0 is invalid (probably should be an array of pointers)'
H26CB6BC11BB2: '接口%0的数组无效（可能应为指针数组）'
# 'array parameter is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)'
HF62708756DE6: '数组参数缺少空安全性类型说明符（_Nonnull、_Nullable 或 _Null_unspecified）'
# 'array section %select{lower bound|length}0 is not an integer'
H54C64A3BE980: '数组区间的%select{下界|长度}0不是整数'
# "array section %select{lower bound|length}0 is of type 'char'"
H553F40D88798: '数组区间的%select{下界|长度}0类型为"char"'
# 'array section does not specify contiguous storage'
HD0B03CAA79AA: '数组区间未指定连续存储'
# 'array section does not specify length for outermost dimension'
HDEBFF7152057: '数组区间未指定最外层维度的长度'
# 'array section must be a subset of the original array'
H9DAB88506A15: '数组区间必须是原始数组的子集'
# 'array shaping dimension is evaluated to a non-positive value %0'
H6C186AF92991: '数组成形维度计算结果为非正值%0'
# 'array shaping operation dimension is not an integer'
H521C171EF9F9: '数组成形操作的维度不是整数'
# 'array size expression has incomplete class type %0'
H48253C816CFD: '数组大小表达式具有不完全类类型%0'
# 'array size expression must have integral or %select{|unscoped }0enumeration type, not %1'
H46181D36F61E: '数组大小表达式必须是整型或%select{|未命名 }0枚举类型，而不是%1'
# 'array size expression of type %0 requires explicit conversion to type %1'
H08A74EE986A3: '类型%0的数组大小表达式需要显式转换为类型%1'
# 'array size is negative'
H2357C6CBC81F: '数组大小为负数'
# 'array size must be specified in new expression with no initializer'
HC377DBA39626: '在没有初始化的new表达式中必须指定数组大小'
# 'array subscript is not an integer'
HCA57C5D6E89C: '数组下标不是整数'
# "array subscript is of type 'char'"
HF94CCD2B1ECE: "数组下标是类型'char'"
# 'array type %0 is not assignable'
H89C95FEC605F: '数组类型%0不可赋值'
# 'array types cannot be value-initialized'
HA2673E710254: '数组类型不能进行值初始化'
# 'array-to-pointer decay of array member without known bound is not supported'
HAB3F18D32404: '未知边界的数组成员的数组到指针衰减不受支持'
# "as specified in %select{'collapse'|'ordered'|'collapse' and 'ordered'}0 clause%select{||s}0"
H1ABDD2AD30EB: "如%select{'collapse'|'ordered'|'collapse'和'ordered'}0子句%select{||s}0中所述"
# 'asm constraint has an unexpected number of alternatives: %0 vs %1'
HF38699D505AA: 'asm约束的替代数意外：%0 vs %1'
# 'asm operand has incomplete type %0'
HAA2952BA222F: 'asm操作数具有不完整类型%0'
# 'asm operand name "%0" first referenced here'
H8FB938C946B0: 'asm-specifier的输入或输出变量名“%0”首次引用于此'
# 'asm-specifier for input or output variable conflicts with asm clobber list'
H99E324C19D00: 'asm-specifier与asm销毁列表冲突'
# 'assigning %select{array literal|dictionary literal|numeric literal|boxed expression|<should not happen>|block literal}0 to a weak %select{property|variable}1; object will be released after assignment'
H8FFA1E619C25: '将%select{数组字面量|字典字面量|数字字面量|包装表达式|<不应发生>|块字面量}0赋值给弱%select{属性|变量}1；对象将在赋值后被释放'
# 'assigning %select{field|instance variable}0 to itself'
H9230F521B121: '将%select{字段|实例变量}0赋值给自己'
# 'assigning retained object to %select{weak|unsafe_unretained}0 %select{property|variable}1; object will be released after assignment'
H250CD1E6F903: '将保留对象赋值给%select{弱|unsafe_unretained}0 %select{属性|变量}1；对象将在赋值后被释放'
# 'assigning retained object to unsafe property; object will be released after assignment'
H8135CA913359: '将保留对象赋值给不安全属性；对象将在赋值后被释放'
# "assigning to 'readonly' return result of an Objective-C message not allowed"
H87457323E0B9: '不允许将Objective-C消息的只读返回结果进行赋值'
# 'assigning value of signed enum type %1 to unsigned bit-field %0; negative enumerators of enum %1 will be converted to positive values'
H03B45829D6A4: '将有符号枚举类型%1的值赋给无符号位字段%0；枚举类型%1的负枚举值将被转换为正数'
# 'assignment of a weak-unavailable object to a __weak object'
H270A68B29DDC: '将弱不可用对象赋值给__weak对象'
# "assignment to Objective-C's isa is deprecated in favor of object_setClass()"
H4989286009CB: '对Objective-C的isa赋值已弃用，建议改用object_setClass()'
# 'assignment to cast is illegal, lvalue casts are not supported'
HADC1B6BE18D9: '对强制转换的赋值是非法的，左值强制转换不被支持'
# 'assignment would change active union member during the initialization of a different member of the same union'
HE419D89C08F2: '在联合体的另一个成员初始化期间，赋值会改变该联合体的活动成员'
# 'assumption evaluated to false'
H4B3BD75DFF9D: '假设条件被评估为假'
# 'assumption is ignored because it contains (potential) side-effects'
H2E58C9356572: '因包含（潜在的）副作用，假设条件被忽略'
# 'at least one argument of MTE builtin function must be a pointer (%0, %1 invalid)'
H9293CC0B9621: 'MTE内置函数至少有一个参数必须是指针（%0、%1无效）'
# 'at most one defaultmap clause for each variable-category can appear on the directive'
H95E39CFC8758: '每个变量类别只能出现一个defaultmap子句'
# "at most one overload for a given name may lack the 'overloadable' attribute"
H9206D4731FC1: "给定名称最多有一个重载函数可以不带'overloadable'属性"
# "at most three expressions are allowed in '%0' clause in 'target teams ompx_bare' construct"
HC1194A65DC15: "在'target teams ompx_bare'构造中的'%0'子句最多允许三个表达式"
# 'atomic %select{load|store}0 requires runtime support that is not available for this target'
HD7BAEC48A8AF: '%select{加载|存储}0原子操作需要目标不支持的运行时支持'
# "atomic by default property %0 has a user defined %select{getter|setter}1 (property should be marked 'atomic' if this is intended)"
H5A9A236EC6A5: "默认原子属性%0有用户定义的%select{获取器|设置器}1（若需此行为，请将属性标记为'atomic'）"
# "atomic constraint must be of type 'bool' (found %0)"
H69DAA34C1AB6: '原子约束必须是类型=bool（发现类型%0）'
# 'atomic memory operand must have a power-of-two size'
HB13C6FA40316: '原子内存操作数必须具有2的幂次方大小'
# 'atomic property of reference type %0 cannot have non-trivial assignment operator'
HFC34A950A835: '引用类型%0的原子属性不能具有非平凡的赋值运算符'
# "atomic types are not supported in '%0'"
H97C63071B5D3: "原子类型不被支持在'%0'中使用"
# 'atomic variable can be %select{assigned|initialized}0 to a variable only in global address space'
HCB0951EAACB6: '原子变量只能在全局地址空间中%select{赋值|初始化}0到另一个变量'
# 'attempt to call %0 on non-heap %select{object %2|object: block expression|object: lambda-to-function-pointer conversion}1'
H6E5B5738458E: '尝试在非堆%select{对象 %2|对象：块表达式|对象：lambda到函数指针转换}1上调用%0'
# 'attempt to specialize declaration here'
HF06CAF52936D: '尝试在此处特化声明'
# 'attempt to use a deleted function%select{|: %1}0'
HA9C947D267C4: '尝试使用已删除的函数%select{|: %1}0'
# 'attempt to use a poisoned identifier'
H3643F70789A4: '尝试使用已被毒化的标识符'
# 'attempting to use the forward class %0 as superclass of %1'
H994AA508EDDF: '尝试将前向声明的类 %0 用作 %1 的超类'
# 'attribute %0 after definition is ignored'
H5CD4712D502F: '属性 %0 在定义之后被忽略'
# 'attribute %0 can be used only on HLSL intangible type %1'
HF8261011AFDE: '属性 %0 仅可用于 HLSL 无形类型 %1'
# 'attribute %0 can only be applied to @protocol definitions, not forward declarations'
H308DB757AA67: '属性 %0 仅可应用于 @protocol 定义，而非前向声明'
# 'attribute %0 can only be applied to an OpenCL kernel function'
HCB6BF3FC512F: '属性 %0 仅可应用于 OpenCL 内核函数'
# 'attribute %0 cannot appear more than once on a declaration'
HB715D0AA3201: '属性 %0 不能在一个声明中出现多次'
# 'attribute %0 cannot be applied to %1'
H3AE597187391: '属性 %0 无法应用于 %1'
# 'attribute %0 cannot be applied to %select{functions|Objective-C method}1 without return value'
H1C83B6EE306A: '属性 %0 无法应用于没有返回值的 %select{函数|Objective-C 方法}1'
# "attribute %0 cannot be applied to a 'void' parameter"
H6A5920736ACF: "属性 %0 无法应用于 'void' 类型的参数"
# 'attribute %0 cannot be used as an attribute pack'
HE6BA361D74BF: '属性 %0 不能作为属性包使用'
# 'attribute %0 cannot have an argument list'
HA4D8BF32DC8E: '属性 %0 不能带有参数列表'
# 'attribute %0 does not support argument pack expansion'
H09CC6A21F4B4: '属性 %0 不支持参数包展开'
# "attribute %0 has no effect when annotating an 'if %select{constexpr|consteval}1' statement"
H409C4714E4F9: "在标注 'if %select{constexpr|consteval}1' 语句时，属性 %0 无效"
# 'attribute %0 has no effect when annotating an infinite loop'
HB06D2414EAF4: '在标注无限循环时，属性 %0 无效'
# 'attribute %0 ignored, because it cannot be applied to a type'
H5708F2759194: '属性 %0 被忽略，因为其不能应用于类型'
# 'attribute %0 ignored, because it cannot be applied to omitted return type'
H547B25BBFFDA: '属性 %0 被忽略，因为其不能应用于省略的返回类型'
# 'attribute %0 ignored, because it is not attached to a declaration'
H14902C950EC7: '属性 %0 被忽略，因为其未附加到任何声明'
# 'attribute %0 is already applied'
HC7BD790A19A9: '属性 %0 已经被应用过'
# 'attribute %0 is already applied with different arguments'
H11C03822A58E: '属性 %0 已经用不同的参数应用过'
# 'attribute %0 is ignored, place it after "%select{class|struct|interface|union|enum|enum class|enum struct}1" to apply attribute to type declaration'
HB89779883F0D: '属性 %0 被忽略，请将其放在 "%select{类|结构体|接口|联合体|枚举|枚举类|枚举结构体}1" 之后以应用到类型声明'
# "attribute %0 is not supported by '#pragma clang attribute'"
H38205446BD5C: "属性 %0 不受 '#pragma clang attribute' 支持"
# 'attribute %0 is supported in the OpenCL version %1%select{| onwards}2'
H50454061E7F3: '属性 %0 在 OpenCL 版本 %1%select{| 及以后}2 中受支持'
# "attribute %0 is unsupported in '%1' shaders, requires %select{|one of the following: }2%3"
HFE781A72AFCA: "属性 %0 在 '%1' 着色器中不受支持，需要 %select{|以下之一: }2%3"
# 'attribute %0 only applies to %1'
HC6318570485F: '属性 %0 仅适用于 %1'
# "attribute %0 only applies to a field or parameter of type '%1'"
H552F45F43B85: '属性 %0 仅适用于类型 "%1" 的字段或参数'
# 'attribute %0 requires shader model %1 or greater'
H06BEB9F659D8: '属性 %0 需要 shader 模型 %1 或更高版本'
# 'attribute %0 with %1 arguments requires shader model %2 or greater'
H51393292A866: '带有 %1 个参数的属性 %0 需要 shader 模型 %2 或更高版本'
# 'attribute %q0 cannot be applied to a deleted function'
HCB37B8A40CF9: '属性 %q0 不能应用于已删除的函数'
# 'attribute %q0 cannot be applied to member of %q1 class'
HFBD033ADD565: '属性 %q0 不能应用于 %q1 类的成员'
# "attribute '%0' on function does not match previous declaration"
HF59632E17268: "函数上的属性 '%0' 与之前的声明不匹配"
# "attribute '%0' on overriding function does not match base declaration"
H19F6EB5D2707: "覆盖函数上的属性 '%0' 与基类声明不匹配"
# "attribute '%0' should not be added via type conversion"
HD3474317FB81: "不应通过类型转换添加属性 '%0'"
# "attribute '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' multiversioned functions do not yet support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function|lambdas}1"
HF5E6CA9178D8: "属性 '%select{|目标|CPU特定|CPU分派|目标克隆|目标版本}0' 的多版本函数尚不支持 %select{函数模板|虚函数|推导的返回类型|构造函数|析构函数|已删除函数|默认函数|constexpr函数|consteval函数|lambda表达式}1"
# "attribute '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' multiversioning cannot be combined with attribute %1"
HA264FE94729F: "属性 '%select{|目标|CPU特定|CPU分派|目标克隆|目标版本}0' 的多版本功能不能与属性 %1 结合使用"
# "attribute 'msvc::constexpr' cannot be applied to the %select{constexpr|consteval|virtual}0 function %1"
HAC0996F3C628: "属性 'msvc::constexpr' 不能应用于 %select{constexpr|consteval|虚}0 函数 %1"
# "attribute 'readonly' of property %0 restricts attribute 'readwrite' of property inherited from %1"
HEB32CB97F1A3: "属性 %0 的 'readonly' 属性限制了从 %1 继承的 'readwrite' 属性"
# 'attribute declaration must precede definition'
H83850ED606E9: '属性声明必须在定义之前'
# 'attribute is here'
HD14867328E83: '属性在此处'
# "attribute is ignored on this statement as it only applies to functions; use '%0' on statements"
H8C71964DA95C: "该属性被忽略，因为它仅适用于函数；请在语句上使用'%0'"
# 'attribute only applies to output parameters'
H05F9B2ABFA42: '该属性仅适用于输出参数'
# 'attribute with scope specifier cannot follow default scope specifier'
HFC36C268C353: '带作用域说明符的属性不能跟随默认作用域说明符'
# 'attributes \'%0("%2")\' and \'%1("%2")\' are mutually exclusive'
H56F1BA7862B2: '属性\'%0("%2")\'和\'%1("%2")\'是互斥的'
# 'attributes cannot be specified on a nested namespace definition'
H4264DC0CBC46: '嵌套的命名空间定义不能指定属性'
# 'attributes cannot be specified on namespace alias'
H4F2E4C4430E8: '命名空间别名不能指定属性'
# 'attributes on %select{a namespace|an enumerator}0 declaration are a C++17 extension'
H034995816099: '在%select{命名空间|枚举值}0声明上使用属性是C++17扩展'
# 'attributes on %select{a namespace|an enumerator}0 declaration are incompatible with C++ standards before C++17'
H8BB41AEA1EC6: '在%select{命名空间|枚举值}0声明上使用属性与C++17之前的版本不兼容'
# 'authenticating a null pointer will almost certainly trap'
HB0AE642AC2E4: '验证空指针几乎肯定会引发陷阱'
# 'auto property synthesis is synthesizing property not explicitly synthesized'
H0B109C7F8F74: '自动属性综合正在综合未显式综合的属性'
# 'auto property synthesis will not synthesize property %0 because it cannot share an ivar with another synthesized property'
HB5E0DEB40CE6: '自动属性综合不会合成属性%0，因为它无法与其他综合属性共享实例变量'
# "auto property synthesis will not synthesize property %0 because it is 'readwrite' but it will be synthesized 'readonly' via another property"
H2BD61AD864B9: '自动属性综合不会合成属性%0，因为它被标记为"readwrite"，但将通过另一个属性被综合为"readonly"'
# 'auto property synthesis will not synthesize property %0 declared in protocol %1'
HA0C341D1A812: '自动属性综合不会合成在协议%1中声明的属性%0'
# 'auto property synthesis will not synthesize property %0; it will be implemented by its superclass, use @dynamic to acknowledge intention'
H0457D53851AF: '自动属性综合不会合成属性%0；它将由超类实现，请使用@dynamic声明此意图'
# 'automatic variable qualified with an%select{| invalid}0 address space'
H122ACAE25198: '自动变量使用%select{|无效}0地址空间限定'
# 'autosynthesized property %0 will use %select{|synthesized}1 instance variable %2, not existing instance variable %3'
H4495EA68D322: '自动综合的属性%0将使用%select{|综合的}1实例变量%2，而非现有实例变量%3'
# 'availability does not match previous declaration'
H583F2A1BC062: '可用性声明与之前的声明不匹配'
# 'available multilibs are:%0'
H0F052B7170DD: '可用的多库配置是：%0'
# "backend data layout '%0' does not match expected target description '%1'"
H82DEBC38BED7: "后端数据布局'%0'与预期目标描述'%1'不匹配"
# 'backslash and newline separated by space'
HD4F9A252F950: '反斜杠和换行符被空格分隔'
# 'bad receiver type %0'
HE40F679E3605: '无效的接收器类型 %0'
# "base %0 is marked '%select{final|sealed}1'"
HE6BCB4D05CEC: "基类 %0 被标记为 '%select{final|sealed}1'"
# 'base class %0 has %select{private|protected}1 destructor'
HEB04CB913679: '基类 %0 的析构函数是 %select{私有|受保护}1 的'
# 'base class %0 has a flexible array member'
HD71C5E7037F5: '基类 %0 包含柔性数组成员'
# 'base class %0 is uninitialized when used here to access %q1'
H6E433F27AF21: '使用此处的未初始化基类 %0 访问 %q1'
# 'base class %0 specified here'
HE35763C73750: '此处指定的基类 %0'
# 'base class %0 specified more than once as a direct base class'
HC14516852948: '基类 %0 被多次直接指定'
# 'base class has incomplete type'
H4B76670DCEA2: '基类类型未完成'
# 'base class initializer %0 names both a direct base class and an inherited virtual base class'
HAE21C251743B: '基类初始化项 %0 同时指定了直接基类和虚拟继承基类'
# 'base of member reference is a function; perhaps you meant to call it%select{| with no arguments}0?'
H224FA72A413F: '成员引用的基础是一个函数；或许您想调用它%select{|无参数}0？'
# 'base specifier must name a class'
HBDBF7667EBAE: '基类说明符必须指定一个类'
# 'because %select{base class of |field of |}0type %1 has a user-provided %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2'
HA75BA84DF85B: '因为 %select{基类的|字段的|}0类型 %1 包含用户提供的 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}2'
# 'because %select{base class of |field of |}0type %1 has no default constructor'
HC07ABEF26326: '因为 %select{基类的|字段的|}0类型 %1 没有默认构造函数'
# 'because field %0 has an initializer'
H7DB53EF856A5: '因为字段 %0 有初始化器'
# 'because it has a default argument'
H4C6DC4DA1E45: '因为它具有默认实参'
# 'because it is a variadic function'
H640DA969741B: '因为它是一个可变参数函数'
# 'because its parameter is %diff{of type $, not $|of the wrong type}2,3'
H5CB13170AE2B: '因为其参数 %diff{类型为 $，而非 $|类型错误}2,3'
# 'because no %select{<<ERROR>>|constructor|constructor|assignment operator|assignment operator|<<ERROR>>}2 can be used to %select{<<ERROR>>|copy|move|copy|move|<<ERROR>>}2 %select{base class|field|an object}0 of type %3'
HD9E44C137738: '因为无法使用 %select{<<ERROR>>|构造函数|构造函数|赋值运算符|赋值运算符|<<ERROR>>}2 %select{<<ERROR>>|拷贝|移动|拷贝|移动|<<ERROR>>}2 %select{基类|字段|对象}0 类型 %3'
# 'because of ambiguity in conversion %diff{of $ to $|between types}0,1'
HB064B974A1C3: '因为转换 %diff{类型 $ 到 $|类型之间}0,1 存在歧义'
# 'because substituted constraint expression is ill-formed%0'
H708967A94C80: '因为替换后的约束表达式存在语法错误%0'
# 'because the function selected to %select{construct|copy|move|copy|move|destroy}2 %select{base class|field}0 of type %1 is not trivial'
H1F152D129667: '因为选择用于%select{构造|复制|移动|复制|移动|销毁}2 %select{基类|字段}0 的类型%1的函数不是平凡的'
# 'because type %0 has a member with %select{no|no|__strong|__weak|__autoreleasing}1 ownership'
HE992EBFC669B: '因为类型%0有一个成员具有%select{无|无|__strong|__weak|__autoreleasing}1所有权'
# 'because type %0 has a virtual %select{member function|base class}1'
H45351AACBEF7: '因为类型%0有一个虚拟%select{成员函数|基类}1'
# "befriending %1 without '%select{struct|interface|union|class|enum}0' keyword is incompatible with C++98"
HDE958FBB8995: "在没有'%select{struct|interface|union|class|enum}0'关键字的情况下友元声明%1与C++98不兼容"
# 'binary fold expression has unexpanded parameter packs in both operands'
HBE3AEFF67350: '二进制折叠表达式在两个操作数中都包含未展开的模板参数包'
# 'binary integer literals are a C++14 extension'
H12BBB01421DF: '二进制整数字面量是C++14扩展'
# 'binary integer literals are a C23 extension'
HC848A482B4CC: '二进制整数字面量是C23扩展'
# 'binary integer literals are incompatible with C standards before C23'
H60CB9502C648: '二进制整数字面量与C23之前的C标准不兼容'
# 'binary integer literals are incompatible with C++ standards before C++14'
H039AFCF983A6: '二进制整数字面量与C++14之前的C++标准不兼容'
# 'binary operator not supported, only +, *, -, /, &, ^, |, <<, or >> are permitted'
H947D153F3B10: '不支持的二进制运算符，仅允许使用+, *, -, /, &, ^, |, << 或 >>'
# 'binding %0 cannot appear in the initializer of its own decomposition declaration'
H672061929029: '绑定%0不能出现在其自身分解声明的初始化器中'
# 'binding dereferenced null pointer to reference has undefined behavior'
H95EC0F6A8A66: '将空指针解引用后绑定到引用具有未定义行为'
# 'binding reference %diff{of type $ to value of type $|to value}0,1 %select{drops %3 qualifier%plural{1:|2:|4:|:s}4|changes address space|not permitted due to incompatible qualifiers}2'
H55C0D80172E9: '绑定%diff{类型$到类型$的值|到值}0,1 %select{去除%3 %plural{1:限定符|2:限定符|4:限定符|:s}4|更改地址空间|因不兼容的限定符无法绑定}2'
# 'binding reference member %0 to stack allocated %select{variable|parameter}2 %1'
H6CEDF6C3E571: '将引用成员%0绑定到栈分配的%select{变量|参数}2 %1'
# "binding type '%0' is invalid"
HD0FB3A3589D6: "绑定类型'%0'无效"
# "binding type '%select{t|u|b|s|c|i}0' cannot be applied more than once"
H9FC4B2C35AB9: "绑定类型'%select{t|u|b|s|c|i}0'不能重复使用"
# "binding type '%select{t|u|b|s|c}0' only applies to %select{SRV resources|UAV resources|constant buffer resources|sampler state|numeric variables in the global scope}0"
H9DB6D490A30A: "绑定类型'%select{t|u|b|s|c}0'仅适用于%select{SRV资源|UAV资源|常量缓冲区资源|采样器状态|全局作用域中的数值变量}0"
# "binding type '%select{t|u|b|s|c}0' only applies to types containing %select{SRV resources|UAV resources|constant buffer resources|sampler state|numeric types}0"
H1CE73AE71EA5: "绑定类型'%select{t|u|b|s|c}0'仅适用于包含%select{SRV资源|UAV资源|常量缓冲区资源|采样器状态|数值类型}0的类型"
# "binding type 'b' only applies to constant buffers. The 'bool constant' binding type is no longer supported"
HC83E5E495198: "绑定类型'b'仅适用于常量缓冲区。'bool constant'绑定类型已不再支持"
# "binding type 'c' ignored in buffer declaration. Did you mean 'packoffset'?"
H937D8317B6A5: "绑定类型'c'在缓冲区声明中被忽略。您是指'packoffset'吗？"
# "binding type 'i' ignored. The 'integer constant' binding type is no longer supported"
H2F0190E0856D: "绑定类型 'i' 被忽略。'integer constant'（整型常量）绑定类型不再受支持"
# "bit fields cannot be used to specify storage in a '%0' clause"
H5C9BE7997F9C: "位字段不能用于在 '%0' 子句中指定存储"
# 'bit-field %0 has negative width (%1)'
HA6B3D52AF212: '位字段 %0 的宽度为负数 (%1)'
# 'bit-field %0 has non-integral type %1'
H1F66B27F57D3: '位字段 %0 的类型 %1 不是整型'
# 'bit-field %0 is not wide enough to store all enumerators of %1'
H1E7885609E9C: '位字段 %0 的宽度不足以存储枚举类型 %1 的所有枚举值'
# 'bit-field is declared here'
HE5CFF566169E: '位字段在此处声明'
# 'bit-fields are not supported in OpenCL'
H752654865932: 'OpenCL 不支持位字段'
# 'bit_cast %select{from|to}0 a %select{|type with a }1%select{union|pointer|member pointer|volatile|reference}2 %select{type|member}1 is not allowed in a constant expression'
H0C9C7C0B5093: 'bit_cast %select{from|to}0 的 %select{|type with a }1%select{联合|指针|成员指针|volatile|引用}2 %select{类型|成员}1 不允许出现在常量表达式中'
# 'bit_cast involving type %0 is not allowed in a constant expression; element size %1 * element count %2 is not a multiple of the byte size %3'
H3BD534784507: '涉及类型 %0 的 bit_cast 操作不允许出现在常量表达式中；元素大小 %1 * 元素数量 %2 不是字节大小 %3 的倍数'
# "bitcode library '%0' does not exist"
H551B33870D5D: "位码库 '%0' 不存在"
# 'bitmasking for introspection of Objective-C object pointers is strongly discouraged'
H7CE8DAA0A6CB: '强烈不建议使用位掩码来检查 Objective-C 对象指针的内部结构'
# 'bitwise comparison always evaluates to %select{false|true}0'
H8A4398170F46: '按位比较始终计算为 %select{false|true}0'
# "bitwise negation of a boolean expression%select{;| always evaluates to 'true';}0 did you mean logical negation?"
HE532D6128324: "布尔表达式的按位取反%select{;|始终计算为 'true';}0 是否应改为逻辑非运算？"
# 'bitwise or with non-zero value always evaluates to true'
H6F8F36ACC41B: '与非零值进行按位或运算始终计算为 true'
# 'block cannot return %select{array|function}0 type %1'
H91AB8D594327: '块不能返回 %select{数组|函数}0 类型 %1'
# 'block captures an autoreleasing out-parameter, which may result in use-after-free bugs'
H835D51AA87F3: '块捕获了一个自动释放的传出参数，可能导致使用已释放内存的错误'
# "block could be declared with attribute 'noreturn'"
H9307EF042F77: "该块可以使用 'noreturn' 属性进行声明"
# "block implicitly retains 'self'; explicitly mention 'self' to indicate this is intended behavior"
H094C5FEF2D2A: "块会隐式保留 'self'；若这是预期行为，请显式提及 'self'"
# 'block pointer to non-function type is invalid'
H9EFC2777265D: '指向非函数类型的块指针无效'
# 'block pointer variable %0 is %select{uninitialized|null}1 when captured by block'
H5DFD2F29C16B: '被块捕获的块指针变量 %0 的值为 %select{未初始化|null}1'
# 'block type cannot be used as expression in ternary expression in OpenCL'
HE91DFBCBC336: '块类型不能用作OpenCL三元表达式中的表达式'
# 'block will be retained by %select{the captured object|an object strongly retained by the captured object}0'
H659E73E5BC81: '块将被%select{被捕获的对象|该对象强引用的对象}0所保留'
# 'blocks support disabled - compile with -fblocks or %select{pick a deployment target that supports them|for OpenCL C 2.0 or OpenCL C 3.0 with __opencl_c_device_enqueue feature}0'
H870F6FD76494: '块功能被禁用 - 编译时需添加-fblocks选项或%select{选择支持块功能的部署目标|使用支持__opencl_c_device_enqueue特性的OpenCL C 2.0或3.0}0'
# "blocks used in enqueue_kernel call are expected to have parameters of type 'local void*'"
H5A1C0A69E254: "enqueue_kernel调用中使用的块预期参数类型为'local void*'"
# 'blocks with parameters are not accepted in this prototype of enqueue_kernel call'
H6F73FE38020E: '此enqueue_kernel调用的原型不接受带有参数的块'
# 'body of cpu_dispatch function will be ignored'
H8CCA48E04008: 'cpu_dispatch函数的函数体将被忽略'
# "bool literal returned from 'main'"
H65A070E22BD6: "'main'函数返回了布尔字面量"
# 'both arms of conditional operator are unable to produce a constant expression'
H42234192A750: '条件运算符的两个分支均无法生成常量表达式'
# 'brace elision for designated initializer is a C99 extension'
H98B26CB02BEA: '指定初始化器的花括号省略是C99扩展'
# 'braces around %select{scalar |}0initializer'
H5FA1CA5D46EC: '初始化器周围的%select{标量 |}0花括号'
# 'bracket nesting level exceeded maximum of %0'
HAE0DB07D013C: '超过最大嵌套层级%0'
# 'brackets are not allowed here; to declare an array, place the brackets after the %select{identifier|name}0'
H9FD98F06E7EB: '此处不允许使用方括号；若要声明数组，请将方括号置于%select{标识符|名称}0之后'
# "build a shadowed submodule '%0'"
H9D79CC95EF50: "构建被覆盖的子模块'%0'"
# "building module '%0' as '%1'"
H765D28E7D6EF: "正在构建模块'%0'为'%1'"
# 'built-in candidate %0'
H70FA60F84316: '内置候选%0'
# 'builtin %0 is deprecated; use %1 instead'
H3145BB7C5706: '已弃用的内置函数%0；请改用%1'
# 'builtin call is not valid when calling from a function without active ZA state'
H7B974CCBB78F: '从无活动ZA状态的函数调用内置函数无效'
# 'builtin call is not valid when calling from a function without active ZT0 state'
H1B7C49833DEE: '从无活动ZT0状态的函数调用内置函数无效'
# 'builtin can only be called from a %0 function'
H2DDDDEB70C80: '该内置函数只能从%0类型的函数调用'
# 'builtin feature check macro requires a parenthesized identifier'
HA88BFEE47095: '内置特性检查宏需要带括号的标识符'
# 'builtin functions must be directly called'
HABBC844A5E58: '内置函数必须直接调用'
# 'builtin is not supported on this target'
H6C31A7E5443F: '此目标不支持内置函数'
# 'builtin requires%select{| at least one of the following extensions}0: %1'
HBE3E35E72C33: '内置函数需要%select{|以下至少一个扩展}0: %1'
# "but in %select{'%1'|definition here}0 found %select{%3 referenced %plural{1:protocol|:protocols}3|%ordinal3 referenced protocol with different name %4}2"
HD3683C05282A: "但在%select{'%1'|此处的定义}0 发现 %select{引用了%3 %plural{1:协议|:协议}3|%ordinal3 参考的协议名称不同%4}2"
# "but in %select{'%1'|definition here}0 found %select{%select{method %4|constructor|destructor}3 that has %5 parameter%s5|%select{method %4|constructor|destructor}3 with %ordinal5 parameter of type %6%select{| decayed from %8}7|%select{method %4|constructor|destructor}3 with %ordinal5 parameter named %6}2"
HF69A42480F6D: "但在 %select{'%1'|此处定义}0 发现 %select{%select{方法 %4|构造函数|析构函数}3 具有 %5 参数%s5|%select{方法 %4|构造函数|析构函数}3 的第 %ordinal5 参数类型为 %6%select{| 从 %8 衰减而来}7|%select{方法 %4|构造函数|析构函数}3 的第 %ordinal5 参数名为 %6}2"
# "but in %select{'%1'|definition here}0 found %select{%select{no super class|super class with type %4}3|instance variable '%3' access control is %select{|@private|@protected|@public|@package}4}2"
H07A5F408116E: "但在 %select{'%1'|定义处}0 发现 %select{%select{无基类|基类类型为 %4}3|实例变量 '%3' 的访问控制为 %select{|@private|@protected|@public|@package}4}2"
# "but in %select{'%1'|definition here}0 found %select{end of class|public access specifier|private access specifier|protected access specifier|static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property}2"
H901B5EFBD082: "但在 %select{'%1'|定义处}0 发现 %select{类结束|公共访问说明符|私有访问说明符|保护访问说明符|静态断言|数据成员|方法|类型别名|typedef|数据成员|友元声明|函数模板|方法|实例变量|属性}2"
# "but in %select{'%1'|definition here}0 found %select{field %3|field %3 with type %4|%select{non-|}4bit-field %3|bit-field %3 with different width expression|%select{non-|}4mutable field %3|field %3 with %select{no|an}4 initializer|field %3 with a different initializer}2"
H4C900A5437EA: "但在 %select{'%1'|定义处}0 发现 %select{字段 %3|类型为 %4 的字段 %3|%select{非-|}4位域 %3|宽度表达式不同的位域 %3|%select{非-|}4mutable字段 %3|字段 %3 具有 %select{无|一个}4初始化器|字段 %3 具有不同的初始化器}2"
# "but in %select{'%1'|definition here}0 found %select{method %3 with different return type %4|method %3 as %select{class|instance}4 method|%select{no|'required'|'optional'}3 method control|method %3 with %select{no designated initializer|designated initializer}4|%select{regular|direct}4 method %3|different method %3}2"
H9C08666CA7C3: "但在 %select{'%1'|定义处}0 发现 %select{返回类型不同的方法 %3 %4|作为 %select{类|实例}4 方法的 %3 方法|%select{无|'required'|'optional'}3 方法控制|方法 %3 具有 %select{非指定初始化器|命名初始化器}4|%select{常规|直接}4方法 %3|不同的方法 %3}2"
# "but in %select{'%1'|definition here}0 found %select{property %3|property %3 with type %4|%select{no|'required'|'optional'}3 property control|property %3 with different '%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}4' attribute}2"
HFF656A371ACE: "但在 %select{'%1'|定义处}0 发现 %select{属性 %3|类型为 %4 的属性 %3|%select{无|'required'|'optional'}3 属性控制|属性 %3 具有不同 '%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}4' 属性}2"
# "but in %select{'%1'|definition here}0 found %select{||||different static assert|different field|different method|different type alias|different typedef|different data member|different friend declaration|different function template|different method|different instance variable|different property|another unexpected decl}2"
HF376197A4A03: "但在 %select{'%1'|定义处}0 发现 %select{||||不同的静态断言|不同的数据成员|不同的方法|不同的类型别名|不同的typedef|不同的数据成员|不同的友元声明|不同的函数模板|不同的方法|不同的实例变量|不同的属性|另一个意外声明}2"
# "but in '%0' found %select{%2 base %plural{1:class|:classes}2|%2 virtual base %plural{1:class|:classes}2|%ordinal2 base class with different type %3|%ordinal2 %select{non-virtual|virtual}3 base class %4|%ordinal2 base class %3 with %select{public|protected|private|no}4 access specifier}1"
H86407D9382F4: "但在 '%0' 发现 %select{%2 基 %plural{1:类|:类}2|%2 虚基 %plural{1:类|:类}2|%ordinal2 基类类型不同 %3|%ordinal2 %select{非虚|虚}3 基类 %4|%ordinal2 基类 %3 具有 %select{公有|保护|私有|无}4 访问说明符}1"
# "but in '%0' found %select{%select{typedef|type alias}2 name %3|%select{typedef|type alias}2 %3 with different underlying type %4}1"
H5285292325BC: "但在 '%0' 中发现 %select{%select{typedef|类型别名}2 名称 %3|%select{typedef|类型别名}2 %3 具有不同基础类型 %4}1"
# "but in '%0' found %select{data member with name %2|data member %2 with different type %3|data member %2 with%select{out|}3 an initializer|data member %2 with a different initializer|data member %2 %select{is constexpr|is not constexpr}3}1"
HB02EC39C6642: "但在 '%0' 中发现 %select{名称为 %2 的数据成员|类型为 %3 的数据成员 %2|%2 数据成员%select{out|}3 具有初始化器|%2 数据成员具有不同初始化器|%2 数据成员%select{是constexpr|不是constexpr}3}1"
# "but in '%0' found %select{different return type %2|%ordinal2 parameter with name %3|%ordinal2 parameter with type %3%select{| decayed from %5}4|%ordinal2 parameter with%select{out|}3 a default argument|%ordinal2 parameter with a different default argument|a different body}1"
H926097C3EBA4: "但在 '%0' 中发现 %select{不同返回类型 %2|第 %ordinal2 参数名称 %3|第 %ordinal2 参数类型 %3%select{| 转换自 %5}4|第 %ordinal2 参数带%select{无|}3 默认参数|第 %ordinal2 参数默认参数不同|函数体不同}1"
# "but in '%0' found %select{enum that is %select{not scoped|scoped}2|enum scoped with keyword %select{struct|class}2|enum %select{without|with}2 specified type|enum with specified type %2|enum with %2 element%s2|%ordinal2 element has name %3|%ordinal2 element %3 %select{has|does not have}4 an initializer|%ordinal2 element %3 has different initializer|}1"
H44D066860BB7: "但在'%0'中发现%select{枚举类型是%select{非命名空间|命名空间}2|使用%select{struct|class}2关键字作用域的枚举|枚举%select{没有|有}2指定类型|具有指定类型%2的枚举|包含%2个元素%s2的枚举|第%ordinal2个元素名为%3|第%ordinal2个元素%3%select{有|没有}4初始值设定项|第%ordinal2个元素%3具有不同的初始值设定项|}1"
# "but in '%0' found %select{static assert with different condition|static assert with different message|static assert with %select{|no }2message|%select{method %3|constructor|destructor}2|%select{method %3|constructor|destructor}2 is %select{not deleted|deleted}4|%select{method %3|constructor|destructor}2 is %select{not defaulted|defaulted}4|%select{method %3|constructor|destructor}2 is %select{|pure }4%select{not virtual|virtual}5|%select{method %3|constructor|destructor}2 is %select{not static|static}4|%select{method %3|constructor|destructor}2 is %select{not volatile|volatile}4|%select{method %3|constructor|destructor}2 is %select{not const|const}4|%select{method %3|constructor|destructor}2 is %select{not inline|inline}4|%select{method %3|constructor|destructor}2 with %ordinal4 parameter with%select{out|}5 a default argument|%select{method %3|constructor|destructor}2 with %ordinal4 parameter with a different default argument|%select{method %3|constructor|destructor}2 with %select{no |}4template arguments|%select{method %3|constructor|destructor}2 with %4 template argument%s4|%select{method %3|constructor|destructor}2 with %4 for %ordinal5 template argument|%select{method %3|constructor|destructor}2 with %select{no body|body}4|%select{method %3|constructor|destructor}2 with different body|friend %select{class|function}2|friend %2|friend function %2|function template %2 with %3 template parameter%s3|function template %2 with %ordinal3 template paramter being a %select{type|non-type|template}4 template parameter|function template %2 with %ordinal3 template parameter %select{with no name|named %5}4|function template %2 with %ordinal3 template parameter with %select{no |}4default argument|function template %2 with %ordinal3 template parameter with default argument %4|function template %2 with %ordinal3 template parameter with different type|function template %2 with %ordinal3 template parameter %select{not |}4being a template parameter pack|}1"
H650FCD73F7BC: "但在 '%0' 中发现 %select{具有不同条件的静态断言|具有不同消息的静态断言|具有%select{|无 }2消息的静态断言|%select{方法 %3|构造函数|析构函数}2|%select{方法 %3|构造函数|析构函数}2 是 %select{未删除|已删除}4|%select{方法 %3|构造函数|析构函数}2 是 %select{未默认|已默认}4|%select{方法 %3|构造函数|析构函数}2 是 %select{|纯 }4%select{非虚|虚}5|%select{方法 %3|构造函数|析构函数}2 是 %select{非静态|静态}4|%select{方法 %3|构造函数|析构函数}2 是 %select{非volatile|volatile}4|%select{方法 %3|构造函数|析构函数}2 是 %select{非const|const}4|%select{方法 %3|构造函数|析构函数}2 是 %select{非内联|内联}4|%select{方法 %3|构造函数|析构函数}2 的第 %ordinal4 参数带有%select{出|}5 默认参数|%select{方法 %3|构造函数|析构函数}2 的第 %ordinal4 参数具有不同默认参数|%select{方法 %3|构造函数|析构函数}2 具有%select{无|有}4模板参数|%select{方法 %3|构造函数|析构函数}2 具有 %4 模板参数%s4|%select{方法 %3|构造函数|析构函数}2 具有 %4 作为第 %ordinal5 模板参数|%select{方法 %3|构造函数|析构函数}2 具有%select{无|有}4函数体|%select{方法 %3|构造函数|析构函数}2 具有不同函数体|友元 %select{类|函数}2|友元 %2|友元函数 %2|函数模板 %2 具有 %3 模板参数%s3|函数模板 %2 具有第 %ordinal3 模板参数是 %select{类型|非类型|模板}4 模板参数|函数模板 %2 具有第 %ordinal3 模板参数%select{无名称|名称为 %5}4|函数模板 %2 具有第 %ordinal3 模板参数%select{无|}4默认参数|函数模板 %2 具有第 %ordinal3 模板参数默认参数 %4|函数模板 %2 具有第 %ordinal3 模板参数类型不同|函数模板 %2 具有第 %ordinal3 模板参数%select{不|}4是模板参数包|}1"
# "but in '%0' found %select{unnamed template parameter %2|template parameter %3|template parameter with %select{no |}2default argument|template parameter with different default argument}1"
HA18966A0FC1B: "但在 '%0' 中发现 %select{无名称模板参数 %2|模板参数 %3|模板参数%select{无 |}2默认参数|模板参数具有不同默认参数}1"
# "by value capture of '*this' is incompatible with C++ standards before C++17"
H60BDFA125D23: "在C++17之前的C++标准中，通过值捕获 '*this' 是不兼容的"
# 'by-copy capture of value of abstract type %0'
H69470A21D7A2: '对抽象类型 %0 的值进行拷贝捕获'
# 'by-copy capture of variable %0 with %select{incomplete|sizeless}1 type %2'
H0B21D37A79AB: '通过复制捕获变量 %0，其类型 %2 是%select{不完整类型|零大小}1'
# 'call to %0 implicitly required by coroutine function here'
H58DB024E2029: '协程函数在此处隐式调用 %0'
# 'call to %0 is ambiguous'
HE4A087079576: '调用 %0 时存在歧义'
# 'call to %select{immediate|consteval}1 function %q0 is not a constant expression'
H00D075778CD9: '%select{立即|consteval}1 函数 %q0 的调用不是常量表达式'
# 'call to %select{non-static|explicit}0 member function without an object argument'
H63B47EF20C66: '调用%select{非静态|显式}0 成员函数时缺少对象参数'
# 'call to %select{placement|class-specific}0 %1'
H295DBDE7B5BD: '调用%select{placement|类特异性}0 %1'
# "call to '%0' declared with 'error' attribute: %1"
HDBB58BF71CEC: "调用用'error'属性声明的'%0'函数： %1"
# "call to '%0' declared with 'warning' attribute: %1"
H3865B6C0D901: "调用用'warning'属性声明的'%0'函数： %1"
# "call to '%select{__builtin_operator_new|__builtin_operator_delete}0' selects non-usual %select{allocation|deallocation}0 function"
H676581AF4E96: "调用'%select{__builtin_operator_new|__builtin_operator_delete}0'选择了非常规%select{分配|释放}0函数"
# "call to '%select{initial_suspend|final_suspend}0' implicitly required by the %select{initial suspend point|final suspend point}0"
H1C6B1E5ADCED: '在%select{初始挂起点|最终挂起点}0处隐式调用%select{initial_suspend|final_suspend}0'
# "call to 'await_transform' implicitly required by 'co_await' here"
HA0503466B398: "'co_await'在此处隐式调用'await_transform'函数"
# "call to a function that shares state other than 'za' from a function that has live 'za' state requires a spill/fill of ZA, which is not yet implemented"
H8FF6C74595CF: "从具有活动ZA状态的函数调用共享ZA状态（非'za'）的函数需要保存/恢复ZA状态，但该功能尚未实现"
# 'call to a shared ZA function requires the caller to have ZA state'
H755688EF43BB: '调用共享ZA函数需要调用方具有ZA状态'
# 'call to a shared ZT0 function requires the caller to have ZT0 state'
H89ACEBE543C2: '调用共享ZT0函数需要调用方具有ZT0状态'
# "call to a streaming function requires 'sme'"
H41309CFB27F8: "调用流式函数需要'sme'"
# 'call to constructor of %0 is ambiguous'
H00A38B0315FF: '调用%0构造函数时存在歧义'
# 'call to deleted constructor of %0%select{|: %2}1'
HAA8E5FBCBA79: '调用已删除的%0构造函数%select{|： %2}1'
# 'call to deleted function call operator in type %0%select{|: %2}1'
H8F857BEAC26F: '调用类型%0中的已删除函数调用运算符%select{|： %2}1'
# 'call to deleted%select{| member}0 function %1%select{|: %3}2'
H6B002A51A7D4: '调用已删除%select{|成员}0函数%1%select{|： %3}2'
# 'call to function %0 that is neither visible in the template definition nor found by argument-dependent lookup'
H225588528963: '调用在模板定义中不可见且无法通过参数相关查找找到的函数%0'
# 'call to global function %0 not configured'
HC08574A55FB5: '调用未配置的全局函数%0'
# 'call to implicitly-deleted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0 of %1'
H4C623CF7C837: '调用%1的隐式删除的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数|函数}0'
# 'call to member function %0 is ambiguous'
H60EE3A6ABF6A: '调用成员函数%0 时发生歧义'
# 'call to object of type %0 is ambiguous'
H3783B2A8DBDC: '调用类型%0的对象时发生歧义'
# "call to pointer to member function of type %0 drops '%1' qualifier%s2"
HC75C3E40313D: "调用类型%0的成员函数指针时丢失'%1'限定符%s2"
# 'call to pseudo-destructor cannot have any arguments'
H6ECE40631FC9: '伪析构函数调用不能带有任何参数'
# 'call to pure virtual member function %0 has undefined behavior; overrides of %0 in subclasses are not available in the %select{constructor|destructor}1 of %2'
HDC8AD43C5C1C: '调用纯虚成员函数%0 会产生未定义行为；%2的%select{构造函数|析构函数}1 中不可访问子类对%0 的重载'
# 'call to subscript operator of type %0 is ambiguous'
H1E29AAB6AD84: '类型%0的下标运算符调用发生歧义'
# 'call to undeclared function %0; ISO C99 and later do not support implicit function declarations'
HEBF384E2E2A6: '调用未声明函数%0；ISO C99及后续标准不支持隐式函数声明'
# "call to undeclared library function '%0' with type %1; ISO C99 and later do not support implicit function declarations"
HF288A58FA40B: "调用未声明的库函数'%0'（类型%1）；ISO C99及后续标准不支持隐式函数声明"
# 'call to unsupported expression with unknown type'
H239ACE39DA12: '调用类型未知的不受支持的表达式'
# 'called by %0'
HDC9A013B796D: '被%0调用'
# 'called object type %0 is not a function or function pointer'
H5E3F97BDB14E: '被调用对象类型%0 不是函数或函数指针'
# 'callee declares array parameter as static here'
H80DA3F678F9A: '被调用函数在此处将数组参数声明为static'
# "calling %0 is a violation of trusted computing base '%1'"
HF890EA6739C7: "调用%0 违反了可信计算基'%1'"
# 'calling %0 with incomplete return type %1'
H218BBBD759BD: '调用具有不完整返回类型的%0（返回类型%1）'
# "calling '%0' with a nonzero argument is unsafe"
H373CF9276563: "调用'%0'时传入非零参数是不安全的"
# 'calling a %select{private|protected}0 constructor of class %2'
H1D7B9B5BEE0D: '调用类%2的%select{私有|受保护}0构造函数'
# 'calling a %select{private|protected}1 destructor of class %0'
H2870B0B82BD7: '调用类%0的%select{私有|受保护}1析构函数'
# "calling function %0 requires negative capability '%1'"
HB81388BC5C94: "调用函数%0 需要负能力'%1'"
# "calling function %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HF6312AC18647: "调用函数%1需要持有%0 %select{'%2'|'%2' 独占}3"
# 'calling function with incomplete return type %0'
H47066D05EDB3: '调用具有不完整返回类型的函数%0'
# 'calls to OpenMP runtime API are not allowed within a region that corresponds to a construct with an order clause that specifies concurrent'
HF0FE255D765C: '在对应具有并发指定order子句的构造体的区域内不允许调用OpenMP运行时API'
# 'can only access this member on an object of type %0'
H97DBB9710EB7: '只能在类型%0的对象上访问该成员'
# 'can only poison identifier tokens'
HBA757282B22F: '只能毒化标识符标记'
# 'can only provide an explicit specialization for a class template, function template, variable template, or a member function, static data member, %select{or member class|member class, or member enumeration}0 of a class template'
H705307E2F906: '只能为类模板、函数模板、变量模板或类模板的成员函数、静态数据成员%select{或成员类|成员类、或成员枚举}0提供显式特化'
# "can only use 'init_priority' attribute on file-scope definitions of objects of class type"
H2C248D12A320: "只能将'init_priority'属性用于类类型对象的文件作用域定义"
# 'candidate %select{constructor|template}0 ignored: inherited constructor cannot be used to %select{copy|move}1 object'
HA2E8E747932F: '候选%select{构造函数|模板}0被忽略：继承的构造函数不能用于%select{拷贝|移动}1对象'
# 'candidate %select{constructor|template}0 ignored: instantiation %select{takes|would take}0 its own class type by value'
H5F81F51806D8: '候选%select{构造函数|模板}0被忽略：实例化%select{需要|需要}0按值获取自身类类型'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 has been %select{explicitly made unavailable|explicitly deleted|implicitly deleted}3"
HDF3920A3A1F2: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式'operator=='运算符|继承构造函数}0%select{|模板| %2}1已被%select{显式禁用|显式删除|隐式删除}3"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %ordinal5 argument (%3) would lose %select{const|restrict|const and restrict|volatile|const and volatile|volatile and restrict|const, volatile, and restrict}4 qualifier%select{||s||s|s|s}4"
H95E4AEB3B23E: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式'operator=='运算符|继承构造函数}0%select{|模板| %2}1不可行：第%ordinal5参数（%3）将丢失%select{const|restrict|const和restrict|volatile|const和volatile|volatile和restrict|const、volatile和restrict}4限定符%select{||s||s|s|s}4"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}4 ownership, but parameter has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}5 ownership"
H8D414CDC2F4E: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式'operator=='运算符|继承构造函数}0%select{|模板| %2}1不可行：%select{第%ordinal7|'this'}6参数（%3）具有%select{无|__unsafe_unretained|__strong|__weak|__autoreleasing}4所有权，但参数需要%select{无|__unsafe_unretained|__strong|__weak|__autoreleasing}5所有权"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__weak|__strong}4 ownership, but parameter has %select{no|__weak|__strong}5 ownership"
HFD1E148AC849: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式'operator=='运算符|继承构造函数}0%select{|模板| %2}1不可行：%select{第%ordinal7|'this'}6参数（%3）具有%select{无|__weak|__strong}4所有权，但参数需要%select{无|__weak|__strong}5所有权"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{cannot convert initializer list|too few initializers in list|too many initializers in list}7 argument to %4"
H4C57102C9323: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式'operator=='运算符|继承构造函数}0%select{|模板| %2}1不可行：%select{无法转换初始化列表|列表初始化器太少|列表初始化器过多}7参数到%4"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{requires at least|allows at most single|requires single}3 %select{|non-object }6argument %4, but %plural{0:no|:%5}5 arguments were provided"
H8AD4B8B6097C: "候选 %select{函数|函数|参数顺序反转的函数|构造函数|隐式默认构造函数|隐式拷贝构造函数|隐式移动构造函数|隐式赋值运算符|隐式移动赋值运算符|隐式 'operator=='（对应三向比较运算符）|继承的构造函数}0%select{| 模板| %2}1 不可用：需要 %select{至少|最多一个|一个}3 %select{非对象|}6 参数 %4，但提供 %plural{0:无|:%5}5 个参数"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: 'this' argument has type %3, but method is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}4"
HE6BBB39EEE68: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式'operator=='运算符|继承构造函数}0%select{|模板| %2}1不可行：'this'参数具有类型%3，但方法未标记为%select{const|restrict|const或restrict|volatile|const或volatile|volatile或restrict|const、volatile或restrict}4"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: 'this' object is in %3, but method expects object in %4"
H7EDBF536C9E0: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式'operator=='运算符|继承构造函数}0%select{|模板| %2}1不可行：'this'对象处于%3状态，但方法期望处于%4状态"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: call to %select{__device__|__global__|__host__|__host__ __device__|invalid}3 function from %select{__device__|__global__|__host__|__host__ __device__|invalid}4 function"
HB286FD7ADB16: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式'operator=='运算符|继承构造函数}0%select{|模板| %2}1不可行：从%select{__device__|__global__|__host__|__host__ __device__|无效}4函数调用%select{__device__|__global__|__host__|__host__ __device__|无效}3函数"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot %select{convert from|convert from|bind}3 %select{base class pointer|superclass|base class object of type}3 %4 to %select{derived class pointer|subclass|derived class reference}3 %5 for %ordinal6 argument"
H9EF538024430: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式'operator=='运算符|继承构造函数}0%select{|模板| %2}1不可行：无法%select{将|将|绑定}3%select{基类指针|基类|基类对象}3 %4转换为%select{派生类指针|派生类|派生类引用}3 %5作为第%ordinal6参数"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot %select{pass pointer to|bind reference in}5 %3 %select{as a pointer to|to object in}5 %4 in %ordinal6 argument"
HEE13EA6B12B0: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式'operator=='运算符|继承构造函数}0%select{|模板| %2}1不可行：无法%select{将指针转换为|在引用中绑定}5 %3 %select{作为指向|到}5 %4 的%ordinal6参数"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot convert argument of incomplete type %diff{$ to $|to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &|; remove *|; remove &}7"
H3F2CD3D64E80: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：无法将不完整类型 %diff{的参数从 $ 转换为 $|的参数类型转换为参数类型}3,4 的 %select{%ordinal6 参数|对象参数}5%select{|; 通过 * 解引用参数|; 使用 & 获取参数的地址|; 移除 *|; 移除 &}7"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot implicitly convert argument %diff{of type $ to $|type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5 under ARC"
H2B5B49758162: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：在 ARC 下无法隐式将类型 %diff{的参数从 $ 转换为 $|参数类型转换为目标类型}3,4 的 %select{%ordinal6 参数|对象参数}5"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: constraints not satisfied"
H01514E19EB13: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：约束条件不满足"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: expects an %select{lvalue|rvalue}5 for %select{%ordinal4 argument|object argument}3"
H5778CD649B7A: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：需要 %select{lvalue|rvalue}5 类型的 %select{%ordinal4 参数|对象参数}3"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: no known conversion %diff{from $ to $|from argument type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &|; remove *|; remove &}7"
H2C02021665E8: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：无法将 %diff{参数类型从 $ 转换为 $|参数类型转换为目标类型}3,4 的 %select{%ordinal6 参数|对象参数}5%select{|; 通过 * 解引用参数|; 使用 & 获取参数的地址|; 移除 *|; 移除 &}7"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: no overload of %4 matching %3 for %ordinal5 argument"
H327F9AFBF1B4: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：%4 的 %3 不匹配 %ordinal5 参数的重载"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: requires%select{ at least| at most|}3 %4 %select{|non-object }6argument%s4, but %5 %plural{1:was|:were}5 provided"
HE70B20B055FA: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：需要%select{ 至少| 至多|}3 %4 %select{|非对象 }6参数%s4，但提供了 %5 %plural{1:1个|:多个}5"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %3}1%select{| has different class%diff{ (expected $ but has $)|}5,6| has different number of parameters (expected %5 but has %6)| has type mismatch at %ordinal5 parameter%diff{ (expected $ but has $)|}6,7| has different return type%diff{ ($ expected but has $)|}5,6| has different qualifiers (expected %5 but found %6)| has different exception specification}4"
H8C85DA7348D1: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %3}1%select{| 具有不同的类%diff{（预期 $ 但实际为 $）|}5,6| 参数数量不同（预期 %5 但实际为 %6）| 第 %ordinal5 个参数类型不匹配%diff{（预期 $ 但实际为 $）|}6,7| 返回类型不匹配%diff{（预期 $ 但实际为 $）|}5,6| 限定符不匹配（预期 %5 但实际为 %6）| 异常规范不匹配}4"
# 'candidate address cannot be taken because parameter %0 has pass_object_size attribute'
H9C284929AC5A: '无法获取候选地址，因为参数 %0 具有 pass_object_size 属性'
# 'candidate constructor ignored: cannot be used to construct an object in address space %0'
H02A4FA176268: '候选构造函数被忽略：无法用于创建地址空间 %0 的对象'
# 'candidate disabled: %0'
H7028C3991AD2: '候选被禁用： %0'
# 'candidate found by name lookup is %q0'
H25F5CFEAA3CA: '名称查找找到的候选为 %q0'
# 'candidate function made ineligible by enable_if'
HF67E18BC374D: '候选函数因 enable_if 被排除'
# 'candidate function with non-reversed arguments'
H8514B0198804: '候选函数（参数顺序未反转）'
# 'candidate ignored: %select{not a function template|not a member of the enclosing %select{class template|namespace; did you mean to explicitly qualify the specialization?}1}0'
H46E51FE9BF5C: '候选被忽略：%select{非函数模板|非外围 %select{类模板|命名空间的成员；是否需要显式限定特化？}1}0'
# 'candidate template ignored: cannot deduce a type for %0 that would make %2 equal %1'
H7E4350C35AB8: '候选模板被忽略：无法推导 %0 的类型以使 %2 等同于 %1'
# 'candidate template ignored: constraints not satisfied%0'
H6E9C2A6AF9DA: '候选模板被忽略：约束条件不满足%0'
# 'candidate template ignored: could not match %diff{$ against $|types}0,1'
HBFC6A5130527: '候选模板被忽略：无法将 %diff{$ 与 $ 匹配|类型}0,1'
# 'candidate template ignored: could not match %q0 against %q1'
H95615A85BC94: '候选模板被忽略：无法将 %q0 与 %q1 匹配'
# "candidate template ignored: couldn't infer template argument %0"
H0865F809FC7F: '候选模板被忽略：无法推导模板参数 %0'
# 'candidate template ignored: deduced %select{conflicting types|conflicting values|conflicting templates|packs of different lengths}0 for parameter %1%diff{ ($ vs. $)|}2,3'
HC96827B6C1DA: '候选模板被忽略：推导出的%select{冲突的类型|冲突的值|冲突的模板|不同长度的包}0对于参数%1%diff{ ($ vs. $)|}2,3'
# 'candidate template ignored: deduced too few arguments for expanded pack %0; no argument for %ordinal1 expanded parameter in deduced argument pack %2'
HCCA72493BB47: '候选模板被忽略：推导出的扩展包%0参数数量不足；无法为第%ordinal1个扩展参数在推导出的参数包%2中找到对应的实参'
# 'candidate template ignored: deduced type %diff{$ of %select{|element of }4%ordinal0 parameter does not match adjusted type $ of %select{|element of }4argument|of %select{|element of }4%ordinal0 parameter does not match adjusted type of %select{|element of }4argument}1,2%3'
HF6006A393B95: '候选模板被忽略：推导出的类型%diff{$ of %select{|element of }4%ordinal0参数与调整后的类型$ of %select{|element of }4实参不匹配|of %select{|element of }4%ordinal0参数与调整后的%select{|element of }4实参类型不匹配}1,2%3'
# 'candidate template ignored: deduced values %diff{of conflicting types for parameter %0 (%1 of type $ vs. %3 of type $)|%1 and %3 of conflicting types for parameter %0}2,4'
H300B96CC7A66: '模板候选被忽略：推导值 %diff{为参数 %0 的类型冲突（%1 类型 $ 与 %3 类型 $）|参数 %0 的 %1 和 %3 类型冲突}2,4'
# 'candidate template ignored: disabled by %0%1'
H0A4EC193E9D6: '候选模板被忽略：被%0%1禁用'
# 'candidate template ignored: failed template argument deduction'
HF2D6EBE56EA1: '候选模板被忽略：模板实参推导失败'
# 'candidate template ignored: invalid explicitly-specified argument for %ordinal0 template parameter'
H7C80ECA5E832: '候选模板被忽略：为第%ordinal0个模板参数显式指定的实参无效'
# 'candidate template ignored: invalid explicitly-specified argument for template parameter %0'
HEDC828688F33: '候选模板被忽略：为模板参数%0显式指定的实参无效'
# "candidate template ignored: requirement '%0' was not satisfied%1"
HB155E3417C9D: '候选模板被忽略：要求‘%0’未满足%1'
# 'candidate template ignored: substitution exceeded maximum template instantiation depth'
H6065ACD0EE36: '候选模板被忽略：替换超过了模板实例化深度的最大值'
# 'candidate template ignored: substitution failure%0%1'
HF32FE861D856: '候选模板被忽略：替换失败%0%1'
# 'candidate template ignored: target attributes do not match'
H8F2E4648A7AB: '候选模板被忽略：目标属性不匹配'
# "cannot %select{#include files|import headers}0 inside '#pragma clang arc_cf_code_audited'"
HE8C6864AFFBD: "无法在'#pragma clang arc_cf_code_audited'内%select{包含文件|导入头文件}0"
# "cannot %select{#include files|import headers}0 inside '#pragma clang assume_nonnull'"
H5A02E21DB221: "无法在'#pragma clang assume_nonnull'内%select{包含文件|导入头文件}0"
# 'cannot %select{access base class of|access derived class of|access field of|access array element of|ERROR|access real component of|access imaginary component of}0 pointer past the end of object'
HBEBB0813D273: '无法%select{访问超出对象结尾的基类指针|访问超出对象结尾的派生类指针|访问超出对象结尾的字段|访问超出对象结尾的数组元素|ERROR|访问超出对象结尾的实部指针|访问超出对象结尾的虚部指针}0'
# 'cannot %select{access base class of|access derived class of|access field of|access array element of|perform pointer arithmetic on|access real component of|access imaginary component of}0 null pointer'
H2E784B2C1B28: '无法%select{访问空指针的基类|访问空指针的派生类|访问空指针的字段|访问空指针的数组元素|对空指针执行指针运算|访问空指针的实部|访问空指针的虚部}0'
# 'cannot %select{assign|return|throw|subscript}0 a WebAssembly table'
H1D574B1BA9C6: '无法%select{赋值|返回|抛出|下标访问}0 WebAssembly 表'
# 'cannot %select{capture|take address of}0 WebAssembly reference'
H1706BDA5F276: '无法%select{捕获|获取地址}0 WebAssembly 引用'
# 'cannot %select{decrement|increment}0 expression of enum type %1'
H9709AF91935B: '无法对枚举类型%1执行%select{递减|递增}0操作'
# 'cannot %select{decrement|increment}1 value of type %0'
H7C6ED23E2E9F: '无法对类型%0的%select{递减|递增}1值执行操作'
# 'cannot %select{form pointer to|form reference to|form array of|form function returning|use parentheses when declaring variable with}0 deduced class template specialization type'
HAF4CF818160D: '无法 %select{形成指向|形成引用指向|形成数组的|形成返回函数的|在声明变量时使用括号}0 推导的类模板特化类型'
# 'cannot %select{throw|catch}0 a WebAssembly reference type'
H3CB66A7D1B81: '无法 %select{抛出|捕获}0 WebAssembly 引用类型'
# "cannot %select{use builtin operator '<=>'|default 'operator<=>'}1 because type '%0' was not found; include <compare>"
H40A5A6DFAC87: "无法 %select{使用内置运算符 '<=>'|默认 'operator<=>' }1，因为类型 '%0' 未找到；请包含 <compare>"
# 'cannot %select{use type %1 for a function/method parameter|use type %1 for function/method return|default-initialize an object of type %1|declare an automatic variable of type %1|copy-initialize an object of type %1|assign to a variable of type %1|construct an automatic compound literal of type %1|capture a variable of type %1|cannot use volatile type %1 where it causes an lvalue-to-rvalue conversion}3 since it %select{contains|is}2 a union that is non-trivial to %select{default-initialize|destruct|copy}0'
H72F7777296D1: '无法 %select{使用类型 %1 作为函数/方法参数|使用类型 %1 作为函数/方法返回类型|默认初始化类型 %1 的对象|声明类型 %1 的自动变量|拷贝初始化类型 %1 的对象|将变量赋值为类型 %1|构造类型 %1 的自动复合字面量|捕获类型 %1 的变量|使用会导致左值转右值的易失性类型 %1}3，因为它 %select{包含|是}2 一个难以 %select{默认初始化|销毁|复制}0 的联合类型'
# 'cannot %select{||reinterpret_cast||C-style cast||}0 from member pointer type %1 to member pointer type %2 of different size'
H4DC29F600065: '无法%select{||reinterpret_cast||C-style cast||}0 将成员指针类型 %1 转换为不同大小的成员指针类型 %2'
# "cannot add 'abi_tag' attribute in a redeclaration"
H48F70104AB1E: '无法在重新声明中添加 "abi_tag" 属性'
# 'cannot add a default template argument to the definition of a member of a class template'
H770ED38EE4A2: '无法为类模板成员的定义添加默认模板实参'
# 'cannot allocate %select{function|reference}1 type %0 with new'
HA111D2195E5D: '无法使用 new 分配 %select{函数|引用}1 类型 %0'
# "cannot allocate array of 'auto'"
H63BE6FF3ACD1: "无法分配类型为 'auto' 的数组"
# "cannot allocate array; evaluated array bound %0 exceeds the limit (%1); use '-fconstexpr-steps' to increase this limit"
H786F30B07D61: "无法分配数组；计算得到的数组边界 %0 超过限制（%1）；使用 '-fconstexpr-steps' 增加该限制"
# 'cannot allocate array; evaluated array bound %0 is negative'
H5D0D0D0008CA: '无法分配数组；计算得到的数组边界 %0 为负数'
# 'cannot allocate array; evaluated array bound %0 is too large'
H7762F6A6D3EC: '无法分配数组；计算得到的数组边界 %0 过大'
# 'cannot allocate array; evaluated array bound %0 is too small to hold %1 explicitly initialized elements'
H33075FED0F6C: '无法分配数组；计算得到的数组边界 %0 过小，无法容纳 %1 显式初始化的元素'
# 'cannot allocate memory of %select{incomplete|function}0 type %1'
H1CE3476A2AA9: '无法分配 %select{不完整|函数}0 类型 %1 的内存'
# "cannot allocate untyped memory in a constant expression; use 'std::allocator<T>::allocate' to allocate memory of type 'T'"
H659085361859: "无法在常量表达式中分配未指定类型的内存；使用 'std::allocator<T>::allocate' 来分配类型 'T' 的内存"
# "cannot apply AST actions to LLVM IR file '%0'"
HB65858D558EB: '无法对 LLVM IR 文件 "%0" 应用 AST 操作'
# 'cannot apply asm label to %select{variable|function}0 after its first use'
H75A6849C042D: '无法在首次使用后为 %select{变量|函数}0 应用汇编标签'
# "cannot assign to 'self' in a class method"
HA56E4ED9D1F5: "无法在类方法中为 'self' 赋值"
# "cannot assign to 'self' outside of a method in the init family"
HC5091C795252: "无法在 init 方法族外为 'self' 赋值"
# 'cannot assign to a variable captured by copy in a non-mutable lambda'
H135A3A08A93B: '无法将复制捕获的变量赋值给非可变的 lambda 中的变量'
# 'cannot assign to class object (%0 invalid)'
H25AF70C115F7: '无法将类对象赋值（%0 无效）'
# "cannot assign to this %select{dictionary|array}1 because assigning method's 2nd parameter of type %0 is not an Objective-C pointer type"
H33D10E761543: '无法将 this %select{字典|数组}1 赋值，因为类型为%0 的第二个参数不是 Objective-C 指针类型'
# 'cannot befriend target of using declaration'
H72752EB56616: '无法与 using 声明的目标建立友元关系'
# 'cannot bind non-lvalue argument %0 to %select{|in}1out paramemter'
HD7C1DD47E42B: '无法将非左值参数 %0 绑定到 %select{|in}1 out 参数'
# 'cannot build range expression with array function parameter %0 since parameter with array type %1 is treated as pointer type %2'
H882392B5B8E6: '无法使用数组类型参数 %1 的函数参数 %0 构建范围表达式，因为数组类型参数会被视为指针类型 %2'
# "cannot call function '%1' while %0 '%2' is held"
HE0B68C2EF3F0: '在持有 %0 %2 期间无法调用函数 %1'
# 'cannot call operator __uuidof on a type with multiple GUIDs'
H6DB6EE36C688: '无法对具有多个 GUID 的类型调用 __uuidof 运算符'
# 'cannot call operator __uuidof on a type with no GUID'
HCAE7CA56FF69: '无法对没有 GUID 的类型调用 __uuidof 运算符'
# 'cannot capture __autoreleasing variable in a %select{block|lambda by copy}0'
H9DA2D963C91D: '无法在 %select{block|lambda by copy}0 中捕获 __autoreleasing 变量'
# 'cannot cast %0 to %1 via virtual base %2'
H794ABE3B9398: '无法通过虚基类 %2 将 %0 转换为 %1'
# 'cannot cast %0 to its %select{private|protected}2 base class %1'
H7E4D1C189883: '无法将 %0 转换为其 %select{私有|保护}2 基类 %1'
# 'cannot cast %select{private|protected}2 base class %1 to %0'
HEB1FE12D1532: '无法将 %select{私有|保护}2 基类 %1 转换为 %0'
# 'cannot cast %select{to|from}0 a WebAssembly table'
H608D936A86AA: '无法将 %select{到|从}0 WebAssembly 表进行转换'
# "cannot cast 'super' (it isn't an expression)"
H77DA1D89D4EF: "无法转换 'super'（它不是一个表达式）"
# "cannot cast an object of type %select{'nullptr_t' to %1|%1 to 'nullptr_t'}0"
H379020AFC623: '无法将类型 %select{nullptr_t 转换为 %1|%1 转换为 nullptr_t}0'
# 'cannot cast from lvalue of type %1 to rvalue reference type %2; types are not compatible'
HD498E8671ADF: '无法将类型 %1 的左值转换为右值引用类型 %2；类型不兼容'
# 'cannot cast from rvalue of type %1 to rvalue reference type %2; types are not compatible'
H81F8D1E74E50: '无法将类型 %1 的右值转换为右值引用类型 %2；类型不兼容'
# 'cannot cast from type %1 to member pointer type %2'
HC0F42A4D9625: '无法将类型 %1 转换为成员指针类型 %2'
# 'cannot cast from type %1 to pointer type %2'
H1C20AF9781FF: '无法将类型 %1 转换为指针类型 %2'
# "cannot cast non-zero value '%0' to 'event_t'"
HB63F6FC3F823: "无法将非零值 '%0' 转换为 'event_t'"
# 'cannot cast object of dynamic type %0 to type %1'
H29A99B2195B9: '无法将动态类型为%0的对象转换为类型%1'
# 'cannot catch %select{|reference to }0sizeless type %1'
HFDB51E9BFE05: '不能捕获%select{|引用到}0大小不明确的类型%1'
# 'cannot catch an Objective-C object by value'
HE53524ADBBC8: '不能按值捕获Objective-C对象'
# 'cannot catch an exception thrown with @throw in C++ in the non-unified exception model'
HA5FD18981E9C: '在非统一异常模型中，无法捕获通过C++中@throw抛出的异常'
# 'cannot catch exceptions by rvalue reference'
H5BF423F821AB: '不能通过右值引用捕获异常'
# 'cannot catch incomplete type %0'
H712DCF7BC1DF: '不能捕获不完整类型%0'
# 'cannot catch pointer to incomplete type %0'
H555C8CE71019: '不能捕获指向不完整类型%0的指针'
# 'cannot catch reference to incomplete type %0'
HAB26C8BE4E6D: '不能捕获不完整类型%0的引用'
# 'cannot catch variably modified type %0'
H3E0D097A06D0: '不能捕获变长修饰类型%0'
# 'cannot combine GNU and %select{SVE|RVV}0 vectors in expression, result is ambiguous (%1 and %2)'
H6D9DAA9A57DC: '无法在表达式中同时使用GNU和%select{SVE|RVV}0向量，结果不明确（%1和%2）'
# 'cannot combine fixed-length and sizeless %select{SVE|RVV}0 vectors in expression, result is ambiguous (%1 and %2)'
H3EDDFBE7A4DF: '无法在表达式中同时使用固定长度和大小不明确的%select{SVE|RVV}0向量，结果不明确（%1和%2）'
# "cannot combine with previous '%0' declaration specifier"
H4EE2F7A93C38: "无法与之前的'%0'声明说明符合并"
# "cannot combine with previous '%0' declaration specifier. '__vector' must be first"
H856686567DB2: "无法与之前的'%0'声明说明符合并。'__vector'必须放在首位"
# 'cannot compile this %0 yet'
H395022428A23: '当前无法编译此%0'
# 'cannot compress debug sections (%0 not enabled)'
HB2DFAB48BA84: '无法压缩调试部分（%0未启用）'
# 'cannot compute offset of bit-field %0'
H55C2FB73C827: '无法计算位字段%0的偏移量'
# "cannot constant evaluate '%select{memcpy|memmove}0' between objects of incomplete type %1"
H474B41288CFB: '无法常量评估类型%1的不完全类型之间的%select{memcpy|memmove}0结果'
# "cannot constant evaluate '%select{memcpy|memmove}0' between objects of non-trivially-copyable type %1"
H4AA44A4233D2: '无法常量评估非平凡复制类型的%1之间的%select{memcpy|memmove}0结果'
# "cannot constant evaluate '%select{memcpy|memmove}0' from object of type %1 to object of type %2"
H6FAB8AA1F441: '无法常量评估从类型%1到类型%2的%select{memcpy|memmove}0结果'
# 'cannot constant evaluate the result of adjusting alignment to %0'
H8F0F0485C85D: '无法计算将对齐方式调整到%0后的结果'
# 'cannot constant evaluate whether run-time alignment is at least %0'
H8DC5B278E189: '无法在常量表达式中确定运行时对齐是否至少为%0'
# 'cannot construct object of type %0 with virtual base class in a constant expression'
H7DD1FDBBEF06: '无法在常量表达式中构造包含虚基类的%0类型的对象'
# 'cannot convert %0 token to an identifier'
H18B9F6746EBF: '无法将%0标记转换为标识符'
# 'cannot convert %1 to %2 without a conversion operator'
H703415593D2A: '无法在没有转换运算符的情况下将%1转换为%2'
# 'cannot convert between %select{scalar|vector}0 type %1 and vector type %2 as implicit conversion would cause truncation'
HF046F296A9B0: '无法在隐式转换会导致截断的情况下在%select{标量|向量}0类型%1和向量类型%2之间进行转换'
# 'cannot convert between vector and non-scalar values (%0 and %1)'
HD81F5D7E2B16: '无法在向量类型和非标量类型之间（%0和%1）进行转换'
# 'cannot convert between vector values of different size (%0 and %1)'
H8810EF643AA5: '无法在不同大小的向量值之间进行转换（%0和%1）'
# 'cannot create __weak reference because the current deployment target does not support weak references'
H54D605FEB00B: '无法创建__weak引用，因为当前部署目标不支持弱引用'
# 'cannot create __weak reference in file using manual reference counting'
H98AD8AE899EB: '无法在使用手动引用计数的文件中创建__weak引用'
# 'cannot create a non-constant pointer to member function'
H909CEC9754E8: '无法创建非常量的成员函数指针'
# 'cannot create includes file for module %0: %1'
H521EA5757B62: '无法为模块%0创建包含文件：%1'
# 'cannot create object of function type %0'
HB6BCDD252F4D: '无法声明无名称的类模板%0'
# 'cannot declare a class template with no name'
H86275B9FD8C9: '无法在友元中声明显式特例化'
# 'cannot declare an explicit specialization in a friend'
H8E19851C2991: '不能在 friend 中声明显式特化'
# 'cannot declare class extension for %0 after class implementation'
H472ADAE23CEA: '类实现后不能为 %0 声明类扩展'
# "cannot declare implementation of a class declared with the 'objc_class_stub' attribute"
H831B35F688CB: '无法将命名空间"std"声明为内联'
# "cannot declare the namespace 'std' to be inline"
H1345EF64CB88: '无法在@interface或@protocol内声明变量'
# 'cannot declare variable inside @interface or @protocol'
H11D626BF5B37: '不能在 @interface 或 @protocol 中声明变量'
# 'cannot decompose %select{private|protected}0 member %1 of %3'
HAF5B2F15564E: '不能分解 %select{私有|受保护}0 成员 %1 的 %3'
# 'cannot decompose %select{union|non-class, non-array}1 type %2'
HD213477C2A3A: '无法分解%select{联合体|非类、非数组}1类型%2'
# 'cannot decompose class type %0 because it has an anonymous %select{struct|union}1 member'
H687FA194A579: '无法分解类类型%0，因为它包含匿名%select{结构体|联合体}1成员'
# 'cannot decompose class type %1: %select{its base classes %2 and|both it and its base class}0 %3 have non-static data members'
HBC0288C04290: '不能分解类类型 %1：%select{其基类 %2 和|该类及其基类}0 %3 有非静态数据成员'
# 'cannot decompose lambda closure type'
H3C6B1EAC26ED: '无法分解lambda闭包类型'
# 'cannot decompose members of ambiguous base class %1 of %0:%2'
HE08DBE349649: '无法分解%0的二义性基类%1的成员：%2'
# 'cannot decompose members of inaccessible base class %1 of %0'
HA6ED46C6B298: '无法分解%0的不可访问基类%1的成员'
# "cannot decompose this type; 'std::tuple_element<%0>::type' does not name a type"
H4AD140BFCF3D: "无法分解此类型；'std::tuple_element<%0>::type'不是一个类型名称"
# "cannot decompose this type; 'std::tuple_size<%0>::value' is not a valid integral constant expression"
HE140F3EE6033: "无法分解此类型；'std::tuple_size<%0>::value'不是一个有效的整数常量表达式"
# 'cannot decrement expression of type bool'
H9DABD4A4074A: '不能递减类型为bool的表达式'
# "cannot deduce 'decltype(auto)' from initializer list"
H0294CF60338E: "无法从初始化列表推导'decltype(auto)'类型"
# 'cannot deduce actual type for %1 from %select{parenthesized|nested}0 initializer list'
H1C99EC9B7047: '无法从%select{括号包围的|嵌套}0初始化列表推导%1的实际类型'
# 'cannot deduce actual type for variable %0 with type %1 from initializer list'
HA7FCCDD3352E: '无法从初始化列表推导变量%0（类型%1）的实际类型'
# 'cannot deduce implicit triple value for -Xopenmp-target, specify triple using -Xopenmp-target=<triple>'
HBB4FDAD01556: '无法推导-Xopenmp-target的隐式目标三元组值，请使用-Xopenmp-target=<triple>指定三元组'
# 'cannot deduce lambda return type from initializer list'
HBF4499B07FAC: '无法从初始化列表推导lambda返回类型'
# 'cannot deduce return type %0 for function with no return statements'
H4A0B0541DA05: '无法为无return语句的函数推导返回类型%0'
# 'cannot deduce return type %0 from omitted return expression'
HF76745F04CDD: '无法从省略的返回表达式推导返回类型%0'
# 'cannot deduce return type %0 from returned value of type %1'
HFF6A0873771C: '无法从类型%1的返回值推导返回类型%0'
# 'cannot deduce return type from initializer list'
HD33E533A8026: '无法从初始化列表推导返回类型'
# 'cannot deduce template arguments for %0 from %1'
H59FFC4EE513D: '无法为%0从%1推导模板参数'
# 'cannot deduce type for lambda capture %0 from initializer list'
HD1B46B897454: '无法从初始化列表推导lambda捕获%0的类型'
# 'cannot deduce type for lambda capture %0 from initializer of type %2'
H5BED86131FDB: '无法推导类型%0的lambda捕获类型，因为初始化器的类型为%2'
# 'cannot deduce type for lambda capture %1 from %select{parenthesized|nested}0 initializer list'
HBAF719ACD121: '无法从%select{括号|嵌套}0初始化列表推导lambda捕获%1的类型'
# 'cannot deduce type for variable %1 with type %2 from %select{parenthesized|nested}0 initializer list'
HDBF6BFDD94D3: '无法从%select{括号|嵌套}0初始化列表推导类型%2的变量%1'
# 'cannot deduce type of initializer list because std::initializer_list was not found; include <initializer_list>'
H61AB50323785: '无法推导初始化列表类型，因为未找到std::initializer_list；请包含<initializer_list>'
# 'cannot define %select{category|class extension}0 for undefined class %1'
H075CA56C0949: '无法为未定义的类%1定义%select{分类|类扩展}0'
# 'cannot define a type in a friend declaration'
H90F602DED3B4: '无法在友元声明中定义类型'
# 'cannot define friend function %0 in a local class definition; did you mean %3?'
H40B3F3B5FBB1: '无法在本地类定义中声明友元函数%0；是否应改为%3？'
# 'cannot define friend function in a local class definition'
HB60D03F3A5C5: '无法在本地类定义中声明友元函数'
# 'cannot define non-inline dllimport template specialization'
HF67617A49B06: '无法定义非内联dllimport模板特化'
# 'cannot define or redeclare %0 here because namespace %1 does not enclose namespace %2'
HFA38E82744C2: '无法在此处定义或重新声明%0，因为命名空间%1不包含命名空间%2'
# 'cannot define the implicit copy assignment operator for %0, because non-static %select{reference|const}1 member %2 cannot use copy assignment operator'
H50812469123A: '无法为%0推导隐式拷贝赋值运算符，因为非静态%select{引用|const}1成员%2无法使用拷贝赋值运算符'
# 'cannot delete expression of type %0'
H8F9B57A837EE: '无法删除类型%0的表达式'
# "cannot delete expression with pointer-to-'void' type %0"
HCCFA093E9DE2: "无法删除类型%0的指向'void'指针表达式"
# 'cannot delete pointer to incomplete type %0'
H7E32F7F5C2AD: '无法删除指向不完整类型%0的指针'
# "cannot determine %0 architecture: %1; consider passing it via '%2'; environment variable CLANG_TOOLCHAIN_PROGRAM_TIMEOUT specifies the tool timeout (integer secs, <=0 is infinite)"
H9E1578DA83DB: '无法确定%0架构：%1；建议通过参数"%2"传递；环境变量CLANG_TOOLCHAIN_PROGRAM_TIMEOUT指定工具超时时间（整数秒，≤0表示无限）'
# 'cannot determine allocated array size from initializer'
H3573086C6F39: '无法从初始化器确定分配数组的大小'
# 'cannot determine number of elements for sizeless vectors in a constant expression'
HAFC6AFA63009: '无法在常量表达式中确定无大小向量的元素数量'
# 'cannot determine underlying type of incomplete enumeration type %0'
H486DE8FE7D9E: '无法获取不完整枚举类型%0的底层类型'
# 'cannot emit module %0: %select{size|mtime}1 must be explicitly specified for missing header file "%2"'
H4AFEE6C7D624: '无法生成模块%0：%select{大小|修改时间}1必须显式指定缺失头文件"%2"'
# 'cannot evaluate call to virtual function in a constant expression in C++ standards before C++20'
HC06FC1196550: 'C++20之前的C++标准中无法在常量表达式中求值虚拟函数调用'
# 'cannot evaluate this expression if rounding mode is dynamic'
HC673B661CF5A: '如果舍入模式是动态的，则无法求值此表达式'
# 'cannot export %0 as it is not at namespace scope'
H49EEB2061C19: '无法导出%0，因为它不在命名空间作用域中'
# 'cannot export redeclaration %0 here since the previous declaration %select{is not exported|has internal linkage|has module linkage}1'
H805545AFF107: '由于之前的声明%select{未导出|具有内部链接性|具有模块链接性}1，因此无法在此处导出%0的重新声明'
# "cannot find CUDA installation; provide its path via '--cuda-path', or pass '-nocudainc' to build without CUDA includes"
H483DC86F4594: "无法找到CUDA安装路径；请通过'--cuda-path'提供其路径，或使用'-nocudainc'选项不包含CUDA头文件进行编译"
# "cannot find HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-path'"
H20ABDE201926: "无法找到HIP标准并行加速库；请通过'--hipstdpar-path'提供其路径"
# "cannot find HIP device library%select{| for %1}0; provide its path via '--hip-path' or '--hip-device-lib-path', or pass '-nogpulib' to build without HIP device library"
H74B6BE24033A: "无法找到HIP设备库%select{|用于%1}0；请通过'--hip-path'或'--hip-device-lib-path'提供其路径，或使用'-nogpulib'选项不链接HIP设备库进行编译"
# "cannot find HIP runtime; provide its path via '--rocm-path', or pass '-nogpuinc' to build without HIP runtime"
H11EBFA045BE3: "无法找到HIP运行时；请通过'--rocm-path'提供其路径，或使用'-nogpuinc'选项不包含HIP运行时进行编译"
# "cannot find ROCm device library%select{| for %1| for ABI version %1}0; provide its path via '--rocm-path' or '--rocm-device-lib-path', or pass '-nogpulib' to build without ROCm device library"
H7B7F4A357272: "无法找到ROCm设备库%select{|用于%1|用于ABI版本%1}0；请通过'--rocm-path'或'--rocm-device-lib-path'提供其路径，或使用'-nogpulib'选项不链接ROCm设备库进行编译"
# 'cannot find a valid user-defined mapper for type %0 with name %1'
H0907A5973C27: '未找到类型%0且名称为%1的有效用户自定义映射器'
# "cannot find end ('%1') of expected %0"
H53A2AE90D9C0: "无法找到预期的%0的结束符'%1'"
# 'cannot find interface declaration for %0'
H7325D139C40F: '未找到%0的接口声明'
# 'cannot find interface declaration for %0, superclass of %1'
HDDF90FE7BE8F: '未找到%0的接口声明（%1的基类）'
# 'cannot find interface declaration for %0, superclass of %1; did you mean %2?'
H691319D1E232: '未找到%0的接口声明（%1的基类）；是否是指%2？'
# 'cannot find interface declaration for %0; did you mean %1?'
H3FD5BD5869C6: '未找到%0的接口声明；是否是指%1？'
# "cannot find libdevice for %0; provide path to different CUDA installation via '--cuda-path', or pass '-nocudalib' to build without linking with libdevice"
H9C8FBD27D916: "无法找到%0的libdevice；请通过'--cuda-path'提供其他CUDA安装路径，或使用'-nocudalib'选项不链接libdevice进行编译"
# 'cannot find protocol declaration for %0'
H8559765777E9: '未找到%0的协议声明'
# 'cannot find protocol declaration for %0; did you mean %1?'
H39967D7F0C23: '未找到%0的协议声明；是否是指%1？'
# 'cannot find protocol definition for %0'
H30EC809C2E8C: '未找到%0的协议定义'
# "cannot find re-exported %select{framework|library}0: '%1'"
HFF74F7CAAAC8: "无法找到导出的%select{框架|库}0：'%1'"
# "cannot find rocPrim, which is required by the HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-prim-path'"
H7420A8DBF79F: "无法找到由HIP标准并行加速库所需的rocPrim；请通过'--hipstdpar-prim-path'提供其路径"
# "cannot find rocThrust, which is required by the HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-thrust-path'"
HF20DC196E1CB: "找不到rocThrust，这是HIP标准并行加速库所必需的；请通过'--hipstdpar-thrust-path'提供它"
# "cannot find start ('{{') of expected %0"
H727EB43115FC: "找不到预期的%0的起始符（'{{'）"
# "cannot find start of regex ('{{') in %0"
HD5BDA70A3617: "在%0中找不到正则表达式的起始符（'{{'）"
# 'cannot find suitable %select{getter|setter}0 for property %1'
H0F811370E791: '找不到适合属性%1的%select{getter|setter}0'
# "cannot form %select{pointer to|reference to|array of}0 'decltype(auto)'"
H7F41F0A9CCC7: "无法形成%select{指向|引用|数组}0 'decltype(auto)'"
# 'cannot form a %select{pointer|reference}0 to a WebAssembly table'
H3C39E76E28BC: '无法形成指向WebAssembly表的%select{指针|引用}0'
# 'cannot form a pointer-to-member to member %0 of reference type %1'
H45A1DB7A6AF3: '无法形成引用类型%1的成员%0的成员指针'
# "cannot form a reference to 'void'"
H6E82068C4FE4: "无法形成对'void'的引用"
# "cannot form member pointer of type %0 without '&' and class name"
HA98A1BC7CEC4: "无法在没有'&'和类名的情况下形成类型%0的成员指针"
# 'cannot generate code for reduction on %select{|array section, which requires a }0variable length array'
H328E15AAC013: '无法为%select{|数组段，需要一个}0变长数组生成代码'
# 'cannot have both throw() and noexcept() clause on the same function'
H93A58AAAE480: '同一个函数不能同时使用throw()和noexcept()子句'
# 'cannot implement a category for class %0 that is only visible via the Objective-C runtime'
H93EA111FC5EC: '无法为仅通过Objective-C运行时可见的类%0实现类别'
# 'cannot implement subclass %0 of a superclass %1 that is only visible via the Objective-C runtime'
H0C79ADD5940E: '无法为仅通过Objective-C运行时可见的超类%1实现子类%0'
# 'cannot import unsupported AST node %0'
H4E75F3A5019B: '无法导入不受支持的AST节点%0'
# 'cannot initialize %select{a variable|a parameter|template parameter|return object|statement expression result|an exception object|a member subobject|an array element|a new value|a value|a base class|a constructor delegation|a vector element|a block element|a block element|a complex element|a lambda capture|a compound literal initializer|a related result|a parameter of CF audited function|a structured binding|a member subobject}0 %diff{of type $ with an %select{rvalue|lvalue}2 of type $|with an %select{rvalue|lvalue}2 of incompatible type}1,3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4'
H5225AD7ABD6B: '无法初始化 %select{变量|参数|模板参数|返回对象|表达式结果|异常对象|成员子对象|数组元素|新值|值|基类|构造函数委托|向量元素|块元素|块元素|复数元素|lambda 捕获|复合字面量初始化器|相关结果|CF 审计函数参数|结构化绑定|成员子对象}0 %diff{类型为 $ 的 %select{右值|左值}2 类型 $|与类型不兼容的 %select{右值|左值}2}1,3%select{|：不同类%diff{ ($ vs $)|}5,6|：参数数量不同（%5 vs %6）|：第 %ordinal5 参数类型不同%diff{ ($ vs $)|}6,7|：返回类型不同%diff{ ($ vs $)|}5,6|：限定符不同（%5 vs %6）|：异常说明不同}4'
# 'cannot initialize %select{non-class|reference}0 type %1 with a parenthesized initializer list'
HE63727C8C08B: '无法用括号括起的初始化列表初始化%select{非类|引用}0类型%1'
# 'cannot initialize Objective-C class type %0'
HA709360A8ABC: '无法初始化Objective-C类类型%0'
# 'cannot initialize array %diff{of type $ with array of type $|with different type of array}0,1'
HA759EFFA1CC7: '无法初始化数组 %diff{类型 $ 与类型 $ 的数组|数组类型不同}0,1'
# 'cannot initialize array %diff{of type $ with non-constant array of type $|with different type of array}0,1'
HAEED299DACD1: '不能用不同类型数组初始化 %diff{类型 $ 的数组与非常量数组类型 $|不同类型的数组}0,1'
# 'cannot initialize object parameter of type %0 with an expression of type %1'
H01F0C7FE2242: '无法用类型%1的表达式初始化类型%0的对象参数'
# 'cannot instantiate %0 yet'
H3C23130222AC: '无法实例化%0'
# 'cannot jump from switch statement to this case label'
H0147E81C1C5E: '无法从switch语句跳转到此case标签'
# 'cannot jump from this %select{indirect|asm}0 goto statement to one of its possible targets'
HA7FDD21785F4: '无法从此%select{间接|汇编}0 goto语句跳转到其可能的目标之一'
# 'cannot jump from this continue statement to the loop increment; jump bypasses initialization of loop condition variable'
HF65BBB33CB19: '无法从此continue语句跳转到循环增量；跳转绕过了循环条件变量的初始化'
# 'cannot jump from this goto statement to its label'
HF7AC509BA0D6: '无法从此goto语句跳转到其标签'
# 'cannot jump from this goto statement to label %0 inside an inline assembly block'
HBD667F79ECB9: '无法从此goto语句跳转到内联汇编块内的标签%0'
# "cannot link module '%0': %1"
H957779E89D24: "无法链接模块'%0'：%1"
# 'cannot locate code-completion file %0'
H00AA0E96170A: '无法定位代码补全文件%0'
# 'cannot mangle fixed point literals yet'
H175F8CE0FB1D: '无法对定点字面量进行名称修饰'
# 'cannot mangle this %0 %1 yet'
H50F33B0E4B4E: '无法对此%0 %1进行名称修饰'
# 'cannot mangle this %0 yet'
H1C98A95C714E: '无法对此%0进行名称修饰'
# 'cannot mangle this dependent fixed-length RVV vector type yet'
H01F50B3350B7: '无法对依赖的固定长度RVV向量类型进行名称修饰'
# 'cannot mangle this dependent fixed-length SVE vector type yet'
H53C22EA00769: '无法对依赖的固定长度SVE向量类型进行名称修饰'
# 'cannot mangle this dependent neon vector type yet'
H566B620CDB5E: '无法对依赖的NEON向量类型进行名称修饰'
# 'cannot mangle this requires-expression containing a substitution failure'
H9EEE8BF3FF53: '无法对包含替代失败的requires表达式进行名称修饰'
# 'cannot mangle this unnamed union NTTP yet'
HC67F1942B567: '无法对此未命名的联合NTTP进行名称修饰'
# 'cannot mix packoffset elements with nonpackoffset elements in a cbuffer'
H5F5AED65EDDB: 'cbuffer中不能混合packoffset元素与非packoffset元素'
# 'cannot mix positional and non-positional arguments in format string'
HC2203B0385F9: '格式字符串中不能同时使用位置参数和非位置参数'
# 'cannot mix vectors and extended vectors in a vector conditional'
H0C69F5DF40B4: '向量条件中不能同时使用向量和扩展向量'
# "cannot nest 'critical' regions having the same name %0"
HB0FDA4DB5B6B: "不能嵌套具有相同名称%0的'critical'区域"
# "cannot open file '%0': %1"
H7B318395BD4F: '无法打开文件“%0”：%1'
# "cannot overload a member function %select{without a ref-qualifier|with ref-qualifier '&'|with ref-qualifier '&&'}0 with a member function %select{without a ref-qualifier|with ref-qualifier '&'|with ref-qualifier '&&'}1"
H3E720DF8A96F: "不能用 %select{无 ref-qualifier 成员函数|具有 ref-qualifier '&' 的成员函数|具有 ref-qualifier '&&' 的成员函数}0 重载 %select{无 ref-qualifier 成员函数|具有 ref-qualifier '&' 的成员函数|具有 ref-qualifier '&&' 的成员函数}1"
# 'cannot override a method that is declared direct by a superclass'
H8D083337F734: '不能覆盖由超类直接声明的方法'
# 'cannot parenthesize the name of a method when forming a member pointer'
H733C76C89DE9: '不能在形成成员指针时对方法的名称加括号'
# 'cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2'
H25763FEA732A: '不能将%select{类型%1的表达式|初始化列表}0传递给可变参数%select{函数|块|方法|构造函数}2'
# 'cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
H6A81C62CC358: '不能将%select{类型%1的表达式|初始化列表}0传递给可变参数%select{函数|块|方法|构造函数}2；格式字符串预期类型为%3'
# 'cannot pass %select{non-POD|non-trivial}0 object of type %1 to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
HB3C416B2C325: '不能将%select{非POD|非平凡}0类型的%1对象传递给可变参数%select{函数|块|方法|构造函数}2；格式字符串预期类型为%3'
# 'cannot pass a pointer-to-member through register-constrained inline assembly parameter'
H1A2FFC7DC3D0: '不能通过寄存器约束的内联汇编参数传递成员指针'
# 'cannot pass bit-field as __auto_type initializer in C'
HC2EE224C8229: '不能在C中将位域作为__auto_type初始化器'
# 'cannot pass non-trivial C object of type %0 by value to variadic %select{function|block|method|constructor}1'
H2C5461696894: '不能通过值传递非平凡C类型%0的对象给可变参数%select{函数|块|方法|构造函数}1'
# 'cannot pass object of %select{non-POD|non-trivial}0 type %1 through variadic %select{function|block|method|constructor}2; call will abort at runtime'
H03C685EEC43F: '不能将%select{非POD|非平凡}0类型%1对象传递给可变参数%select{函数|块|方法|构造函数}2；调用将在运行时终止'
# 'cannot pass object with interface type %0 by value through variadic %select{function|block|method|constructor}1'
HFFB4BE108833: '不能通过值传递具有接口类型%0的对象给可变参数%select{函数|块|方法|构造函数}1'
# 'cannot pass object with interface type %1 by value to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
HFCF01B48F1C2: '不能通过值将具有接口类型%1的对象传递给可变参数%select{函数|块|方法|构造函数}2；格式字符串预期类型为%3'
# "cannot pass undiscriminated type %0 to '__builtin_ptrauth_type_discriminator'"
HCF5D52D0F4BA: "无法将未区分的类型%0传递给'__builtin_ptrauth_type_discriminator'"
# 'cannot perform a tail call %select{from|to}0 a %select{constructor|destructor}1'
H92D6BE5E0D10: '无法在%select{从|到}0%select{构造函数|析构函数}1执行尾调用'
# 'cannot perform a tail call from this return statement'
HD566EFBB0F10: '无法从此返回语句执行尾调用'
# 'cannot perform a tail call to function%select{| %1}0 because it uses an incompatible calling convention'
H32E425482ACE: '无法对%select{| %1}0函数执行尾调用，因为它使用了不兼容的调用约定'
# 'cannot perform a tail call to function%select{| %1}0 because its signature is incompatible with the calling function'
HB6791E3481C6: '无法对%select{| %1}0函数执行尾调用，因为其签名与调用函数不兼容'
# 'cannot perform atomic operation on a pointer to type %0: type has non-trivial ownership'
H33A9E57472E9: '无法对类型%0的指针执行原子操作：该类型具有非平凡所有权'
# "cannot read configuration file '%0': %1"
H0AF7279B0969: '无法读取配置文件“%0”：%1'
# "cannot read randomize layout seed file '%0'"
H97BBD89360BC: "无法读取随机化布局种子文件'%0'"
# "cannot rebuild module '%0' as it is already finalized"
H80C2AA3A79E5: "无法重新构建模块'%0'，因为它已被最终确定"
# 'cannot redeclare builtin function %0'
HC3E811B65243: '不能重新声明内置函数%0'
# 'cannot refer to a block inside block'
HEC4D55F7E1FA: '不能在代码块内引用该代码块内部'
# 'cannot refer to a non-static member from the handler of a %select{constructor|destructor}0 function try block'
H7C221E1899F1: '不能在%select{构造函数|析构函数}0的try块处理程序中引用非静态成员'
# 'cannot refer to declaration of structure variable with flexible array member inside block'
H861E195F8EA8: '不能在代码块内引用带有可变长度数组成员的结构体变量的声明'
# 'cannot refer to declaration with a variably modified type inside block'
H3ACCC42BDE35: '不能在代码块内引用具有变长类型声明的变量'
# 'cannot refer to declaration with an array type inside block'
HBA9381EF3C23: '不能在代码块内引用具有数组类型的声明'
# 'cannot refer to element %0 of %select{array of %2 element%plural{1:|:s}2|non-array object}1 in a constant expression'
H97B7B294ED7C: '不能在常量表达式中引用%select{包含%2元素的数组%plural{1:|:s}2|非数组对象}1的元素%0'
# "cannot refer to member %0 in %1 with '%select{.|->}2'"
HF25CD96D4723: "无法使用'%select{.|->}2'在%1中引用成员%0"
# "cannot refer to type member %0 in %1 with '%select{.|->}2'"
H982BCA02E9FD: "无法使用'%select{.|->}2'在%1中引用类型成员%0"
# 'cannot reference member of primary template because deduced class template specialization %0 is %select{instantiated from a partial|an explicit}1 specialization'
HF04074EDD691: '无法引用主模板的成员，因为推导出的类模板特化%0是%select{部分特化|显式}1的特化'
# 'cannot resolve lock expression'
H9831838AB057: '无法解析锁表达式'
# 'cannot return from %0'
HDE7181BDC39D: '不能从%0返回'
# 'cannot set vtable pointer authentication on %0 which is a subclass of polymorphic type %1'
H8615F820D27E: '不能为多态类型%1的子类%0设置虚表指针认证'
# 'cannot set vtable pointer authentication on an incomplete type %0'
H50389542B8AD: '不能为不完全类型%0设置虚表指针认证'
# 'cannot set vtable pointer authentication on monomorphic type %0'
H365AD22227CA: '不能为单态类型%0设置虚表指针认证'
# "cannot specialize %select{|(with 'template<>') }0a member of an unspecialized template"
H21C951459621: "不能特化未特化的模板成员%select{|(使用'template<>' )}0"
# 'cannot specialize a %select{dependent template|template template parameter}0'
HC5BFF931F55D: '不能特化%select{依赖模板|模板模板参数}0'
# "cannot specify '%0%1' when compiling multiple source files"
HFD3172559132: "在编译多个源文件时不能指定'%0%1'"
# "cannot specify '%1' along with '%0'"
H9F94923DAC7E: "不能同时指定 '%1' 和 '%0'"
# 'cannot specify -o when generating multiple output files'
HE249C344BFD2: '生成多个输出文件时不能指定 -o'
# 'cannot specify a default vtable pointer authentication %select{key|address discrimination mode|discriminator}0 with no default set'
H3A1B9264D760: '未设置默认值时无法指定默认 vtable 指针验证 %select{密钥|地址鉴别模式|鉴别符}0'
# "cannot specify any part of a return type in the declaration of a conversion function%select{; put the complete type after 'operator'|; use a typedef to declare a conversion to %1|; use an alias template to declare a conversion to %1|}0"
HAA40A3FFF9F4: "在转换函数声明中不能指定返回类型的任何部分%select{; 在 'operator' 后面写出完整类型|; 使用 typedef 声明向 %1 的转换|; 使用别名模板声明向 %1 的转换|}0"
# 'cannot specify any part of a return type in the declaration of a deduction guide'
H390B6E7B14DB: '在推导指引的声明中不能指定返回类型的任何部分'
# 'cannot specify deduction guide for %select{<error>|function template|variable template|alias template|template template parameter|concept|dependent template name}0 %1'
H8A234F5E78B1: '无法为 %select{<error>|函数模板|变量模板|别名模板|模板模板参数|概念|依赖模板名称}0 %1 指定推导指引'
# "cannot specify parameter '%0' twice in the same '#embed' directive"
HD1DC8056B121: "不能在同一 '#embed' 指令中重复指定参数 '%0'"
# 'cannot store matrix to read-only pointer'
H425886F44B36: '无法将矩阵存储到只读指针'
# "cannot subclass a class that was declared with the 'objc_subclassing_restricted' attribute"
H5638A6FF93B7: "不能继承使用 'objc_subclassing_restricted' 属性声明的类"
# 'cannot synthesize property %0 with incomplete type %1'
H71A1173D4045: '无法合成具有不完整类型 %1 的属性 %0'
# 'cannot synthesize weak property because the current deployment target does not support weak references'
H38DCEFEFA216: '当前部署目标不支持弱引用，因此无法合成弱属性'
# 'cannot synthesize weak property in file using manual reference counting'
H0734CFB3421A: '在使用手动引用计数的文件中无法合成弱属性'
# 'cannot take address of %select{immediate|consteval}2 %select{function|call operator of}1 %0 outside of an immediate invocation'
H530D63A21A7A: '不能在非立即调用的上下文中获取 %select{立即|consteval}2 %select{函数|调用运算符的}1 %0 的地址'
# 'cannot take address of function %0 because it has one or more non-tautological enable_if conditions'
H23DB8FEDBD81: '不能获取具有一个或多个非同构 enable_if 条件的函数 %0 的地址'
# 'cannot take address of function %0 because its constraints are not satisfied'
H4014F85A3BA5: '由于其约束未满足，无法获取函数 %0 的地址'
# 'cannot take address of function %0 because parameter %1 has pass_object_size attribute'
H6872B0BADEA4: '由于参数 %1 具有 pass_object_size 属性，无法获取函数 %0 的地址'
# 'cannot take an address of a virtual member function if its return or argument types are incomplete'
HF3A5696A9EB7: '如果虚成员函数的返回或参数类型不完整，则不能获取其地址'
# 'cannot take the address of an rvalue of type %0'
H60F39E1B8F38: '无法获取类型 %0 的右值的地址'
# 'cannot template a using %select{directive|declaration}0'
H7E5220347031: '无法对 using %select{指令|声明}0 进行模板化'
# 'cannot throw an object of abstract type %0'
H1AA71488C1EF: '不能抛出抽象类型 %0 的对象'
# 'cannot throw object of incomplete type %0'
H5A0A40D72DE8: '不能抛出不完整类型 %0 的对象'
# 'cannot throw object of sizeless type %0'
HA8B5689740C7: '不能抛出无尺寸类型 %0 的对象'
# 'cannot throw object of type %0 with a potentially-throwing destructor'
HC355469628A0: '不能抛出具有可能抛出的析构函数的类型 %0 的对象'
# 'cannot throw pointer to object of incomplete type %0'
H079B08EA2D25: '不能抛出指向不完整类型 %0 对象的指针'
# 'cannot type cast @selector expression'
H485C835C56BA: '无法将 @selector 表达式进行类型转换'
# "cannot use %select{'auto'|<ERROR>|'__auto_type'}0 with %select{initializer list|array}1 in C"
HE2E4F9E6D620: "不能在 C 中将 %select{'auto'|<ERROR>|'__auto_type'}0 与 %select{初始化列表|数组}1 一起使用"
# "cannot use %select{C++ 'try'|Objective-C '@try'}0 in the same function as SEH '__try'"
H455974313E2A: "不能在同一函数中同时使用 %select{C++ 'try'|Objective-C '@try'}0 和 SEH '__try'"
# 'cannot use %select{dot|arrow}0 operator on a type'
H546BD63E07E0: '不能对类型使用 %select{点|箭头}0 运算符'
# "cannot use %select{unicode|wide}0 string literal in 'asm'"
HD3FDC775E04A: "无法在 'asm' 中使用 %select{Unicode|宽}0 字符串字面量"
# "cannot use '%0' in %select{__device__|__global__|__host__|__host__ __device__}1 function"
H92A38A76E58C: "不能在 %select{__device__|__global__|__host__|__host__ __device__}1 函数中使用 '%0'"
# "cannot use '%0' output with multiple -arch options"
H1A59A50BBDD4: "不能在多个 -arch 选项中使用 '%0' 输出"
# "cannot use '%0' with '__vector bool'"
HB212313EEF9A: "不能将 '%0' 与 '__vector bool' 一起使用"
# "cannot use '%0' with Objective-C exceptions disabled"
H633899DC0353: "在禁用 Objective-C 异常时不能使用 '%0'"
# "cannot use '%0' with exceptions disabled"
H0F6B73A63960: "在禁用异常时不能使用 '%0'"
# "cannot use '_Complex' with '__vector'"
HCFEB59CAC054: "不能将 '_Complex' 与 '__vector' 一起使用"
# "cannot use 'float' with '__vector'"
H8772A8A87C32: "不能将 'float' 与 '__vector' 一起使用"
# "cannot use 'long double' with '__vector'"
HD41E42BADD92: "不能将 'long double' 与 '__vector' 一起使用"
# "cannot use 'long' with '__vector'"
H0DD309217BB4: "不能将 'long' 与 '__vector' 一起使用"
# "cannot use SEH '__try' in a coroutine when C++ exceptions are enabled"
H0484D634DF37: "当启用 C++ 异常时，协程中不能使用 SEH '__try'"
# "cannot use SEH '__try' in blocks, captured regions, or Obj-C method decls"
HAED8CA9442A3: "不能在块、捕获区域或 Obj-C 方法声明中使用 SEH '__try'"
# 'cannot use WebAssembly table as a function parameter'
H70C162E9FD41: '不能将WebAssembly表用作函数参数'
# 'cannot use a WebAssembly table within a branch of a conditional expression'
H4CC748CB0567: '不能在条件表达式的一个分支中使用WebAssembly表'
# "cannot use a protocol declared 'objc_non_runtime_protocol' in a @protocol expression"
H22D18CFED6B9: "不能在@protocol表达式中使用标记为'objc_non_runtime_protocol'的协议"
# "cannot use an empty string literal in 'asm'"
H9269C6D18FCF: "不能在'asm'中使用空字符串字面量"
# 'cannot use dynamic_cast to convert from %0 to %1'
H5749CC5204B8: '不能将dynamic_cast用于从%0到%1的转换'
# 'cannot use incomplete type %0 as a range'
H779605C5A805: '不能将不完整类型%0用作范围'
# 'cannot use initializer list at the beginning of a macro argument'
HFB12BDAF6D6F: '不能在宏参数开头使用初始化列表'
# 'cannot use type %0 as a range'
H9F644F56E9E3: '不能将类型%0用作范围'
# 'cannot use type %0 as an iterator'
H45599EAAF2D8: '不能将类型%0用作迭代器'
# "cannot use type '%0' within '#pragma clang fp eval_method'; type is set according to the default eval method for the translation unit"
HD91CCA267FD1: "不能在'#pragma clang fp eval_method'中使用类型'%0'；该类型由翻译单元的默认求值方法决定"
# 'cannot use variable %1 in collapsed imperfectly-nested loop %select{init|condition|increment}0 statement'
H40887EDB8E4A: '无法在折叠的嵌套循环%select{init|condition|increment}0语句中使用变量%1'
# 'cannot use variable-length arrays in %select{__device__|__global__|__host__|__host__ __device__}0 functions'
H33A7639314BD: '不能在%select{__device__|__global__|__host__|__host__ __device__}0函数中使用变长数组'
# "cannot write file '%0': %1"
H57D82DC5A945: '无法写入文件"%0": %1'
# 'cannot yet @encode type %0'
H5CF1C5265DEE: '目前无法@encode类型%0'
# 'cannot yet compile %0 in this ABI'
H7B123038B924: '当前ABI无法编译%0'
# 'cannot yet mangle %0 expression'
HA255CBB16444: '目前无法对%0表达式进行名称修饰'
# 'cannot yet mangle OpenACC Asterisk Size expression'
H2D31700B7C49: '目前无法对OpenACC星号大小表达式进行名称修饰'
# 'cannot yet mangle expression type %0'
HF4D45A826D3A: '无法对表达式类型%0进行名称修饰'
# 'capture %0 by %select{value|reference}1'
HD0ACA3E1F2BB: '通过%select{值|引用}1捕获%0'
# 'capture default must be first'
HBD6F708D5FEC: '捕获默认必须放在最前面'
# 'capture host side class data member by this pointer in device or host device lambda function may result in invalid memory access if this pointer is not accessible on device side'
HA00333F0A82E: '在设备或混合设备lambda函数中通过this指针捕获主机侧类的数据成员，如果该this指针在设备侧不可访问，可能导致无效内存访问'
# 'capture host variable %0 by reference in device or host device lambda function'
H4218AAE93F26: '在设备或混合设备lambda函数中按引用捕获主机变量%0'
# "capture of '*this' by copy is a C++17 extension"
H9C3948693023: '按值捕获"*this"是C++17扩展'
# "capture of variable '%0' as type %1 calls %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}2constructor"
H6489D0544330: '将变量"%0"作为类型%1捕获调用%select{私有|保护}3%select{默认 |拷贝 |移动 |*ERROR* |*ERROR* |*ERROR* |}2构造函数'
# 'captured structured bindings are a C++20 extension'
HED60DD4C6A62: '捕获结构化绑定是C++20扩展'
# 'captured structured bindings are incompatible with C++ standards before C++20'
HA1967A579A6F: '捕获结构化绑定与C++20之前的C++标准不兼容'
# 'capturing %0 strongly in this block is likely to lead to a retain cycle'
H495EA167E92F: '在此块中强捕获%0可能会导致保留循环'
# 'capturing a structured binding is not yet supported in OpenMP'
H3DD2898A017E: 'OpenMP暂不支持捕获结构化绑定'
# 'case ranges are a C2y extension'
H022E1C3F4097: 'case范围是C2y扩展'
# 'case ranges are a GNU extension'
H0ADA830DF441: 'case范围是GNU扩展'
# 'case ranges are incompatible with C standards before C2y'
H94092A9759CB: 'case范围与C2y之前的C标准不兼容'
# 'case value not in enumerated type %0'
H4866E4105494: '枚举类型%0中不存在该case值'
# 'cast %diff{from $ to $ |}0,1converts to incompatible function type'
HAE54FE7B3C1C: '将%diff{从$转为$ |}0,1转换为不兼容的函数类型'
# "cast between incompatible calling conventions '%0' and '%1'; calls through this pointer may abort at runtime"
HB4A395B83746: '在调用约定类型"%0"和"%1"之间进行转换；通过该指针调用可能在运行时中止'
# 'cast between pointer-to-function and pointer-to-object is an extension'
H276B46B48964: '函数指针和对象指针之间的转换是扩展'
# 'cast between pointer-to-function and pointer-to-object is incompatible with C++98'
HD37948261117: '函数指针和对象指针之间的转换与C++98不兼容'
# 'cast expression to void to silence warning'
H1D7499C23CFE: '将表达式强制转换为void以消除警告'
# 'cast from %0 is not allowed in a constant expression %select{in C++ standards before C++2c|because the pointed object type %2 is not similar to the target type %3}1'
H542ED6DEC45B: '%select{在 C++2c 之前的 C++ 标准中|因为指向对象类型 %2 不与目标类型 %3 兼容}1 不允许将 %0 转换为常量表达式'
# 'cast from %0 to %1 drops %select{const and volatile qualifiers|const qualifier|volatile qualifier}2'
HA3B03023258D: '从%0转换到%1会丢失%select{const和volatile限定符|const限定符|volatile限定符}2'
# 'cast from %0 to %1 increases required alignment from %2 to %3'
H4A02BB23383F: '将 %0 转换为 %1 需要的对齐从 %2 增加到 %3'
# 'cast from %0 to %1 must have all intermediate pointers const qualified to be safe'
HB7DFA89AF07B: '从%0到%1的强制转换必须将所有中间指针用const限定以保证安全'
# 'cast from function call of type %0 to non-matching type %1'
H8CE3B0EB72DC: '将函数调用类型%0强制转换为不匹配的类型%1'
# 'cast from pointer to smaller type %2 loses information'
H60D928000B5D: '将指向较小类型%2的指针强制转换会丢失信息'
# 'cast of %select{Objective-C|block|C}0 pointer type %1 to %select{Objective-C|block|C}2 pointer type %3 cannot use %select{__bridge|__bridge_transfer|__bridge_retained}4'
H2F5F45B60576: '将%select{Objective-C|block|C}0指针类型%1强制转换为%select{Objective-C|block|C}2指针类型%3时不能使用%select{__bridge|__bridge_transfer|__bridge_retained}4'
# 'cast of type %0 to %1 is deprecated; use sel_getName instead'
HC7428E5162D0: '将类型%0转换为%1的强制转换已弃用；请改用sel_getName'
# 'cast one or both operands to int to silence this warning'
H49949EF0EEB5: '将其中一个或两个操作数强制转换为int以消除此警告'
# 'cast to %1 from smaller integer type %0'
HF29EC08A2098: '将较小的整型%0强制转换为%1'
# 'cast to incomplete type %0'
HB29014F052FD: '将不完整类型%0进行强制转换'
# 'cast to smaller integer type %1 from %0'
H3EAB0F6AAF90: '将%0强制转换为较小的整型%1'
# 'cast to union type from type %0 not present in union'
H26129A704E2A: '将类型%0（该类型未在联合中定义）强制转换为联合类型'
# 'cast to union type is a GNU extension'
H07ADEAB6CDD8: '将联合类型进行强制转换是GNU扩展'
# 'casting from randomized structure pointer type %0 to %1'
H760D7A3D8C24: '将随机化结构体指针类型%0强制转换为%1'
# "casting to dereferenceable pointer removes 'noderef' attribute"
H435CE65222D6: '将指针强制转换为可解引用指针会移除"noderef"属性'
# 'casting to type %0 is not allowed'
H05073823504A: '转换为类型%0是不允许的'
# 'catch-all handler must come last'
H18423565AC35: '默认异常处理程序必须放在最后'
# 'category is implementing a method which will also be implemented by its primary class'
H12CCDCE8A3DF: '分类正在实现一个方法，该方法也会由其主类实现'
# "chained comparison 'X %0 Y %1 Z' does not behave the same as a mathematical expression"
HF2403FB0CB87: '链式比较"X %0 Y %1 Z"的行为与数学表达式不同'
# "change return type to 'int'"
H2DD08C8E9ADD: '将返回类型更改为int'
# 'change size argument to be the size of the destination'
HC31A5632ABB1: '将大小参数更改为目标类型的大小'
# 'change the argument to be the free space in the destination buffer minus the terminating null byte'
H66702CDAA7E2: '将参数更改为目标缓冲区的可用空间减去终止空字节'
# "change this ',' to a ';' to call %0"
H5A1EAB3B7F87: "将此','改为';'以调用%0"
# "change type of %0 to '%select{std::span' to preserve bounds information|std::array' to label it for hardening|std::span::iterator' to preserve bounds information}1%select{|, and change %2 to '%select{std::span|std::array|std::span::iterator}1' to propagate bounds information between them}3"
H1123F3B73559: "将%0的类型更改为'%select{std::span'以保留边界信息|std::array'以标记为强化|std::span::iterator'以保留边界信息}1%select{|，并将%2更改为'%select{std::span|std::array|std::span::iterator}1'以在它们之间传播边界信息}3"
# "change type of %0 to '%select{std::span' to preserve bounds information|std::array' to label it for hardening|std::span::iterator' to preserve bounds information}1%select{|, and change %2 to safe types to make function %4 bounds-safe}3"
H9C76AEF6C221: "将%0的类型更改为'%select{std::span'以保留边界信息|std::array'以标记为强化|std::span::iterator'以保留边界信息}1%select{|，并将%2更改为安全类型以使函数%4具有边界安全性}3"
# "character '%0' cannot be specified by a universal character name"
H9FDECB7636A6: "字符'%0'不能通过通用字符名指定"
# 'character <U+%0> not allowed %select{in|at the start of}1 an identifier'
H0604F74F1073: '字符<U+%0>不允许%select{在|在开头}1标识符中'
# 'character constant too long for its type'
H99E005D8F34A: '字符常量的长度超过其类型允许的范围'
# 'character literal with user-defined suffix cannot be used here'
HB73A18549E7B: '此处不能使用具有用户定义后缀的字符文字'
# 'character too large for enclosing character literal type'
HFC3FA51117BB: '字符过大，超出包含的字符类型范围'
# 'characters names in Unicode escape sequences are sensitive to case and whitespaces'
H6FEF0F08A2BB: 'Unicode转义序列中的字符名称对大小写和空白符敏感'
# 'charizing operator #@ is a Microsoft extension'
H374F252BD0E9: '字符化运算符#@是Microsoft扩展'
# "checker '%0' has no option called '%1'"
H473E877D384D: "检查器'%0'没有名为'%1'的选项"
# "checker cannot be enabled with analyzer option '%0' == %1"
H9705343670F8: "无法通过分析器选项'%0' == %1启用检查器"
# "checker plugin '%0' is not compatible with this version of the analyzer"
H6AAE762D0724: "检查器插件'%0'与此版本的分析器不兼容"
# 'chosen constructor is explicit in copy-initialization'
H0B94DB59D2D8: '在拷贝初始化中选择的构造函数是显式的'
# 'circular pointer delegation detected'
H16A98512E3BA: '检测到循环指针委托'
# 'clang-rename could not find symbol %0'
H72B95322F623: 'clang-rename无法找到符号%0'
# 'clang-rename could not find symbol (offset %0)'
H9B2484C454C5: 'clang-rename无法找到符号（偏移量%0）'
# 'class %0 defined without specifying a base class'
H3A2FB228D84B: '类%0在未指定基类的情况下被定义'
# 'class %0 has incompatible superclasses'
HAE8DDB1E1535: '类%0具有不兼容的超类'
# 'class %0 previously declared with type parameters'
H5BCC48BDFD6B: '类%0之前使用类型参数声明过'
# "class already marked '%0'"
HCB141E8798E7: "类已标记为 '%0'"
# 'class extension has no primary class'
H14396A81AB6D: '类扩展没有主类'
# 'class has %0 base %plural{1:class|:classes}0'
HD719F68B2E7D: '类具有 %0 基 %plural{1:类|:类}0'
# 'class has base type %0'
H55F5972959B4: '类的基类型为 %0'
# 'class implementation is declared here'
HFDD816FBE31D: '类实现在此处声明'
# 'class implementation may not have super class'
HF88305654764: '类实现不能有超类'
# 'class is declared here'
H1CB72009FE78: '类在此处声明'
# 'class is incompatible with __weak references'
H5D4A2732A59E: '该类与 __weak 引用不兼容'
# 'class member %0 cannot appear in capture list as it is not a variable'
HB01A6BF35CAF: '类成员 %0 不能出现在捕获列表中，因为它不是变量'
# "class member already marked '%0'"
H8651C68C3085: "类成员已标记为 '%0'"
# 'class member cannot be redeclared'
H011ED139495E: '类成员不能重新声明'
# "class method %objcclass0 not found (return type defaults to 'id')"
HA1F101EC915B: "未找到类方法 %objcclass0（返回类型默认为 'id'）"
# "class method %objcclass0 not found (return type defaults to 'id'); did you mean %objcclass2?"
H4EC4BD008AC8: "未找到类方法 %objcclass0（返回类型默认为 'id'）；是否是指 %objcclass2？"
# 'class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category'
H70F68CFFF089: '类属性 %0 需要定义方法 %1 —— 请使用 @dynamic 或在该分类中提供方法实现'
# 'class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this class implementation'
HC6D0854C646B: '类属性 %0 需要定义方法 %1 —— 请使用 @dynamic 或在该类实现中提供方法实现'
# 'class template %0 was explicitly specialized here'
HAF7828F4534C: '类模板 %0 已在此处显式特化'
# 'class template %0 was instantiated here'
H67A993394D9A: '类模板 %0 已在此处实例化'
# 'class template argument deduction for %0 selected a deleted constructor'
H2F3153B3F0E2: '%0 的类模板参数推导选中了一个已删除的构造函数'
# 'class template argument deduction for %0 selected an explicit %select{constructor|deduction guide}1 for copy-list-initialization'
HC409A532BB3A: '%0 的类模板参数推导为复制列表初始化选中了一个显式的 %select{构造函数|推导指引}1'
# 'class template argument deduction for alias templates is incompatible with C++ standards before C++20'
H0A109AC10809: '别名模板的类模板参数推导与 C++20 之前的 C++ 标准不兼容'
# 'class template argument deduction is incompatible with C++ standards before C++17%select{|; for compatibility, use explicit type name %1}0'
HCFEDA0AEF7C1: '类模板参数推导与C++17之前的C++标准不兼容%select{|; 为兼容性，请显式指定类型名 %1}0'
# 'class template partial specialization %0 cannot be redeclared'
HD6C67286FA78: '类模板部分特化 %0 不能被重新声明'
# "class with destructor marked '%select{final|sealed}0' cannot be inherited from"
H8F6FAE53F32D: "带有被标记为 '%select{final|sealed}0' 的析构函数的类不能被继承"
# 'class with specified objc_requires_property_definitions attribute is declared here'
H42C6E2F16E82: '指定了 objc_requires_property_definitions 属性的类在此处声明'
# 'cmse is not compatible with %select{RWPI|ROPI}0'
HC391A16C0EBD: 'cmse 不兼容 %select{RWPI|ROPI}0'
# "code model '%0' is not supported on this target"
HCF39144044A7: "代码模型 '%0' 不受此目标平台支持"
# 'code object v6 is still in development and not ready for production use yet; use at your own risk'
H1929D4BDCAE5: 'v6代码对象仍处于开发阶段，尚未准备好用于生产环境；请自行承担风险使用'
# 'code will never be executed'
H2586D13FCD3D: '代码永远不会被执行'
# 'collection element of type %0 is not an Objective-C object'
H8FFDEDA7A274: '集合元素类型 %0 不是Objective-C对象'
# 'collection expression type %0 is a forward declaration'
HDDCD4086A7F8: '集合表达式类型 %0 是前向声明'
# 'collection expression type %0 may not respond to %1'
H8F39224B1450: '集合表达式类型 %0 可能无法响应 %1'
# 'comma expressions are not allowed as indices in matrix subscript expressions'
H3F02FDCEC720: '矩阵下标表达式的索引中不允许使用逗号表达式'
# 'comma operator in operand of #if'
HDC042AF8F218: '#if 运算符的运算对象中包含逗号运算符'
# 'comma separating Objective-C messaging arguments'
HAB4747C7C927: 'Objective-C消息传递参数间的逗号分隔符'
# 'commas at the end of enumerator lists are a C++11 extension'
H2EA69DF0ADB4: '枚举列表末尾的逗号是C++11扩展语法'
# 'commas at the end of enumerator lists are a C99-specific feature'
H1F877ED68177: '枚举列表末尾的逗号是C99特定特性'
# 'commas at the end of enumerator lists are incompatible with C++98'
H28609FC0503F: '枚举列表末尾的逗号与C++98标准不兼容'
# 'comparing a pointer to a null character constant; did you mean to compare to %select{NULL|(void *)0}0?'
H5D12051B65A0: '正在将指针与空字符常量进行比较；是否应比较 %select{NULL|(void *)0}0？'
# 'comparing floating point with == or != is unsafe'
H1DE5EF3912E1: '使用 == 或 != 比较浮点数是不安全的'
# 'comparing with this %select{specifier|format string}0'
H0EA8BCD476F7: '与这个 %select{说明符|格式字符串}0 进行比较'
# "comparison against address of weak declaration '%0' can only be performed at runtime"
H3C6EE2D92685: "对弱声明 '%0' 的地址进行比较只能在运行时执行"
# "comparison against opaque constant address '%0' can only be performed at runtime"
HAC7288F66309: "对不透明常量地址 '%0' 的比较只能在运行时执行"
# "comparison against pointer '%0' that points past the end of a complete object has unspecified value"
H3D15A3D98DF0: "指向完整对象末尾之后的指针 '%0' 的比较具有未指定值"
# 'comparison against pointer to weak member %q0 can only be performed at runtime'
HFCA39B812783: '对弱成员 %q0 的指针进行比较只能在运行时执行'
# 'comparison between NULL and non-pointer %select{(%1 and NULL)|(NULL and %1)}0'
H20F85EBECAC2: 'NULL与非指针类型 %select{(%1 和 NULL)|(NULL 和 %1)}0 进行比较'
# 'comparison between pointer and integer (%0 and %1)'
H9205163E9BD4: '指针与整数 (%0 和 %1) 之间的比较'
# "comparison between pointers to unrelated objects '%0' and '%1' has unspecified value"
H722AC288816C: "指向无关对象 '%0' 和 '%1' 的指针之间的比较具有未指定值"
# "comparison between two arrays compare their addresses and will be deprecated in c++20; to compare array addresses, use unary '+' to decay operands to pointers"
H5D551E6212F9: "两个数组的比较会比较它们的地址，并将在C++20中弃用；要比较数组地址，请使用一元 '+' 运算符将操作数转换为指针"
# "comparison between two arrays is deprecated; to compare array addresses, use unary '+' to decay operands to pointers"
H4D3F55AAB37F: "两个数组的比较已被弃用；要比较数组地址，请使用一元 '+' 运算符将操作数转换为指针"
# "comparison between two arrays is ill-formed in C++26; to compare array addresses, use unary '+' to decay operands to pointers"
H20B4EE22A6C2: "在C++26中比较两个数组是不符合规范的；要比较数组地址，请使用一元 '+' 运算符将操作数转换为指针"
# "comparison of %select{address of|function|array}0 '%1' %select{not |}2equal to a null pointer is always %select{true|false}2"
H61B7557646A7: "%select{地址的|函数|数组}0 '%1' 与空指针 %select{不 |}2相等的比较始终为 %select{true|false}2"
# 'comparison of address of base class subobject %0 of class %1 to field %2 has unspecified value'
HCEA4BEB9DFF0: '对类 %1 的基类子对象 %0 的地址与字段 %2 进行比较具有未指定值'
# 'comparison of address of fields %0 and %2 of %4 with differing access specifiers (%1 vs %3) has unspecified value'
H30BB5DCF7738: '对 %4 中具有不同访问说明符（%1 与 %3）的字段 %0 和 %2 的地址进行比较具有未指定值'
# 'comparison of addresses of potentially overlapping literals has unspecified value'
H59EF9C14B9AF: '对可能重叠的字面量的地址进行比较具有未指定值'
# 'comparison of addresses of subobjects of different base classes has unspecified value'
HA10192E66EB6: '对不同基类的子对象的地址进行比较具有未指定值'
# 'comparison of different enumeration types in switch statement%diff{ ($ and $)|}0,1'
H820D2D4F7522: '在switch语句中比较不同的枚举类型%diff{ ($ 和 $)|}0,1'
# 'comparison of distinct block types%diff{ ($ and $)|}0,1'
HA2CFC62DE473: '比较不同块类型%diff{ ($ 和 $)|}0,1'
# 'comparison of distinct pointer types%diff{ ($ and $)|}0,1'
H1D24D97A54FF: '比较不同指针类型%diff{ ($ 和 $)|}0,1'
# 'comparison of integers of different signs: %0 and %1'
H8C3AA027FA1B: '不同符号的整数比较：%0 和 %1'
# "comparison of nonnull %select{function call|parameter}0 '%1' %select{not |}2equal to a null pointer is '%select{true|false}2' on first encounter"
H9EDFDB49F3E3: "对非空 %select{函数调用|参数}0 '%1' 与空指针 %select{不 |}2相等的比较在首次遇到时为 '%select{true|false}2'"
# "comparison of numeric address '%0' with pointer '%1' can only be performed at runtime"
HFBF28443EB32: "对数值地址 '%0' 与指针 '%1' 的比较只能在运行时进行"
# 'comparison of pointer to virtual member function %0 has unspecified value'
HDF5F345093AE: '对虚成员函数 %0 的指针进行比较具有未指定的值'
# "comparison of pointers '%0' and '%1' to unrelated zero-sized objects"
H0C0F9C2F76E9: "无关零大小对象指针 '%0' 和 '%1' 的比较"
# 'comparison operator template cannot be defaulted'
HC75525ADCB07: '比较运算符模板不能默认'
# "compatibility_version does not match: '%0' (provided) vs '%1' (found)"
H96AD79FF790D: "兼容性版本不匹配：'%0'（已提供）与 '%1'（已找到）"
# 'compatible type %0 specified here'
HA0D702990A9A: '此处指定的兼容类型 %0'
# "compilation database '%0' could not be opened: %1"
H55D78247B7D8: "无法打开编译数据库 '%0'：%1"
# 'compile time floating point arithmetic suppressed in strict evaluation modes'
H1CBDE348A919: '严格求值模式下禁止编译时浮点运算'
# 'compiler has implicitly changed method %0 return type'
HA0BE2730FEEE: '编译器已隐式更改方法 %0 的返回类型'
# 'completion handler is called twice'
HA50FDB30A90B: '完成处理程序被调用了两次'
# 'completion handler is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2'
HF3977C617098: '当%select{取真分支|取假分支|处理此情况|所有情况均不适用|进入循环|跳过循环|取其中一个分支}2时，完成处理程序从未%select{使用|调用}1'
# 'complex initialization specifying real and imaginary components is an extension'
H4D2B224EF174: '同时指定实部和虚部的复数初始化是一项扩展'
# 'complex integer types are a GNU extension'
H69724ED89FCA: '复数整数类型是GNU扩展'
# 'complex numbers are an extension in a freestanding C99 implementation'
HC53143A84579: '自由-standing C99实现中的复数类型是一项扩展'
# 'compound binary operator not supported, only +=, *=, -=, /=, &=, ^=, |=, <<=, or >>= are permitted'
H7DD0E2130464: '仅允许使用 +=, *=, -=, /=, &=, ^=, |=, <<= 或 >>=，不支持其他复合二进制运算符'
# 'compound literal cannot be of variable-length array type'
H35B29277CD5B: '复合字面量不能是可变长度数组类型'
# 'compound literal in function scope may not be qualified with an address space'
H5D92A895F54C: '函数作用域内的复合字面量不能用地址空间进行限定'
# 'compound literals are a C99-specific feature'
H89109EF1C578: '复合字面量是C99特定特性'
# 'concatenated NSString literal for an NSArray expression - possibly missing a comma'
H05B938722790: '用于NSArray表达式的连接NSString字面量 - 可能缺少逗号'
# 'concept cannot have associated constraints'
H2D3AA7366D73: '概念不能具有关联约束'
# 'concept declarations may only appear in global or namespace scope'
HC471DCAA93F1: '概念声明只能出现在全局或命名空间作用域中'
# 'concept named in type constraint is not a type concept'
H745ADE930837: '类型约束中命名的概念不是一个类型概念'
# 'concept template parameter list must have at least one parameter; explicit specialization of concepts is not allowed'
HBDA562F258A9: '概念模板参数列表必须至少包含一个参数；不允许显式特化概念'
# "condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', %select{or '>='|'>=', or '!='}0) of loop variable %1"
H8BF46A7D7B10: "OpenMP for循环的条件必须是循环变量 %1 的 relational 比较（'<'、'<=', '>', %select{或 '>='|'>=', 或 '!='}0）"
# 'conditional expression is ambiguous; %diff{$ and $|types}0,1 can be converted to several common types'
H9909B5566589: '条件表达式存在歧义；%diff{$ 和 $|类型}0,1 可以转换为多种公共类型'
# 'conditional expression is ambiguous; %diff{$ can be converted to $ and vice versa|types can be convert to each other}0,1'
HD6EF4047D3B6: '条件表达式存在歧义；%diff{$ 可以转换为 $ 并且反之|类型可以相互转换}0,1'
# "configuration file '%0' cannot be found"
HF43B1D62E529: "配置文件 '%0' 未找到"
# "configuration file '%0' cannot be opened: %1"
H91238BB29F2B: "无法打开配置文件 '%0'：%1"
# 'configuration macros are only allowed in top-level modules'
HC1EFBD1A6AB2: '配置宏仅允许在顶层模块中使用'
# 'conflicting %0 here'
H178724C0754B: '此处与 %0 冲突'
# 'conflicting __device__ function declared here'
H6D42767A98E2: '此处声明的 __device__ 函数存在冲突'
# 'conflicting address space qualifiers are provided between types %0 and %1'
HA444D7C677AE: '类型 %0 和 %1 之间提供的地址空间限定符存在冲突'
# 'conflicting asm label'
H08C5ACC499B8: '冲突的汇编标签'
# 'conflicting attribute is here'
HB210D5E7919C: '冲突的属性在此处'
# 'conflicting attributes %0 are ignored'
H43DE73EC415F: '冲突的属性 %0 被忽略'
# "conflicting attributes for state '%0'"
H30B7C9BA9F57: "状态 '%0' 的属性存在冲突"
# 'conflicting code segment specifiers'
HF81F9823233E: '冲突的代码段指定符'
# 'conflicting declaration'
H9D2B5D5AA66E: '冲突的声明'
# 'conflicting deduction %diff{$ against $|types}0,1 for parameter'
H0919F4EB4F97: '参数的类型推导与 %diff{$ 和 $|类型}0,1 存在冲突'
# "conflicting deployment targets, both '%0' and '%1' are present in environment"
H8F50D7638091: "部署目标存在冲突，环境同时包含 '%0' 和 '%1'"
# 'conflicting distributed object modifiers on parameter type in declaration of %0'
H4CB94BB5639A: '在%0的声明中参数类型存在冲突的分布式对象修饰符'
# 'conflicting distributed object modifiers on parameter type in implementation of %0'
HA9E88E86F6C2: '在%0的实现中参数类型存在冲突的分布式对象修饰符'
# 'conflicting distributed object modifiers on return type in declaration of %0'
HBE23CBB42FFE: '在%0的声明中返回类型存在冲突的分布式对象修饰符'
# 'conflicting distributed object modifiers on return type in implementation of %0'
HBB60CEE9C2B2: '在%0的实现中返回类型存在冲突的分布式对象修饰符'
# 'conflicting instance variable names: %0 vs %1'
H088E6A0E59D6: '冲突的实例变量名：%0 与 %1'
# 'conflicting loop attribute %0'
H69465530AFA7: '冲突的循环属性 %0'
# 'conflicting nullability specifier on parameter types, %0 conflicts with existing specifier %1'
H11AC0D03E320: '参数类型上的空值指定符冲突：%0 与现有指定符 %1 冲突'
# 'conflicting nullability specifier on return types, %0 conflicts with existing specifier %1'
H9D01BC58F478: '返回类型上的空值指定符冲突：%0 与现有指定符 %1 冲突'
# "conflicting option '-fcoro-aligned-allocation' and '-fno-aligned-allocation'"
HD53AB264ABE6: "选项 '-fcoro-aligned-allocation' 与 '-fno-aligned-allocation' 冲突"
# 'conflicting parameter qualifier %0 on parameter %1'
HC7B786535E39: '参数 %1 上存在冲突的参数限定符 %0'
# 'conflicting parameter types in declaration of %0%diff{: $ vs $|}1,2'
HCBD5D6ED758A: '在%0的声明中参数类型冲突%diff{: $ vs $|}1,2'
# 'conflicting parameter types in declaration of %0: %1 vs %2'
HF405BA99A067: '在%0的声明中参数类型冲突：%1 与 %2'
# 'conflicting parameter types in implementation of %0%diff{: $ vs $|}1,2'
H64F50A39ECB1: '在%0的实现中参数类型冲突%diff{: $ vs $|}1,2'
# 'conflicting parameter types in implementation of %0: %1 vs %2'
HC0C8356B7475: '在%0的实现中参数类型冲突：%1 与 %2'
# 'conflicting pass_object_size attributes on parameters'
H99CE421CA443: '参数上的 pass_object_size 属性冲突'
# 'conflicting prototype is here'
HF896EFD79698: '冲突的原型在此处'
# "conflicting re-export of module '%0' as '%1' or '%2'"
H8B0F3A29C0A1: "冲突的模块重导出：'%0' 作为 '%1' 或 '%2'"
# 'conflicting return type in declaration of %0%diff{: $ vs $|}1,2'
H2BB3153B6C50: '在%0的声明中返回类型冲突%diff{: $ vs $|}1,2'
# 'conflicting return type in declaration of %0: %1 vs %2'
H5D783A189DCF: '在%0的声明中返回类型冲突：%1 与 %2'
# 'conflicting return type in implementation of %0%diff{: $ vs $|}1,2'
HEB354C372ED1: '在%0的实现中返回类型冲突%diff{: $ vs $|}1,2'
# 'conflicting return type in implementation of %0: %1 vs %2'
H5C54E8625E6A: '在%0的实现中返回类型冲突：%1 与 %2'
# 'conflicting super class name %0'
HF493EF2E1E41: '父类名称%0冲突'
# 'conflicting types for %0'
H5E0475C2D7BC: '%0的类型冲突'
# 'conflicting types for alias %0'
HCE7DAE70AA85: '别名%0的类型冲突'
# 'conflicting variadic declaration of method and its implementation'
H2A0A12EA2AF3: '方法及其实现的可变参数声明冲突'
# 'conformance of forward class %0 to protocol %1 cannot be confirmed'
H978A4E78BB8C: '无法确认前向类%0对协议%1的符合性'
# "consecutive right angle brackets are incompatible with C++98 (use '> >')"
H77515E521F08: "连续的右尖括号与C++98不兼容（请使用'> >'）"
# "consider adding '%0' to the header search path"
HCE15ED850DE4: "考虑将'%0'添加到头文件搜索路径"
# "consider defining %0 with the '%1' calling convention"
H6A4F6FD30F2D: "考虑使用'%1'调用约定定义%0"
# 'consider making the bit-field type %select{unsigned|signed}0'
HDAE81431A685: '考虑将位域类型设置为%select{unsigned|signed}0'
# "consider using __builtin_trap() or qualifying pointer with 'volatile'"
H002E765592F2: "考虑使用__builtin_trap()或用'volatile'修饰指针"
# 'consider using vld1_%0%1() to initialize a vector from memory, or vcreate_%0%1() to initialize from an integer constant'
H3E54619F1458: '考虑使用vld1_%0%1()从内存初始化向量，或使用vcreate_%0%1()从整数常量初始化'
# 'consider using vld1q_%0%1() to initialize a vector from memory, or vcombine_%0%1(vcreate_%0%1(), vcreate_%0%1()) to initialize from integer constants'
H0B91FFD90BE8: '考虑使用vld1q_%0%1()从内存初始化向量，或使用vcombine_%0%1(vcreate_%0%1(), vcreate_%0%1())从整数常量初始化'
# 'const variable cannot be emitted on device side due to dynamic initialization'
H2D4E40F2FA4A: '由于动态初始化，const变量无法在设备端生成'
# 'const-qualified list item cannot be %0'
HABDF81BBC813: 'const限定的列表项不能是%0'
# 'const-qualified variable cannot be %0'
H02E8DDC8D310: 'const限定的变量不能是%0'
# 'const-qualified variable without mutable fields cannot be %0'
HF38DA802B6DD: '没有可变字段的const限定变量不能是%0'
# 'constant evaluation of %0 between arrays of types %1 and %2 is not supported; only arrays of narrow character types can be compared'
H42EAC15FC487: '在类型%1和%2的数组之间对%0进行常量求值不受支持；仅窄字符类型的数组可以比较'
# 'constant evaluation of %0 on array of type %1 is not supported; only arrays of narrow character types can be searched'
HCF9A8296188E: '在类型%1的数组上对%0进行常量求值不受支持；仅窄字符类型的数组可以搜索'
# 'constant expression evaluates to %0 which cannot be narrowed to type %1'
HE08100927247: '常量表达式求值为%0，无法窄化为类型%1'
# 'constant expression evaluates to %0 which cannot be narrowed to type %1 in C++11'
H3A70E9ED4BE6: '常量表达式计算结果为%0，在C++11中无法转换为类型%1'
# 'consteval function %0 cannot override a non-consteval function'
HD9788F98961F: 'consteval函数%0不能覆盖非consteval函数'
# 'consteval if is a C++23 extension'
H32DA4F52DDFE: 'consteval if是C++23的扩展'
# 'consteval if is always true in an %select{unevaluated|immediate}0 context'
HFA38139DBCC5: '在%select{未计算|立即}0上下文中，consteval if始终为真'
# 'consteval if is incompatible with C++ standards before C++23'
H3BF3B6976984: 'consteval if与C++23之前的版本不兼容'
# 'constexpr %select{member function|constructor}0 not allowed in %select{struct|interface|class}1 with virtual base %plural{1:class|:classes}2'
HA87030D3447E: '在具有虚拟基类%plural{1:class|:classes}2的%select{struct|interface|class}1中不允许使用constexpr %select{成员函数|构造函数}0'
# 'constexpr bit cast involving type %0 is not yet supported'
H93DC3AD734F6: '涉及类型%0的constexpr位转换尚不支持'
# 'constexpr bit_cast involving bit-field is not yet supported'
HCF05A23F6C40: '涉及位域的constexpr bit_cast尚不支持'
# 'constexpr constructor that does not initialize all members is a C++20 extension'
H6D6AAEF0CE01: '未初始化所有成员的constexpr构造函数是C++20的扩展'
# 'constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20'
H6CD8A3688EC0: '未初始化所有成员的constexpr构造函数与C++20之前的版本不兼容'
# 'constexpr evaluation exceeded maximum depth of %0 calls'
H71A1AF77C8D7: 'constexpr求值超过%0层的最大深度'
# 'constexpr evaluation hit maximum call limit'
H2D336AD5FC66: 'constexpr求值达到最大调用限制'
# 'constexpr evaluation hit maximum heap allocation limit'
HEA6F0C77C92E: 'constexpr求值达到最大堆分配限制'
# 'constexpr evaluation hit maximum step limit; possible infinite loop?'
H3A9C6A5C602B: 'constexpr求值达到最大步数限制；可能存在无限循环？'
# 'constexpr function %0 without __host__ or __device__ attributes cannot overload __device__ function with the same signature; add a __host__ attribute, or build with -fno-cuda-host-device-constexpr'
HAF2225A9BAA0: '不带__host__或__device__属性的constexpr函数%0不能重载具有相同签名的__device__函数；添加__host__属性，或使用-fno-cuda-host-device-constexpr编译'
# 'constexpr function with no return statements is incompatible with C++ standards before C++14'
H60A27D48D081: '没有返回语句的constexpr函数与C++14之前的版本不兼容'
# 'constexpr if condition is not a constant expression'
H9AC357BF4F5E: 'constexpr if的条件不是一个常量表达式'
# 'constexpr if is a C++17 extension'
H8C78EE861C25: 'constexpr if是C++17的扩展'
# 'constexpr if is incompatible with C++ standards before C++17'
H518345725A13: 'constexpr if与C++17之前的版本不兼容'
# 'constexpr initializer evaluates to %0 which is not exactly representable in type %1'
HFD7668DF8CE8: 'constexpr初始化器计算结果为%0，无法在类型%1中精确表示'
# 'constexpr initializer for type %0 is of type %1'
H57EA50C1B712: '类型%0的constexpr初始值为类型%1'
# 'constexpr on lambda expressions is incompatible with C++ standards before C++17'
H2F64715F9E19: '在C++17之前的C++标准中，lambda表达式上的constexpr不兼容'
# 'constexpr pointer initializer is not null'
HA90F435C9DCD: 'constexpr指针初始值不是空值'
# 'constexpr union constructor that does not initialize any member is a C++20 extension'
HDA9656DF3125: '不初始化任何成员的constexpr联合构造函数是C++20扩展'
# 'constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20'
H42AB5A6736FE: '不初始化任何成员的constexpr联合构造函数与C++20之前的C++标准不兼容'
# 'constexpr variable %0 must be initialized by a constant expression'
H22D6867A6C46: 'constexpr变量%0必须由常量表达式初始化'
# 'constexpr variable %0 must have constant destruction'
H0CB1A9F457E9: 'constexpr变量%0必须具有常量销毁'
# 'constexpr variable cannot have non-literal type %0'
H8CA68B10BD1E: 'constexpr变量不能具有非字面类型%0'
# 'constexpr variable cannot have type %0'
H9CBE3FDAF244: 'constexpr变量不能具有类型%0'
# 'constexpr variable declaration must be a definition'
H28D5C206A058: 'constexpr变量声明必须是一个定义'
# 'constrained by %select{|implicitly }1%select{private|protected}0 inheritance here'
HA215ECA901D4: '受%select{|隐式 }1%select{private|protected}0继承的约束'
# "constrained placeholder types other than simple 'auto' on non-type template parameters not supported yet"
HA5CE432D2BF4: "非类型模板参数上的非简单'auto'约束占位类型尚未支持"
# "constraint '%0' is already present here"
HDBC0B5C441D3: "约束'%0'在此处已存在"
# 'constraint depends on a previously diagnosed expression'
HE3836E579C9B: '约束依赖于之前诊断过的表达式'
# 'constraint variable %0 cannot be used in an evaluated context'
H553F40E512D9: '约束变量%0不能在求值上下文中使用'
# 'constraints not satisfied for %select{class template|function template|variable template|alias template|template template parameter|template}0 %1%2'
H81A668F064ED: '约束条件未满足%select{类模板|函数模板|变量模板|别名模板|模板模板参数|模板}0 %1%2'
# "construct '%0' not allowed in a region associated with a directive with 'order' clause"
HC4C995E5BA30: "在与带有'order'子句的指令关联的区域中不允许构造'%0'"
# 'construction of individual component of complex number is not yet supported in constant expressions'
H0E4CD910394F: '复数的各个分量的构造在常量表达式中尚未支持'
# 'constructor call from initializer list is incompatible with C++98'
HB192963D1DEE: '来自初始化列表的构造函数调用与C++98不兼容'
# "constructor cannot be declared '%0'"
HC6A3768462FF: "构造函数不能声明为'%0'"
# 'constructor cannot be redeclared'
H55F24B0BC81F: '构造函数不能被重新声明'
# 'constructor cannot have a return type'
H859AAE558539: '构造函数不能有返回类型'
# 'constructor for %0 creates a delegation cycle'
H475456925F83: '%0的构造函数创建了委托循环'
# 'constructor from base class %0 inherited here'
H1711561364CF: '从基类%0继承的构造函数'
# 'constructor inherited by %0 from base class %1 is implicitly deleted'
H97CFC0CC7D39: '%0从基类%1继承的构造函数被隐式删除'
# 'constructor inherited from base class %0 cannot be used in a constant expression; derived class cannot be implicitly initialized'
HC12464115FAE: '从基类%0继承的构造函数不能用于常量表达式；派生类无法隐式初始化'
# 'constructor initializer %0 does not name a class'
HCFC849237163: '构造函数初始化项%0未命名一个类'
# 'constructor of %0 inherited from multiple base class subobjects'
HC9F4CC1EE50E: '%0的构造函数从多个基类子对象继承'
# 'constructor of base class %0 is not called'
H3174F7100ABA: '基类%0的构造函数未被调用'
# 'constructor parameter %0 shadows the field %1 of %2'
H11CEF1CBDAF0: '构造函数参数%0遮蔽了%2的字段%1'
# "constructs with the same name must have a 'hint' clause with the same value"
H0760234C4455: "具有相同名称的构造必须带有值相同的'hint'子句"
# "consumed analysis attribute is attached to member of class %0 which isn't marked as consumable"
H05C072713E0E: 'consumed分析属性附加到未标记为可消耗的类%0的成员'
# 'container access result unused - container access should not be used for side effects'
H8AF2586DAD21: '容器访问结果未被使用 - 容器访问不应用于副作用'
# 'context %select{set|selector|property}0 options are: %1'
H10E910F395AC: '上下文%select{设置|选择器|属性}0选项为：%1'
# 'control flows through the definition of a %select{static|thread_local}0 variable'
HBD024CE03438: '控制流通过%select{静态|线程局部}0变量的定义'
# 'control reached end of constexpr function'
HE6815340E241: '控制到达constexpr函数的末尾'
# 'controlling expression type %0 compatible with %1 generic association types'
HB8A1ADD97071: '控制表达式类型%0与%1泛型关联类型兼容'
# 'controlling expression type %0 not compatible with any generic association type'
H55E9ACCD45B7: '控制表达式类型%0与任何泛型关联类型不兼容'
# "convenience initializer missing a 'self' call to another initializer"
HF14170AD5005: '便利初始化器缺少对另一个初始化器的self调用'
# "convenience initializer should not invoke an initializer on 'super'"
HA39139A75170: "便利初始化器不应在'super'上调用另一个初始化器"
# 'conversion %diff{from $ to $|between types}0,1 is ambiguous'
HDD7803D6F7A1: '转换 %diff{从 $ 到 $|在类型之间}0,1 是模棱两可的'
# 'conversion between fixed point and %0 is not yet supported'
HF68AF1DBEB64: '固定点与 %0 之间的转换尚未支持'
# 'conversion between matrix type %0 and incompatible type %1 is not allowed'
H499A22E2DD8F: '禁止将矩阵类型 %0 转换为不兼容类型 %1'
# 'conversion between matrix types%diff{ $ and $|}0,1 of different size is not allowed'
H82DF9F4CF265: '禁止将不同大小的矩阵类型%diff{ $ 和 $|}0,1 之间进行转换'
# 'conversion candidate %0 not viable: constraints not satisfied'
H1A87D3FA633E: '转换候选项 %0 不可行：约束条件不满足'
# 'conversion candidate of type %0'
H1704891C4D79: '类型 %0 的转换候选项'
# 'conversion from %0 to %1 in converted constant expression would bind reference to a temporary'
H22C174FA2D9C: '在转换后的常量表达式中将 %0 转换为 %1 会绑定临时对象到引用'
# 'conversion from %0 to %1 is not allowed in a converted constant expression'
H64DA1E381CAE: '在转换后的常量表达式中将 %0 转换为 %1 不被允许'
# 'conversion from pointer to member of class %0 to pointer to member of class %1 via virtual base %2 is not allowed'
HC6DC2FD11DE6: '通过虚基类 %2 将类 %0 的成员指针转换为类 %1 的成员指针是不被允许的'
# 'conversion from string literal to %0 is deprecated'
H1DEAC81E3C65: '将字符串字面量转换为 %0 是已弃用的'
# 'conversion function %diff{from $ to $|between types}0,1 invokes a deleted function%select{|: %3}2'
H302A0E48B3BA: '转换函数 %diff{从 $ 到 $|在类型之间}0,1 调用了被删除的函数%select{|: %3}2'
# 'conversion function cannot be redeclared'
HA31D9D61E048: '转换函数不能被重新声明'
# 'conversion function cannot be variadic'
H28A6D9FD4C07: '转换函数不能是可变参数的'
# 'conversion function cannot convert to a function type'
H61F51031942B: '转换函数不能转换为函数类型'
# 'conversion function cannot convert to an array type'
H431E774C8920: '转换函数不能转换为数组类型'
# 'conversion function cannot have a return type'
H846A21D09489: '转换函数不能具有返回类型'
# 'conversion function cannot have any parameters'
H9E24A8535723: '转换函数不能有任何参数'
# 'conversion function converting %0 to %1 will never be used'
H960F42AADA51: '将 %0 转换为 %1 的转换函数将永远不会被使用'
# 'conversion function converting %0 to its base class %1 will never be used'
H1FE504FD028F: '将 %0 转换为其基类 %1 的转换函数将永远不会被使用'
# 'conversion function converting %0 to itself will never be used'
HC22DB2DAD0D5: '将 %0 转换为其自身的转换函数将永远不会被使用'
# 'conversion function must be a non-static member function'
HCACC98687D9A: '转换函数必须是非静态成员函数'
# 'conversion to %select{integral|enumeration}0 type %1'
H52D400CB1F4D: '转换为%select{整型|枚举}0类型%1'
# 'conversion to %select{integral|enumeration}0 type %1 declared here'
H126F1D6252B2: '转换为%select{整型|枚举}0类型%1，该类型在这里声明'
# 'conversion to pointer type %0'
H88631D898FE3: '转换为指针类型%0'
# 'converting delete expression from type %0 to type %1 invokes an explicit conversion function'
HFA594BB552D0: '将类型%0的delete表达式转换为类型%1会调用显式转换函数'
# 'converting the enum constant to a boolean'
HC26D67935F61: '将枚举常量转换为布尔值'
# "converting the result of '<<' to a boolean always evaluates to %select{false|true}0"
H66F90B0804A0: "将运算符'<<'的结果转换为布尔值始终会计算为%select{false|true}0"
# "converting the result of '<<' to a boolean; did you mean '(%0) != 0'?"
HB5F0E9F35B11: "将运算符'<<'的结果转换为布尔值；是否想表达'(%0) != 0'？"
# "converting the result of '?:' with integer constants to a boolean always evaluates to 'true'"
H0B52D2457927: "将带有整型常量的运算符'?:'的结果转换为布尔值始终会计算为'true'"
# 'converting to boxing syntax requires casting %0 to %1'
HDE90319BAAF3: '转换为装箱语法需要将%0转换为%1'
# 'coprocessor %0 must be configured as %select{GCP|CDE}1'
H4C456D50EC55: '协处理器%0必须配置为%select{GCP|CDE}1'
# 'copy %select{constructor|assignment operator}0 is implicitly deleted because %1 has a user-declared move %select{constructor|assignment operator}2'
HBE99D1D6F119: '复制%select{构造函数|赋值运算符}0被隐式删除，因为%1声明了用户自定义的移动%select{构造函数|赋值运算符}2'
# 'copy constructor must pass its first argument by reference'
H3ABFF716FBF3: '复制构造函数必须通过引用传递其第一个参数'
# 'copy constructor of %0 is implicitly deleted because field %1 is of rvalue reference type %2'
H5B9C818EF5D6: '%0的复制构造函数被隐式删除，因为字段%1是右值引用类型%2'
# 'copying a temporary object of incomplete type %0'
H4C050E15C304: '复制不完整类型%0的临时对象'
# "coroutine %0 cannot be declared 'noreturn' as it always returns a coroutine handle"
H7F1772343EA2: '协程%0不能声明为noreturn，因为它始终返回协程句柄'
# "could not acquire lock file for module '%0': %1"
H0C3259D0CAD4: "无法为模块'%0'获取锁文件：%1"
# "could not build module '%0'"
H0F4C1C79774B: "无法构建模块'%0'"
# "could not calculate number of iterations calling 'operator-' with upper and lower loop bounds"
H55F92FED58CA: '无法通过调用带有循环上下限的operator-计算迭代次数'
# 'could not determine the original source location for %0:%1:%2'
H596D1B547578: '无法确定%0:%1:%2的原始源代码位置'
# "could not find ';' after @import"
H808D2C4625A0: "在@import后找不到';'"
# 'could not find Objective-C class %0 to convert %1 to %2'
H8A434A2F54F7: '找不到Objective-C类%0来将%1转换为%2'
# 'could not match %diff{$ against $|types}0,1'
HB17669DA1C41: '无法匹配%diff{$ against $|types}0,1'
# "could not open '%0' for embedding"
HF452E067B4E2: "无法打开'%0'用于嵌入"
# "could not read %0 input list '%1': %2"
H67879BBD7E88: "无法读取%0输入列表'%1'：%2"
# "could not read directory '%0': %1"
HBA8BA2C7E279: "无法读取目录'%0'：%1"
# "could not remap file '%0' to the contents of file '%1'"
H154079BD4163: "无法将文件'%0'重映射为文件'%1'的内容"
# 'covariant thunk required by %0'
H96E8ACBA5464: '%0需要协变thunk'
# "cpu '%0' does not support rv%select{32|64}1"
HB22CC79010F2: "CPU '%0'不支持rv%select{32|64}1"
# "current API version is '%0', but plugin was compiled with version '%1'"
H399ED19E4A74: "当前API版本是'%0'，但插件是使用版本'%1'编译的"
# 'current file is older than dependency %0'
HCE89B30434E7: '当前文件比依赖项%0更旧'
# "current handling of vector bool and vector pixel types in this context are deprecated; the default behaviour will soon change to that implied by the '-altivec-compat=xl' option"
H2144886C992F: "在此上下文中处理向量布尔类型和向量像素类型的方式已弃用；默认行为将很快更改为由'-altivec-compat=xl'选项暗示的行为"
# "current_version does not match: '%0' (provided) vs '%1' (found)"
H84F45A8B13FB: "current_version不匹配：提供的'%0'与找到的'%1'"
# "cycle in acquired_before/after dependencies, starting with '%0'"
HCB49175AA5FC: "在acquired_before/after依赖项中存在循环，起始于'%0'"
# "cyclic dependency in module '%0': %1"
H2C783846485B: "模块'%0'中存在循环依赖：%1"
# 'data argument not used by format string'
HB79E446EA7A1: '数据参数未被格式字符串使用'
# "data argument position '%0' exceeds the number of data arguments (%1)"
H3A25FAA1F4B4: "数据参数位置'%0'超过了数据参数的数量(%1)"
# 'data member instantiated with function type %0'
HE2AF1A6B9D7C: '用函数类型%0实例化的数据成员'
# "data-sharing attribute '%0' in '%1' clause requires OpenMP version %2 or above"
H12FB4E840EF7: "'%1'子句中的数据共享属性'%0'需要OpenMP版本%2或更高"
# "dealloc return type must be correctly specified as 'void' under ARC, instead of %0"
HF5C8E84C253E: "在ARC下，dealloc的返回类型必须正确指定为'void'，而不是%0"
# "debug information option '%0' is not supported for target '%1'"
H53B68E933A49: '调试信息选项‘%0’不支持目标‘%1’'
# "debug information option '%0' is not supported; requires DWARF-%2 but target '%1' only provides DWARF-%3"
HBD9D2872B134: '调试信息选项‘%0’不支持；需要DWARF-%2，但目标‘%1’仅提供DWARF-%3'
# "declaration %0 attached to named module '%1' cannot be attached to other modules"
H238E4BEFC413: '已附加到命名模块‘%1’的声明%0无法附加到其他模块'
# "declaration %0 is detected to be defined in multiple module units, first is from '%1' and second is from '%2'; the compiler may not be good at merging the definitions. "
H96F07A99E632: '检测到声明%0在多个模块单元中定义，第一个来自‘%1’，第二个来自‘%2’；编译器可能无法有效合并这些定义。'
# "declaration '%0' is %select{weak defined|thread local}1, but symbol is not in dynamic library"
HFB32CBE0F1C5: '声明‘%0’是%select{弱定义|线程局部}1，但符号不在动态库中'
# "declaration '%0' is marked %select{available|unavailable}1, but symbol is %select{not |}2exported in dynamic library"
H01B92D3A7F34: '声明‘%0’被标记为%select{可用|不可用}1，但符号在动态库中%select{未|}2导出'
# "declaration cannot be inferred '%0' because it has no definition in this translation unit"
HFACBBC5D211B: '无法推断声明‘%0’，因为它在此翻译单元中没有定义'
# 'declaration conflicts with target of using declaration already in scope'
HF0A04A0DD736: '声明未声明任何参数'
# 'declaration does not declare a parameter'
HAB6C8E5E5B42: '该声明未声明任何内容'
# 'declaration does not declare anything'
HCF31319302C2: '声明未声明任何内容'
# "declaration has external linkage, but dynamic library doesn't have symbol '%0'"
H867521795963: '该声明具有外部链接，但在动态库‘%0’中符号具有内部链接'
# "declaration has external linkage, but symbol has internal linkage in dynamic library '%0'"
H51741F52DD27: "声明具有外部链接，但在动态库 '%0' 中符号具有内部链接"
# 'declaration hides type'
HBEC56FF31D60: '接口中的声明'
# 'declaration in interface'
HA49C5D70160C: '接口中的声明'
# "declaration in interface is not in the '%select{alloc|copy|init|new}0' family because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1"
H135EF0608D60: "接口中的声明不属于 '%select{alloc|copy|init|new}0' 家族，因为 %select{其结果类型不是对象指针|其结果类型与接收类型无关}1"
# "declaration is marked with '%select{\\|@}0deprecated' command but does not have a deprecation attribute"
H7C7F3BB153A5: "带有 '%select{\\|@}0deprecated' 命令的声明缺少废弃属性"
# 'declaration is not declared in any declare target region'
H519107FB97C7: '声明在首次使用后被标记为声明目标，可能导致结果不正确'
# 'declaration marked as declare target after first use, it may lead to incorrect results'
HB5487BD38E68: '缺少‘[[carries_dependency]]’属性的声明在此处'
# "declaration missing '[[carries_dependency]]' attribute is here"
H0D046CE0EB0D: "未标记 '[[carries_dependency]]' 属性的声明在此处"
# 'declaration of %0 does not match'
H12CB12FACAA5: '%0 的声明不匹配'
# 'declaration of %0 has a different language linkage'
HB8AA7E6F59F0: '%0 的声明具有不同的语言链接性'
# 'declaration of %0 in %select{the global module|module %2}1 follows declaration in %select{the global module|module %4}3'
HCB7EF6CCFFAA: '%0 在 %select{全局模块|模块 %2}1 的声明跟随了 %select{全局模块|模块 %4}3 的声明'
# 'declaration of %0 is missing in %1 class'
HCE379B9B6B0B: '%1 类中缺少 %0 的声明'
# "declaration of %0 overrides a '%select{final|sealed}1' function"
H49FDD9D92060: "%0 的声明覆盖了一个 '%select{final|sealed}1' 函数"
# 'declaration of %0 shadows template parameter'
HB1AA8E00948E: '%0 的声明遮蔽了模板参数'
# 'declaration of %0 will not be visible outside of this function'
H1E299D7E36E1: '%0 的声明在函数外部不可见'
# 'declaration of %0 with internal linkage cannot be exported'
HB1BC44F22B13: '具有内部链接性的 %0 的声明无法导出'
# 'declaration of %1 %select{with C language linkage|in global scope}0 conflicts with declaration %select{in global scope|with C language linkage}0'
HADF36ADC7505: '%1 %select{具有C语言链接性|在全局作用域中}0 的声明与 %select{全局作用域中的|具有C语言链接性}0 的声明冲突'
# "declaration of a variadic function without a comma before '...' is deprecated"
HF12988516A95: "在 '...' 前缺少逗号的可变参数函数声明已弃用"
# 'declaration of anonymous %0 must be a definition'
H1EBFCC5461F9: '匿名 %0 的声明必须是一个定义'
# 'declaration of block scope identifier with linkage cannot have an initializer'
HDD3AC9280BE3: '具有链接性的块作用域标识符的声明不能具有初始化器'
# "declaration of built-in function '%0' requires the declaration of the 'jmp_buf' type, commonly provided in the header <setjmp.h>"
H8F1CDE7D22C0: "内置函数 '%0' 的声明需要声明 'jmp_buf' 类型，该类型通常在头文件 <setjmp.h> 中提供"
# "declaration of built-in function '%1' requires inclusion of the header <%0>"
H059DBCAF4C02: "内置函数 '%1' 的声明需要包含头文件 <%0>"
# 'declaration of constexpr static data member %0 requires an initializer'
HCFAE74ED9FCD: 'constexpr 静态数据成员 %0 的声明需要初始值设定项'
# 'declaration of instance variables in the interface is deprecated'
HF2C25CBD493E: "在 'for' 循环中声明了非局部变量"
# "declaration of non-local variable in 'for' loop"
HBFAC0B86B48E: "在 'for' 循环中声明非局部变量是C23扩展"
# "declaration of non-local variable in 'for' loop is a C23 extension"
H82E18D14C9A2: "在 'for' 循环中声明非局部变量与C23之前的标准不兼容"
# "declaration of non-local variable in 'for' loop is incompatible with C standards before C23"
H1C8715C3541C: "'for' 循环中的非局部变量声明与 C23 之前的 C 标准不兼容"
# 'declaration of reference variable %0 requires an initializer'
H8635EDA9A8C6: '引用变量 %0 的声明需要初始化器'
# 'declaration of variable %0 with deduced type %1 requires an initializer'
H737154EADE2A: '类型推导为 %1 的变量 %0 的声明需要初始化器'
# 'declaration requires a global constructor'
H55DC760EFFEA: '该声明需要全局构造函数'
# 'declaration requires a global destructor'
H7852FAA15ED5: '该声明需要全局析构函数'
# 'declaration requires an exit-time destructor'
H86CA276EEC00: '该声明需要退出时析构函数'
# 'declaration shadows a %select{local variable|variable in %2|static data member of %2|field of %2|typedef in %2|type alias in %2|structured binding}1'
H68CDFAD663DD: '该声明遮蔽了 %select{局部变量|%2 中的变量|%2 的静态数据成员|%2 的字段|%2 中的 typedef|%2 中的类型别名|结构化绑定}1'
# 'declaration uses __weak, but ARC is disabled'
H1C8188316ADE: '该声明使用了 __weak，但 ARC 已禁用'
# 'declaration uses __weak, which the current deployment target does not support'
HEB22F5D20508: '该声明使用了 __weak，而当前部署目标不支持'
# 'declaration uses type that is ill-formed in ARC'
H522AD27CDFBF: '该声明使用了在 ARC 中格式错误的类型'
# 'declarator requires an identifier'
HB85D316E7D82: '声明符需要标识符'
# "declare 'static' if the %select{variable|function}0 is not intended to be used outside of this translation unit"
H5D50A42530DC: "如果 %select{变量|函数}0 不打算在本翻译单元外使用，请声明为 'static'"
# 'declare the parameter __strong or capture a __block __strong variable to keep values alive across autorelease pools'
H9B7134A463BB: '声明参数为 __strong 或捕获一个 __block __strong 变量，以在自动释放池间保持值的有效性'
# "declared %select{'returns_nonnull'|'nonnull'}0 here"
H9D136543BAF2: "此处声明 %select{'returns_nonnull'|'nonnull'}0"
# 'declared %select{in global scope|with C language linkage}0 here'
H3DB72872F2B8: '此处声明 %select{在全局作用域|具有 C 语言链接性}0'
# 'declared as a non-template here'
H65BA70C7322E: '此处声明为非模板'
# 'declared here'
HA1E35E29C81D: '此处声明'
# 'declared here with type %0'
H880F1F3D3828: '此处声明类型为 %0'
# "declared here%select{ in module '%1'|}0"
HD4C36AE9FEF2: "此处声明%select{ 在模块 '%1'|}0"
# 'declared with %0 attribute here'
H98D954FCA941: '此处用 %0 属性声明'
# "declared with class '%0' here"
HA2F652501D84: "此处用类 '%0' 声明"
# 'declared with index %0 here'
H29E8DAE209C5: '此处用索引%0声明'
# 'declaring function parameter of type %0 is not allowed%select{; did you forget * ?|}1'
H45BA30613376: '不允许声明类型为%0的函数参数%select{; 是否忘记添加*？|}1'
# 'declaring function return value of type %0 is not allowed %select{; did you forget * ?|}1'
HC0F56D942DA5: '不允许声明类型为%0的函数返回值%select{; 是否忘记添加*？|}1'
# "declaring overloaded %0 as 'static' is a C++23 extension"
H3416DF62F662: "将重载的%0声明为'static'是C++23扩展"
# "declaring overloaded %0 as 'static' is incompatible with C++ standards before C++23"
HE846DD4F137C: "将重载的%0声明为'static'与C++23之前的标准不兼容"
# 'declaring variable of type %0 is not allowed'
HCC1ADB51903E: '不允许声明类型为%0的变量'
# 'decomposition declaration %0 requires an initializer'
H745CF12AB2DC: '分解声明%0需要初始值设定项'
# 'decomposition declaration cannot be a template'
H12444CAF9EB2: '分解声明不能是模板'
# "decomposition declaration cannot be declared %plural{1:'%1'|:with '%1' specifiers}0"
HEDAF4E9407D4: "分解声明不能被声明%plural{1:'%1'|:具有'%1'说明符}0"
# "decomposition declaration cannot be declared with constrained 'auto'"
H33CAEB57113F: "分解声明不能被声明为具有约束条件的'auto'"
# 'decomposition declaration cannot be declared with parentheses'
H02314396E4F0: '分解声明不能用括号声明'
# "decomposition declaration cannot be declared with type %0; declared type must be 'auto' or reference to 'auto'"
H3DD0947995B7: "分解声明声明的类型%0无效；声明类型必须为'auto'或'auto'的引用"
# "decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is a C++20 extension"
HED6397EE7170: "分解声明被声明%plural{1:'%1'|:具有'%1'说明符}0是C++20扩展"
# "decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is incompatible with C++ standards before C++20"
H3B1B7DD7D4A6: "分解声明被声明%plural{1:'%1'|:具有'%1'说明符}0与C++20之前的标准不兼容"
# 'decomposition declaration must be the only declaration in its group'
H36F7861E46A5: '分解声明必须是其组中的唯一声明'
# 'decomposition declaration not permitted in this context'
HE332CBDAE8B6: '当前上下文中不允许分解声明'
# 'decomposition declarations are a C++17 extension'
H41B58BACEDBD: '分解声明是C++17扩展'
# 'decomposition declarations are incompatible with C++ standards before C++17'
H6F6939D7899C: '分解声明与C++17之前的标准不兼容'
# 'deduced conflicting types %diff{($ vs $) |}0,1for initializer list element type'
H41EB8FB5647B: '推导出冲突的类型%diff{($ vs $)|}0,1作为初始列表元素类型'
# 'deduced incomplete pack %0 for template parameter %1'
H03080CBC4C1A: '为模板参数%1推导出未完成的包%0'
# 'deduced non-type template argument does not have the same type as the corresponding template parameter%diff{ ($ vs $)|}0,1'
H6489085BE16C: '推导出的非类型模板实参与对应的模板参数类型不一致%diff{ ($ vs $)|}0,1'
# "deduced return type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be 'auto', not %1"
H209B0E7EFC40: "默认实现的%select{<ERROR>|equality|three-way|equality|relational}0比较运算符的推导返回类型必须为'auto'，而非%1"
# 'deduced return types are a C++14 extension'
HB07F9BCAC63A: '推导返回类型是C++14扩展'
# 'deduced type %0 does not satisfy %1'
H9431BF910A33: '推导出的类型%0不满足%1'
# 'deduced type %1 of deduction guide is not %select{|written as }2a specialization of template %0'
H902D2FE80122: '推导指引的推导类型%1不是%select{|以}2模板%0的特化形式'
# 'deduction guide cannot be %select{explicitly instantiated|explicitly specialized}0'
HA3A632F69A86: '推导指引不能%select{显式实例化|显式特化}0'
# "deduction guide cannot be declared '%0'"
HF6365CFA8B89: "推导指引不能被声明为'%0'"
# 'deduction guide cannot have a function definition'
H7D3F7544A5EA: '推导指引不能有函数定义'
# 'deduction guide declaration without trailing return type'
H4EE056EE4349: '推导指引声明缺少尾随返回类型'
# 'deduction guide declared %0 by intervening access specifier'
HBCF8F59E9812: '推导指引被%0的访问说明符声明'
# 'deduction guide has different access from the corresponding member template'
H1030B70A50CA: '推导指引与对应的成员模板的访问权限不同'
# 'deduction guide must be declared in the same scope as template %q0'
H1F6362B2A695: '推导指引必须在与模板%q0相同的范围内声明'
# 'deduction guide template contains %select{a template parameter|template parameters}0 that cannot be deduced'
H9078590D8224: '推导指引模板包含%select{一个无法推导的模板参数|无法推导的模板参数}0'
# 'default %select{argument|non-type template argument}0 may not use a GNU statement expression'
HB2A0E2C3CEAE: '默认%select{参数|非类型模板参数}0不能使用GNU语句表达式'
# 'default argument declared here'
HDD61CA193DBE: '默认参数在这里声明'
# 'default argument not permitted on an explicit %select{instantiation|specialization}0 of function %1'
HA5116018194A: '显式%select{实例化|特化}0的函数%1不允许有默认参数'
# "default argument references 'this'"
H743C3B172B68: "默认参数引用了'this'"
# 'default argument references local variable %0 of enclosing function'
HAA8CD5949FC3: '默认参数引用了外部函数的局部变量%0'
# 'default argument references parameter %0'
H573EB7C93602: '默认参数引用了参数%0'
# 'default argument used here'
H2C2A14271D90: '默认参数在此处使用'
# 'default arguments can only be specified for parameters in a function declaration'
H910FAD8C4EA4: '默认参数只能为函数声明中的参数指定'
# 'default arguments cannot be added to a function template that has already been declared'
H2AD8ADEE046B: '不能为已声明的函数模板添加默认参数'
# 'default arguments cannot be added to an out-of-line definition of a member of a %select{class template|class template partial specialization|nested class in a template}0'
H2A1897D12086: '不能为%select{类模板|类模板的部分特化|模板中的嵌套类}0的成员的外部定义添加默认参数'
# 'default arguments not allowed for parameters of a requires expression'
H8AAADF6A99AF: '不允许为requires表达式参数的默认参数'
# 'default assign attribute on property %0 which implements NSCopying protocol is not appropriate with -fobjc-gc[-only]'
H8248EDB07821: '实现了NSCopying协议的属性%0的默认assign属性与-fobjc-gc[-only]不兼容'
# 'default capture by %select{value|reference}0'
H472BB89BA278: '默认按%select{值|引用}0捕获'
# 'default constructed field %0 declared here'
H948E9DA6EBAF: '默认构造的字段%0在此处声明'
# 'default initialization of an object of const type %0%select{| without a user-provided default constructor}1'
H303212CBDF84: 'const类型%0%select{|没有用户提供的默认构造函数}1的默认初始化'
# 'default initialization of an object of const type %0%select{| without a user-provided default constructor}1 is a Microsoft extension'
H48E5A1B64C89: 'const类型%0%select{|没有用户提供的默认构造函数}1的默认初始化是Microsoft扩展'
# 'default label in switch which covers all enumeration values'
HF1A67825B6F5: 'switch中的默认标签覆盖所有枚举值'
# 'default member initializer declared here'
H09B30FC3540B: '默认成员初始值设定项在此处声明'
# 'default member initializer for %0 uses itself'
H62A9561A4498: '成员%0的默认初始值设定项使用了自身'
# 'default member initializer for %1 needed within definition of enclosing class %0 outside of member functions'
HB4FBDC93A96D: '在外部类%0的成员函数外部定义时，需要为%1的默认成员初始值设定项'
# 'default member initializer for bit-field is a C++20 extension'
H960B2B591D79: '位字段的默认成员初始值设定项是C++20扩展'
# 'default member initializer for bit-field is incompatible with C++ standards before C++20'
H85717DD87366: '位字段的默认成员初始值设定项与C++20之前的C++标准不兼容'
# 'default member initializer for non-static data member is a C++11 extension'
HB1974A6508C8: '非静态数据成员的默认成员初始值设定项是C++11扩展'
# 'default member initializer for non-static data members is incompatible with C++98'
H75DECF5B5D30: '非静态数据成员的默认成员初始值设定项与C++98标准不兼容'
# "default property attribute 'assign' not appropriate for object"
HBAC11B3F8368: "对象的默认属性'assign'不适用"
# 'default scope specifier for attributes is a C++17 extension'
H9959B28B39FE: '属性的默认作用域限定符是C++17扩展'
# 'default scope specifier for attributes is incompatible with C++ standards before C++17'
HCB10ABA8102F: '属性的默认作用域限定符与C++17之前的C++标准不兼容'
# 'default template argument for a template template parameter must be a class template'
H3FA43EDB90ED: '模板模板参数的默认模板实参必须是一个类模板'
# 'default template argument in a class template partial specialization'
H57E58A1F67E6: '类模板的部分特化中不允许有默认模板实参'
# 'default template argument not permitted on a friend template'
H1B3D975772BB: '不允许在友元模板上使用默认模板实参'
# 'default template arguments for a function template are a C++11 extension'
H94B1EDF48980: '函数模板的默认模板实参是C++11扩展'
# 'default template arguments for a function template are incompatible with C++98'
H688888558286: '函数模板的默认模板实参与C++98不兼容'
# 'defaulted %0 is implicitly deleted because %2 is a %select{union-like class|union}1 with variant members'
HAADBD633A7F2: '默认的%0因隐式删除，因为%2是具有变体成员的%select{类似联合的类|联合}1'
# 'defaulted %0 is implicitly deleted because a builtin comparison function using this conversion would be the best match for the comparison'
H6F959181B71C: '默认的%0因隐式删除，因为使用该转换的内置比较函数会成为比较的最佳匹配'
# 'defaulted %0 is implicitly deleted because class %1 has a reference member'
HDDAEEF62F6DD: '默认的%0因隐式删除，因为类%1有引用成员'
# "defaulted %0 is implicitly deleted because implied %select{|'==' |'<' }1comparison %select{|for member %3 |for base class %3 }2is ambiguous"
H8204A4BEFE67: "默认的%0因隐式删除，因为隐含的%select{|'==' |'<' }1比较%select{|对于成员%3 |对于基类%3 }2是模棱两可的"
# 'defaulted %0 is implicitly deleted because it would invoke a %select{private|protected}3 %4%select{ member of %6| member of %6 to compare member %2| to compare base class %2}1'
HA2763C071EBA: '默认的%0因隐式删除，因为它会调用%select{private|protected}3 %4%select{ 的%6成员|的%6成员来比较成员%2|来比较基类%2}1'
# 'defaulted %0 is implicitly deleted because it would invoke a deleted comparison function%select{| for member %2| for base class %2}1'
H73AE2279ECF2: '默认的 %0 被隐式删除，因为它会调用已删除的比较函数%select{|的成员 %2|的基类 %2}1'
# "defaulted %0 is implicitly deleted because there is no viable %select{three-way comparison function|'operator=='}1 for %select{|member |base class }2%3"
HC9957DD8DD53: "默认的%0因隐式删除，因为%select{|成员 |基类 }2%3没有可用的%select{三向比较函数|'operator=='}1"
# 'defaulted %0 is implicitly deleted because this non-rewritten comparison function would be the best match for the comparison'
H5A66B2776E93: '默认的%0因隐式删除，因为此未重写的比较函数会成为比较的最佳匹配'
# 'defaulted comparison function must not be volatile'
H50500CCE550F: '默认的比较函数不能声明为volatile'
# 'defaulted comparison operators are a C++20 extension'
H17EA10D2ACC2: '默认比较运算符是C++20扩展'
# 'defaulted comparison operators are incompatible with C++ standards before C++20'
H38C2AF56B86F: '默认比较运算符与C++20之前的C++标准不兼容'
# "defaulted definition of %select{%select{<ERROR>|equality|three-way|equality|relational}1 comparison operator|three-way comparison operator}0 cannot be declared %select{constexpr|consteval}2 because %select{it|for which the corresponding implicit 'operator==' }0 invokes a non-constexpr comparison function"
HDA596C603C53: '默认的%select{%select{<ERROR>|相等性|三向|相等性|关系性}1比较运算符|三向比较运算符}0不能声明为%select{constexpr|consteval}2，因为%select{它|对应隐式operator==的}0调用了非constexpr比较函数'
# 'defaulted definition of %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be marked %select{constexpr|consteval}1 before C++23'
H5C1B0C179374: '默认的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0在C++23之前不能标记为%select{constexpr|consteval}1'
# 'defaulted member %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be const-qualified'
H8A22F945F946: '默认的%select{<ERROR>|相等性|三向|相等性|关系性}0比较运算符必须有const限定符'
# 'defaulted move assignment operator of %0 will move assign virtual base class %1 multiple times'
HC302B71D801C: '类型%0的默认移动赋值运算符将多次移动赋值虚基类%1'
# "defaulting %select{this %select{<ERROR>|equality|three-way|equality|relational}1 comparison operator|the corresponding implicit 'operator==' for this defaulted 'operator<=>'}0 would delete it after its first declaration"
HCBD1D13B7A08: "默认实现%select{这个 %select{<ERROR>|相等性|三向|相等性|关系}1 比较运算符|对应隐式 'operator==' 的这个默认 'operator<=>' }0 会删除其首次声明后的实现"
# 'defaulting this %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is not allowed because it was already declared outside the class'
H21E3B4CFF46D: '默认实现这个 %select{<ERROR>|相等性|三向|相等性|关系}0 比较运算符是不允许的，因为它已在类外声明过'
# 'defaulting this %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 would delete it after its first declaration'
H7E7544692CE2: '默认实现这个 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0 会删除其首次声明后的实现'
# 'defined as %0'
H95D82B9347CA: '定义为 %0'
# "defining a type within '%select{__builtin_offsetof|offsetof}0' is a C23 extension"
HB6CCA72E4AE1: "在 '%select{__builtin_offsetof|offsetof}0' 内定义类型是 C23 扩展"
# 'definition %0 cannot also be an %select{alias|ifunc}1'
HEAC49AC815B1: '%select{别名|ifunc}1 不能同时是 %0 的定义'
# 'definition has no member %0'
HF2870D3EBBD2: '定义中没有成员 %0'
# "definition in module '%0' is here"
HD03996A6AE5C: "模块 '%0' 中的定义在此处"
# "definition of %0 is not complete until the closing '}'"
H6A431AA48FA1: "%0 的定义在闭合的 '}' 之前未完成"
# 'definition of a %select{static variable|thread_local variable|variable of non-literal type}1 in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
HE9E063DA4F95: '在 constexpr %select{函数|构造函数}0 中定义 %select{静态变量|线程局部变量|非字面量类型变量}1 不兼容 C++23 之前的版本标准'
# 'definition of a %select{static|thread_local}1 variable in a constexpr %select{function|constructor}0 is a C++23 extension'
H398F375C6A6A: '在 constexpr %select{函数|构造函数}0 中定义 %select{静态|线程局部}1 变量是 C++23 扩展'
# 'definition of builtin function %0'
HC9CC697C220C: '内置函数 %0 的定义'
# 'definition of class %0 must be available to use Objective-C %select{array literals|dictionary literals|numeric literals|boxed expressions|string literals}1'
H852A8FF09E04: '为使用 Objective-C %select{数组字面量|字典字面量|数值字面量|装箱表达式|字符串字面量}1，类 %0 必须提供完整定义'
# 'definition of dllimport data'
HBDC4BCE4EB33: 'dllimport 数据的定义'
# 'definition of dllimport static field'
H64DF6CE31868: 'dllimport 静态字段的定义'
# 'definition of dllimport static field not allowed'
H8C1897964645: '不允许定义 dllimport 静态字段'
# 'definition of explicitly defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0'
H1522F98BEB4D: '显式默认实现的 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数|函数}0'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared copy %select{assignment operator|constructor}1'
H069CBC304A15: '%0 的隐式拷贝 %select{构造函数|赋值运算符}1 已弃用，因为其包含用户声明的拷贝 %select{赋值运算符|构造函数}1'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared destructor'
H423281D39FA7: '%0 的隐式拷贝 %select{构造函数|赋值运算符}1 已弃用，因为其包含用户声明的析构函数'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided copy %select{assignment operator|constructor}1'
H3C23BCA5B3D2: '%0 的隐式拷贝 %select{构造函数|赋值运算符}1 已弃用，因为其包含用户提供的拷贝 %select{赋值运算符|构造函数}1'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided destructor'
H396EB4CE9202: '隐式拷贝的%select{构造函数|赋值运算符}1的定义对%0已被弃用，因为其提供了用户定义的析构函数'
# 'definition of implicitly declared %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}1'
H86596A04E020: '隐式声明的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数|函数}1的定义'
# 'definition of macro %0 does not match definition in precompiled header'
H79B9B4BA8FFF: '宏%0的定义与预编译头中的定义不匹配'
# "definition of macro '%0' differs between the AST file '%3' ('%1') and the command line ('%2')"
H40BB23B29C3F: "宏'%0'在AST文件'%3'（'%1'）和命令行（'%2'）中的定义不同"
# "definition of module '%0' is not available; use -fmodule-file= to specify path to precompiled module interface"
H1ED33479DE5D: "模块'%0'的定义不可用；请使用-fmodule-file=指定预编译模块接口的路径"
# 'definition of type %0 conflicts with %select{typedef|type alias}1 of the same name'
H5C3C4CCA94AB: '类型%0的定义与同名的%select{typedef|类型别名}1冲突'
# 'definition of variable with array type needs an explicit size or an initializer'
H79E09A4784DB: '具有数组类型的变量定义需要显式指定大小或初始化器'
# 'definition or redeclaration of %0 cannot name the global scope'
H3AC58FC9EA5A: '%0的定义或重新声明不允许出现在全局作用域'
# 'definition or redeclaration of %0 not allowed inside a block'
HD4328CF55600: '%0的定义或重新声明不允许出现在块内部'
# 'definition or redeclaration of %0 not allowed inside a function'
H26DE3CAC54F0: '%0的定义或重新声明不允许出现在函数内部'
# "definition with same mangled name '%0' as another definition"
H9CD626C8B999: "与另一个定义具有相同的装饰名称'%0'"
# 'defsym must be of the form: sym=value: %0'
H633B95A139C3: 'defsym必须采用形式：sym=value: %0'
# 'delegating constructors are incompatible with C++98'
H57A554A5A2B8: '委派构造函数与C++98不兼容'
# 'delegating constructors are permitted only in C++11'
H859BD39058E0: '仅允许在C++11中使用委派构造函数'
# 'delete of object with dynamic type %1 through pointer to base class type %0 with non-virtual destructor'
H2817C3914B5E: '通过基类类型%0的指针删除动态类型为%1的对象，而该基类未声明虚析构函数'
# "delete of pointer '%0' that does not point to a heap-allocated object"
H8B4F3ED0F000: "删除指向非堆分配对象的指针'%0'"
# 'delete of pointer that has already been deleted'
H42BC8DFBCECC: '删除已被释放的指针'
# "delete of pointer%select{ to subobject|}1 '%0' %select{|that does not point to complete object}1"
H4DFF941C0746: '删除%select{子对象|}1的指针%select{|不指向完整对象}1的指针%0'
# 'deleted definition must be first declaration'
H0F602982588E: '被删除的定义必须是首次声明'
# 'deleted function %0 cannot override a non-deleted function'
H3FCDC44C217B: '被删除的函数%0不能覆盖非删除函数'
# 'deleting incomplete class type %0; no conversions to pointer type'
H9074591E0AF3: '删除不完整类类型%0；无法转换为指针类型'
# 'deleting pointer to incomplete type %0 is incompatible with C++2c and may cause undefined behavior'
H0FC4BDC8CA1F: '删除指向不完整类型%0的指针与C++2c不兼容，可能导致未定义行为'
# 'delimited escape sequence cannot be empty'
H5E38AA141B13: '界定转义序列不能为空'
# 'delimited escape sequences are incompatible with C standards before C2y'
H21BCF42E1D91: '界定转义序列与C2y之前的C标准不兼容'
# "depend modifier cannot be used with 'sink' or 'source' depend type"
H92A125FCC1F2: "depend修饰符不能与'sink'或'source' depend类型一起使用"
# 'dependent %select{__if_not_exists|__if_exists}0 declarations are ignored'
H7E0205C30EB0: '依赖的%select{__if_not_exists|__if_exists}0声明被忽略'
# 'dependent nested name specifier %0 for friend class declaration is not supported; turning off access control for %1'
H6C7EBDCCA541: '依赖的嵌套名称指定符%0用于友元类声明不受支持；禁用%1的访问控制'
# 'dependent nested name specifier %0 for friend template declaration is not supported; ignoring this friend declaration'
H5BCC077F4A6E: '依赖的嵌套名称指定符%0用于友元模板声明不受支持；忽略此友元声明'
# "dependent using declaration resolved to type without 'typename'"
H9473A34B51B9: "依赖的using声明解析为不带'typename'的类型"
# 'dereference of pointer to incomplete type %0'
H2DF43C211998: '解引用指向不完整类型%0的指针'
# 'dereference of type %1 that was reinterpret_cast from type %0 has undefined behavior'
H90FCF362143A: '对类型%0经reinterpret_cast转换为类型%1后的解引用会导致未定义行为'
# 'dereferenced pointer past the end of %select{|subobject of }0%select{temporary|%2}1 is not a constant expression'
H22AD60D3A378: '解引用超出%select{|子对象的 }0%select{临时对象|%2}1末尾的指针不是一个常量表达式'
# "dereferencing %0; was declared with a 'noderef' type"
H77B30DE9BC36: "解引用%0；该类型被声明为'noderef'"
# 'dereferencing a __weak pointer is not allowed due to possible null value caused by race condition, assign it to strong variable first'
H69A87CE8BA55: '由于竞态条件可能导致空值，不允许解引用__weak指针，请先将其赋值给strong变量'
# "dereferencing expression marked as 'noderef'"
HB6D67B14D60F: "解引用标记为'noderef'的表达式"
# 'derived class must specify the same code segment as its base classes'
HF7C9EF85294D: '派生类必须指定与基类相同的代码段'
# 'designated initializer invoked a non-designated initializer'
H504DCC34F2E8: '命名初始化器调用了非命名初始化器'
# "designated initializer missing a 'super' call to a designated initializer of the super class"
H94AB45A96460: "命名初始化器缺少对超类命名初始化器的'super'调用"
# "designated initializer should only invoke a designated initializer on 'super'"
H2306DCB92F88: "命名初始化器应仅在'super'上调用命名初始化器"
# 'designated initializers are a C++20 extension'
H868FB6A7DCFA: '命名初始化器是C++20扩展'
# 'designated initializers are a C99 feature'
HCE690B2EFB92: '指定初始化器是C99的特性'
# 'designated initializers are incompatible with C++ standards before C++20'
HB212F1F17A19: '指定初始化器与C++20之前的C++标准不兼容'
# 'designator in initializer for %select{scalar|indivisible sizeless}0 type %1'
HDC0C952FB90A: '%select{标量|不可分割且无大小}0类型%1的初始化器中的指定符'
# 'designator into flexible array member subobject'
H596716C96072: '指定符进入柔性数组成员子对象'
# "destroying object '%0' whose lifetime has already ended"
H480FFC7A6CDF: "销毁生命周期已结束的对象'%0'"
# 'destroying operator delete can have only an optional size and optional alignment parameter'
H05866AB32F25: '销毁用的operator delete只能有可选的大小和可选的对齐参数'
# 'destruction of individual component of complex number is not yet supported in constant expressions'
H6533BAA0653D: '复数的单个组件的销毁在常量表达式中尚未得到支持'
# 'destruction of object that is already being destroyed'
HBC86CD58BD53: '正在销毁已被销毁的对象'
# 'destructor cannot be declared %select{<ERROR>|constexpr|consteval|constinit}0'
H39B25D41B01F: '析构函数不能声明为%select{<ERROR>|constexpr|consteval|constinit}0'
# 'destructor cannot be declared %select{<ERROR>|constexpr|consteval|constinit}0 because %select{data member %2|base class %3}1 does not have a constexpr destructor'
HEA62090F1654: '析构函数不能声明为%select{<ERROR>|constexpr|consteval|constinit}0，因为%select{数据成员%2|基类%3}1没有constexpr析构函数'
# "destructor cannot be declared '%0'"
H18788E54B072: "析构函数不能声明为'%0'"
# 'destructor cannot be declared as a template'
H2A9016676C0B: '析构函数不能声明为模板'
# 'destructor cannot be declared using a %select{typedef|type alias}1 %0 of the class name'
HD2E86EDB043A: '不能使用类名的%select{typedef|类型别名}1 %0来声明析构函数'
# 'destructor cannot be redeclared'
H7C102E557BD9: '析构函数不能被重新声明'
# 'destructor cannot be variadic'
H3060C3D6CE56: '析构函数不能是可变参数的'
# 'destructor cannot have a return type'
HB61BE667BB0D: '析构函数不能有返回类型'
# 'destructor cannot have any parameters'
H27289F072FC5: '析构函数不能有任何参数'
# 'destructor for %0 is not trivial because it is virtual'
H695A7FB4C51A: '%0的析构函数不是平凡的，因为它为虚析构函数'
# 'destructor must be a non-static member function'
HE5AA51DEFC74: '析构函数必须是一个非静态成员函数'
# 'destructor name %0 does not refer to a template'
H6A0A4776F7D0: '析构函数名%0不指向一个模板'
# 'destructor of class %0 is ambiguous'
H29DC1463BFE1: '类%0的析构函数存在二义性'
# 'destructor type %0 in object destruction expression does not match the type %1 of the object being destroyed'
HCA02CE698CF6: '对象销毁表达式中的析构函数类型%0与被销毁对象的类型%1不匹配'
# 'detected while default synthesizing properties in class implementation'
HDACD480D581B: '在类实现中默认合成属性时检测到'
# "device clause with ancestor device-modifier used without specifying 'requires reverse_offload'"
H7C03F0398F87: '在未指定"requires reverse_offload"的情况下使用带有祖先设备修饰符的设备子句'
# 'diagnostic formatting in SARIF mode is currently unstable'
HADEECC0D1814: 'SARIF模式下的诊断信息格式目前还不稳定'
# 'diagnostic msg: %0'
H1318B5E4A90B: '诊断信息：%0'
# "did not expect %0 '%2' to be managed by '%1'"
H41E6876DEC05: '未预期"%2"（%0）会被"%1"管理'
# "did not find header '%0' in framework '%1' (loaded from '%2')"
H33EA4C9E31A5: '在框架"%1"（从"%2"加载）中未找到头文件"%0"'
# "did you forget ';'?"
H5762CA5BE293: '是否漏掉了";"？'
# "did you intend to use '#pragma pack (pop)' instead of '#pragma pack()'?"
H38F2C3CF1911: '是否应使用"#pragma pack(pop)"而不是"#pragma pack()"？'
# "did you mean %0 ('%2' U+%1)?"
H034E19BAF4DB: '是否是指%0（"%2" U+%1）？'
# 'did you mean %0?'
H0AFE75F407BD: '是否是指%0？'
# 'did you mean %select{struct|interface|class}0 here?'
H2F94B54CE3AD: '此处是否是指%select{struct|interface|class}0？'
# "did you mean '%0'?"
HC2D29273BC0C: '是否是指"%0"？'
# "did you mean 'using namespace'?"
H7384271A4FC4: '是否是指"using namespace"？'
# "did you mean to %select{dereference the argument to 'sizeof' (and multiply it by the number of elements)|remove the addressof in the argument to 'sizeof' (and multiply it by the number of elements)|provide an explicit length}0?"
H206E38ACCE90: '是否应%select{对"sizeof"的参数进行解引用（并乘以元素数量）|移除"sizeof"参数中的取地址运算符（并乘以元素数量）|提供显式的长度}0？'
# 'did you mean to call the %0 method?'
H0FF3D4ADDC94: '是否应调用%0方法？'
# 'did you mean to compare the result of %0 instead?'
HA27A0B6056FB: '是否应比较%0的结果？'
# "did you mean to use '%0'?"
H18F66684E290: '是否应使用"%0"？'
# "did you mean to use '.' instead?"
HE2F23CD42B59: '是否应使用"."？'
# "did you mean to use '\\u'?"
H8EB1B38F64B3: '您是否想使用‘\\u’？'
# "did you mean to use 'typename'?"
HA177681AD789: "您是否想使用'typename'？"
# 'did you mean to use __block %0?'
H6A59F85FFA80: '您是否想使用__block %0？'
# "differing user-defined suffixes ('%0' and '%1') in string literal concatenation"
HD69068F6D5EE: "字符串字面量连接时用户定义的后缀不同（'%0'和'%1'）"
# 'digit separator cannot appear at %select{start|end}0 of digit sequence'
HC90158811A8B: '数字分隔符不能出现在数字序列的%select{开始|结束}0处'
# 'digit separators are incompatible with C standards before C23'
H45FD89D6E3CC: '数字分隔符与C23之前的C标准不兼容'
# 'digit separators are incompatible with C++ standards before C++14'
H14907D30B29E: '数字分隔符与C++14之前的C++标准不兼容'
# 'dimension expression does not evaluate to a constant unsigned int'
H7ABEC48E09A3: '维度表达式未计算为常量无符号整数'
# "direct access to Objective-C's isa is deprecated in favor of object_getClass()"
H9F7CC297D241: '直接访问Objective-C的isa已弃用，建议使用object_getClass()'
# 'direct attribute on property %0 ignored (not implemented by this Objective-C runtime)'
H4EFEDE46DF56: '属性%0的direct属性被忽略（此Objective-C运行时未实现该功能）'
# 'direct base %0 is inaccessible due to ambiguity:%1'
HB8D80890A48E: '直接基类%0由于以下歧义不可访问：%1'
# 'direct comparison of %select{an array literal|a dictionary literal|a numeric literal|a boxed expression|}0 has undefined behavior'
HB492D0D3EB6E: '直接比较%select{数组字面量|字典字面量|数值字面量|包装表达式|}0会导致未定义行为'
# 'direct comparison of a string literal has undefined behavior'
H32F54A871B25: '直接比较字符串字面量会导致未定义行为'
# 'direct member declared here'
H29E544F12128: '直接成员在此处声明'
# 'direct method %0 declared here'
HFC16D00B1613: '直接方法%0在此处声明'
# 'direct method implementation was previously declared not direct'
HD4855D6E8730: '直接方法实现之前声明为非直接'
# 'direct method was declared in %select{the primary interface|an extension|a category}0 but is implemented in %select{the primary interface|a category|a different category}1'
HE6AB93C50673: '在%select{主接口|扩展|分类}0中声明而在%select{主接口|分类|不同分类}1中实现'
# 'direct property cannot be @dynamic'
HE7907E55F6FD: '直接属性不能为@dynamic'
# "directive '#pragma omp %0' cannot contain more than one '%1' clause%select{| with '%3' name modifier| with 'source' dependence}2"
H4FF8713761CF: "指令'#pragma omp %0'不能包含超过一个'%1'子句%select{|带有'%3'名称修饰符|带有'source'依赖}2"
# "directive '#pragma omp %0' cannot contain more than one 'seq_cst',%select{ 'relaxed',|}1 'acq_rel', 'acquire' or 'release' clause"
HAC63F783B13F: "指令'#pragma omp %0'不能包含超过一个'seq_cst',%select{ 'relaxed',|}1 'acq_rel', 'acquire'或'release'子句"
# "directive '#pragma omp %0' requires the '%1' clause"
H54115AA95D6F: "指令 '#pragma omp %0' 需要 '%1' 子句"
# "directive '#pragma omp atomic%select{ %0|}1' cannot be used with '%2' clause"
H007A29406786: "指令 '#pragma omp atomic%select{ %0|}1' 不能与 '%2' 子句一起使用"
# "directive '#pragma omp atomic' cannot contain more than one 'read', 'write', 'update', 'capture', or 'compare' clause"
HE9B44E8E263B: "指令 '#pragma omp atomic' 不能包含超过一个 'read'、'write'、'update'、'capture' 或 'compare' 子句"
# "directive '#pragma omp taskwait' cannot use 'nowait' clause without 'depend' clause"
H6E17817BFD4B: "指令 '#pragma omp taskwait' 在没有 'depend' 子句的情况下不能使用 'nowait' 子句"
# 'directive may only be specified in protocols only'
H164583DA86CB: '指令只能在协议中指定'
# 'directive must be at file or namespace scope'
H1C3ABA756D9B: '指令必须位于文件或命名空间作用域'
# "directive name modifier '%0' is not allowed for '#pragma omp %1'"
H92E146113514: "指令名称修饰符 '%0' 不允许用于 '#pragma omp %1'"
# 'disabled expansion of recursive macro'
H7E32A887A37D: '禁用递归宏的展开'
# 'discriminator argument to ptrauth_sign_constant must be a constant integer, the address of the global variable where the result will be stored, or a blend of the two'
H24D055782EF6: 'ptrauth_sign_constant 的 discriminator 参数必须是一个常量整数、存储结果的全局变量的地址，或者是两者的结合'
# 'division by zero'
H3658877899CE: '除以零'
# 'division by zero in preprocessor expression'
H312B477ACFDB: '预处理器表达式中的除以零'
# 'dllimport cannot be applied to non-inline function definition'
H1B629BAD5F55: 'dllimport 不能应用于非内联函数定义'
# 'domain argument %0 does not point to an NSString or CFString constant'
H04276D1D8088: '域参数 %0 不指向 NSString 或 CFString 常量'
# 'domain argument %select{|%1 }0does not refer to global constant'
H427CD3AEDAC3: '域参数 %select{|%1 }0 不指向全局常量'
# 'double precision constant requires %select{cl_khr_fp64|cl_khr_fp64 and __opencl_c_fp64}0, casting to single precision'
H4D72ED1FA64B: '双精度常量需要 %select{cl_khr_fp64|cl_khr_fp64 和 __opencl_c_fp64}0，转换为单精度'
# 'double-quoted include "%0" cannot be aliased to angle-bracketed include <%1>'
H136E4A788F48: '双引号包含的 "%0" 不能别名为尖括号包含的 <%1>'
# 'double-quoted include "%0" in framework header, expected angle-bracketed instead'
H2D4306614026: '框架头文件中的双引号包含 "%0"，应使用尖括号包含'
# 'due to %0 being dllexported%select{|; try compiling in C++11 mode}1'
HB6A4EDE022F4: '由于 %0 被 dllexported%select{|; 尝试使用 C++11 模式编译}1'
# 'due to lvalue conversion of the controlling expression, association of type %0 will never be selected because it is %select{of array type|qualified}1'
HE4CE0D7DDF88: '由于控制表达式进行了左值转换，类型 %0 的关联永远不会被选中，因为它 %select{是数组类型|已限定}1'
# "duplicate %0 clause in an 'external_source_symbol' attribute"
H3523FE9C404F: "在 'external_source_symbol' 属性中重复了 %0 子句"
# "duplicate '%0' declaration specifier"
HD8ED5E5CBF0B: "重复的 '%0' 声明说明符"
# "duplicate 'virtual' in base specifier"
HA0A16A07E97F: "基类说明符中重复的 'virtual'"
# "duplicate asm qualifier '%0'"
HE8EA4F072983: "重复的 asm 限定符 '%0'"
# "duplicate attribute subject matcher '%0'"
H1D5786B873EA: "重复的属性对象匹配器 '%0'"
# "duplicate case value '%0'"
H4BDEA82874BB: "重复的 case 值 '%0'"
# "duplicate case value: '%0' and '%1' both equal '%2'"
HCE899F8A3E5C: "重复的 case 值：'%0' 和 '%1' 均等于 '%2'"
# 'duplicate code segment specifiers'
HBEFD6978776A: '重复的代码段说明符'
# 'duplicate declaration of method %0'
HA0EF6CBBD7AC: '方法 %0 的重复声明'
# 'duplicate default generic association'
H2C51601AE456: '重复的通用关联默认值'
# 'duplicate definition of category %1 on interface %0'
HECFD78DC0BC9: '接口 %0 上的分类 %1 的重复定义'
# 'duplicate explicit instantiation of %0'
HDBC529CD9977: '%0 的显式实例化重复'
# 'duplicate explicit instantiation of %0 ignored as a Microsoft extension'
HDA2A4AABFB51: '作为 Microsoft 扩展被忽略的 %0 显式实例化重复'
# 'duplicate interface definition for class %0'
H95CB7C0C6F7F: '类 %0 的重复接口定义'
# 'duplicate key in dictionary literal'
H048B82F688D2: '字典字面量中的重复键'
# 'duplicate macro parameter name %0'
H066136189F8C: '重复的宏参数名称 %0'
# 'duplicate member %0'
HC0ECCD41D310: '重复的成员 %0'
# "duplicate modifier '%0' in '%1' clause"
HF11C4EF9CA32: "在 '%1' 子句中重复的修饰符 '%0'"
# "duplicate module file extension block name '%0'"
HCCAD463A8663: "重复的模块文件扩展块名称 '%0'"
# 'duplicate nullability specifier %0'
HBA9CD0A409AC: '重复的空值限定符 %0'
# 'duplicate parameter modifier %0'
H6D49784340BA: '重复的参数修饰符 %0'
# 'duplicate protocol definition of %0 is ignored'
HD20F74839349: '%0 的重复协议定义将被忽略'
# 'duplicate use of asm operand name "%0"'
H3EAACD3C87CF: 'asm 操作数名称 "%0" 重复使用'
# "duplicated command '%select{\\|@}0%1'"
H76B78FD8FF48: "重复的命令'%select{\\|@}0%1'"
# 'during field initialization in %select{this|the implicit default}0 constructor'
H865BE3842864: '在 %select{this|the implicit default}0 构造函数的字段初始化期间'
# 'during template argument deduction for %select{class|variable}0 template %select{partial specialization |}1%2 %3'
H7650D46B8E2E: '在推导 %select{类|变量}0 模板 %select{部分特化 |}1%2 %3 的模板参数时'
# 'dxv not found; resulting DXIL will not be validated or signed for use in release environment'
H6BC661D7D75A: '未找到 dxv；生成的 DXIL 将不会被验证或签名，无法在发布环境中使用'
# 'dynamic exception specifications are deprecated'
H37FC9EB13E92: '动态异常规范已被弃用'
# 'dynamic exception specifications with types are currently ignored in wasm'
H3D36CC52AFBF: '在 wasm 中带有类型的动态异常规范当前会被忽略'
# 'dynamic initialization is not supported for __device__, __constant__, __shared__, and __managed__ variables'
H6251875A88D3: '__device__、__constant__、__shared__ 和 __managed__ 变量不支持动态初始化'
# "dynamic library symbol '%0' is %select{weak defined|thread local}1, but its declaration is not"
H876356229227: "动态库符号 '%0' 是 %select{弱定义|线程本地}1，但其声明并非如此"
# 'dynamic memory allocation is not permitted in constant expressions until C++20'
H63A7F05406AD: '在 C++20 之前，常量表达式中不允许进行动态内存分配'
# 'dynamic property cannot have instance variable specification'
HD37DA789564D: '动态属性不能指定实例变量'
# 'dynamic_cast will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0'
HBD4085CEECCB: '由于 %select{-fno-rtti-data|/GR-}0 禁用了 RTTI 数据，dynamic_cast 将无法正常工作'
# 'editor placeholder in source file'
H8455BF28630F: '源文件中的编辑占位符'
# "effects conflict when merging declarations; kept '%0', discarded '%1'"
H73408A047417: '合并声明时效果冲突；保留“%0”，丢弃“%1”'
# 'elaborated enum specifier cannot be declared as a friend'
H7321A1B2921E: '详细枚举说明符不能声明为友元'
# 'element %0 also has value %1'
HFCF33BA58954: '元素 %0 还具有值 %1'
# 'element %0 has been implicitly assigned %1 which another element has been assigned'
H72D209AC7B7A: '元素 %0 被隐式赋值为 %1，而另一个元素已被赋予该值'
# 'ellipsis in pack %select{|init-}0capture must appear %select{after|before}0 the name of the capture'
H6C27D3CFC7C1: '在 pack %select{|init-}0capture 中的省略号必须出现在捕获名称的 %select{后|前}0'
# 'embedded and GOT-based position independence are incompatible'
H471F7EE0F065: '嵌入式和基于 GOT 的位置无关性不兼容'
# 'embedding a #%0 directive within macro arguments is not supported'
HB9B077BA7EC9: '在宏参数中嵌入 #%0 指令不受支持'
# 'embedding a directive within macro arguments has undefined behavior'
HD8530107105F: '在宏参数中嵌入指令具有未定义行为'
# 'empty %0 cannot be composed with named ones'
HE7EB612973FC: '空的 %0 无法与命名项组合'
# 'empty %select{struct|union}0 is a GNU extension'
H758BF913FE7C: '空的 %select{结构|联合}0 是 GNU 扩展'
# 'empty case range specified'
H15C9A1C7CC9D: '指定了空的 case 范围'
# 'empty character constant'
H277FE12896EE: '空的字符常量'
# "empty delimited universal character name; treating as '\\' '%0' '{' '}'"
HF9BFC93E5104: "空的限定通用字符名称；将其视为 '\\' '%0' '{' '}'"
# "empty expression statement has no effect; remove unnecessary ';' to silence this warning"
HE7735A8B2ADE: "空的表达式语句没有效果；删除不必要的 ';' 以消除此警告"
# 'empty filename'
H1CC4DB7178D7: '空的文件名'
# "empty initialization statement of '%select{if|switch|range-based for}0' has no effect"
HCB0D32A02160: "在 '%select{if|switch|范围基于的 for}0' 中的空初始化语句没有效果"
# 'empty macro arguments are a C99 feature'
HD178344D06D5: '空的宏参数是 C99 特性'
# 'empty macro arguments are incompatible with C++98'
HE94FA0985A16: '空的宏参数与 C++98 不兼容'
# 'empty modifier-specification-list is not allowed'
HB0857A4C55BC: '空的 modifier-specification 列表是不允许的'
# "empty paragraph passed to '%select{\\|@}0%1' command"
H38E7CAD895AE: "传递到 '%select{\\|@}0%1' 命令的空段落"
# 'empty parentheses interpreted as a function declaration'
H058E44413EA1: '空的括号被解释为函数声明'
# 'empty symbolic operand name in inline assembly string'
H2DC9E2773A21: '内联汇编字符串中的空符号操作数名称'
# 'enclose %0 in %select{an @available|a __builtin_available}1 check to silence this warning'
HC0011ACD5CEF: '用 %select{@available|__builtin_available}1 检查包裹 %0 以消除此警告'
# 'encoding of %0 type is incomplete because %1 component has unknown encoding'
HE63ED9F43B42: '%0 类型的编码不完整，因为 %1 成分的编码未知'
# "encoding prefix '%0' on an unevaluated string literal has no effect%select{| and is incompatible with c++2c}1"
HFB264777D8F6: "未求值的字符串字面量上的编码前缀 '%0' 没有效果%select{| 且与 c++2c 不兼容}1"
# 'end tag'
HE76165194C35: '结束标签'
# "entering module '%0' due to this pragma"
H00CF7F723C1C: "由于此#pragma指令进入模块'%0'"
# 'enum %0 was explicitly specialized here'
H888313DD02EB: '枚举%0在这里被显式特化'
# 'enumeration %0 is incomplete'
HACD4B99390E7: '枚举类型%0是不完整的'
# 'enumeration cannot be a template'
H0777CF5091AE: '枚举类型不能作为模板'
# 'enumeration previously declared as %select{un|}0scoped'
H979505490BD1: '枚举之前被声明为%select{非|}0作用域'
# 'enumeration previously declared with %select{non|}0fixed underlying type'
H8C078F2C2E0F: '枚举之前被声明为带有%select{非|}0固定底层类型'
# 'enumeration redeclared with different underlying type %0 (was %1)'
H67E555152513: '枚举被重新声明为不同的底层类型%0（原为%1）'
# 'enumeration type %0 is not allowed in a vector conditional'
H71F136014B3C: '枚举类型%0不允许在向量条件中使用'
# 'enumeration type in nested name specifier is incompatible with C++98'
HA088A8B3CD7F: '嵌套名称限定符中的枚举类型与C++98不兼容'
# 'enumeration types with a fixed underlying type are a C++11 extension'
HFFCCC841103E: '带有固定底层类型的枚举类型是C++11的扩展'
# 'enumeration types with a fixed underlying type are a C23 extension'
H463F9486C53D: '带有固定底层类型的枚举类型是C23的扩展'
# 'enumeration types with a fixed underlying type are a Microsoft extension'
H6BC03602C783: '带有固定底层类型的枚举类型是Microsoft扩展'
# 'enumeration types with a fixed underlying type are incompatible with C standards before C23'
H39FE50255F32: '带有固定底层类型的枚举类型与C23之前的C标准不兼容'
# 'enumeration types with a fixed underlying type are incompatible with C++98'
H73924A0CCAED: '带有固定底层类型的枚举类型与C++98不兼容'
# 'enumeration value %0 is out of range of flags in enumeration type %1'
H4F8DF0E727E1: '枚举值%0超出枚举类型%1的标志范围'
# 'enumeration values exceed range of largest integer'
HC084754F6A8B: '枚举值超出最大整数类型的范围'
# 'enumerations cannot be explicitly instantiated'
H997CA3993586: '枚举类型不能显式实例化'
# 'enumerator %0 does not exist in instantiation of %1'
H3D7F75D140F9: '枚举常量%0在实例化%1时不存在'
# 'enumerator %0 with value %1 here'
HD8CCFA398CFA: '此处枚举常量%0的值为%1'
# 'enumerator value %0 is not representable in the underlying type %1'
HAB7EC95F417E: '枚举常量%0的值无法用底层类型%1表示'
# 'enumerator value is not representable in the underlying type %0'
H9CDAE4E68DA9: '枚举值无法用底层类型%0表示'
# 'enums in the Microsoft ABI are signed integers by default; consider giving the enum %0 an unsigned underlying type to make this code portable'
HB2071E0C6A67: 'Microsoft ABI中的枚举默认是带符号整数；请考虑为枚举%0指定无符号底层类型以增强代码的可移植性'
# "environment '%0' is not supported: '%1'"
H88874600742B: "不支持的环境 '%0'：'%1'"
# "environment variable 'SOURCE_DATE_EPOCH' ('%0') must be a non-negative decimal integer <= %1"
H4F81D6E33B46: "环境变量 'SOURCE_DATE_EPOCH' ('%0') 必须是小于等于%1的非负十进制整数"
# 'environment variable CC_PRINT_HEADERS_%select{FORMAT|FILTERING}0 has invalid value %1'
H69C68EA8FAC0: '环境变量 CC_PRINT_HEADERS_%select{FORMAT|FILTERING}0 的值%1无效'
# 'equality comparison between function pointer and void pointer (%0 and %1)'
HD61C2409F0EE: '函数指针与void指针之间的相等性比较（%0 和 %1）'
# 'equality comparison with extraneous parentheses'
H461F5EF9D3AE: '存在多余的括号的相等性比较'
# 'error in backend: %0'
H5E9564F574A6: '后端错误：%0'
# "error in loading module '%0' from prebuilt module path"
H9CB0C604EFA6: "从预构建模块路径加载模块'%0'时出错"
# "error opening '%0': %1"
H14F257DDD829: "打开'%0'时出错：%1"
# "error opening '%0': required by the CrossTU functionality"
HD1F59176156D: "打开'%0'时出错：该文件由跨翻译单元功能所需"
# "error opening file '%0': %1"
H36FA208EA1D0: "打开文件'%0'时出错：%1"
# "error parsing index file: '%0' line: %1 '<USR-Length>:<USR> <File-Path>' format expected"
HDAED7E913418: "索引文件解析错误：'%0' 第%1行应为'<USR-Length>:<USR> <File-Path>'格式"
# "error reading '%0': %1"
HB78815388E3E: "读取'%0'时出错：%1"
# 'error reading stdin: %0'
HFD3376140ADC: '读取标准输入时出错：%0'
# 'escaped newline between */ characters at block comment end'
H16A52D2449DE: '块注释末尾的*/字符之间存在转义换行符'
# "exactly one '%0' directive must appear in the loop body of an enclosing directive"
H3C9E45F0564B: "外围指令的循环体内必须出现恰好一个'%0'指令"
# "exactly one of 'depend', 'destroy', or 'update' clauses is expected"
H41134C7D7A6A: "预期出现'depend'、'destroy'或'update'子句中的恰好一个"
# "exactly one of 'inclusive' or 'exclusive' clauses is expected"
H43DE08BE23B9: "预期出现'inclusive'或'exclusive'子句中的恰好一个"
# 'exception declarator cannot be qualified'
H9E73B1CE7174: '异常声明符不能被限定'
# 'exception object of type %0 has %select{private|protected}1 destructor'
H45EFA39B1650: '类型为%0的异常对象具有%select{私有|受保护}1的析构函数'
# 'exception of type %0 will be caught by earlier handler'
H63736AC525A3: '类型为%0的异常将被更早的处理程序捕获'
# 'exception specification in declaration does not match previous declaration'
H02068091298F: '当前声明的异常规范与之前的声明不匹配'
# 'exception specification in explicit instantiation does not match instantiated one'
HB42947FF7AB7: '显式实例化中的异常规范与实例化后的规范不匹配'
# 'exception specification is not available until end of class definition'
HD568DD20B09E: '异常规范在类定义结束前不可用'
# 'exception specification needed for member of incomplete class %0'
H64C22CA14EC7: '不完整类%0的成员需要异常规范'
# 'exception specification of %0 uses itself'
H8B7B4ED4974B: '%0的异常规范使用自身'
# "exception specification of '...' is a Microsoft extension"
H50C368DB8633: "'...'的异常规范是Microsoft扩展"
# 'exception specification of overriding function is more lax than base version'
HBB63D54D7089: '覆盖函数的异常规范比基类版本更宽松'
# 'exception specifications are not allowed beyond a single level of indirection'
HB84B4B7EA104: '异常规范不允许超过单层间接引用'
# 'exception specifications are not allowed in %select{typedefs|type aliases}0'
HBAC9EC08A3E9: '异常规范不允许在%select{typedefs|类型别名}0中使用'
# 'exception specifications of %select{return|argument}0 types differ'
H04931F9B5864: '%select{返回|参数}0类型的异常规范不同'
# 'excess elements in %select{array|vector|scalar|union|struct}0 initializer'
H6B059251CDF0: '%select{数组|向量|标量|联合|结构体}0初始化器存在多余元素'
# 'excess elements in char array initializer'
H65240A881DB2: '字符数组初始化器存在多余元素'
# 'excess elements in initializer for indivisible sizeless type %0'
HF6B0539A54ED: '不可分割无尺寸类型%0的初始化器存在多余元素'
# 'excess precision is requested but the target does not support excess precision which may result in observable differences in complex division behavior%select{|, additional uses where the requested higher precision cannot be honored were found but not diagnosed}0'
H46192DCC4FC7: '请求额外精度但目标架构不支持额外精度，可能导致复数除法行为差异%select{|, 在其他需要更高精度的位置未诊断出无法满足的情况}0'
# 'execute only is not supported for the %0 sub-architecture'
H355C6C44365F: '%0子架构不支持执行仅模式'
# 'existing instance variable %1 for __weak property %0 must be __weak'
HBE1A4247ED95: '__weak属性%0的现有实例变量%1必须为__weak'
# 'existing instance variable %1 for property %0 with %select{unsafe_unretained|assign}2 attribute must be __unsafe_unretained'
H45768C1508E1: '属性%0的%select{unsafe_unretained|assign}2属性对应的实例变量%1必须为__unsafe_unretained'
# 'existing instance variable %1 for strong property %0 may not be %select{|__unsafe_unretained||__weak}2'
H98A6ABD1A54E: '强属性%0的现有实例变量%1不能为%select{|__unsafe_unretained||__weak}2'
# 'existing instance variable %1 for strong property %0 may not be __weak'
HD554DEC7881B: '强属性 %0 的现有实例变量 %1 可能不能是 __weak'
# 'expanding this definition of %0'
H5BA1B50B21D1: '展开 %0 的这个定义'
# 'expansion of date or time macro is not reproducible'
H816E771096AD: '日期或时间宏的展开结果不可重复'
# 'expansion of macro %0 requested here'
H97F2144252C9: '此处请求展开宏 %0'
# "expansion of predefined identifier '%0' to a string literal is a Microsoft extension"
H89888E84B8EB: "将预定义标识符 '%0' 扩展为字符串字面量是 Microsoft 扩展"
# 'expected "FILENAME" or <FILENAME>'
H6038B7E6D091: '预期 "FILENAME" 或 <FILENAME>'
# "expected #pragma pack parameter to be '1', '2', '4', '8', or '16'"
HA00C06644234: '预期 #pragma pack 参数为 "1"、"2"、"4"、"8" 或 "16"'
# 'expected %0'
H1C2353E37609: '预期 %0'
# 'expected %0 at end of module'
H0F6B0905AE5F: '模块结尾处预期 %0'
# "expected %0 in OpenMP clause '%1'"
HC79E103ACDFE: "在 OpenMP 子句 '%1' 中预期 %0"
# 'expected %0 or %1'
HC08F459555DA: '预期 %0 或 %1'
# 'expected %0; %1 is a keyword in Objective-C++'
H62A445966708: '预期 %0；%1 是 Objective-C++ 的关键字'
# 'expected %1 after %0'
H5879CE8F4818: '在 %0 之后预期 %1'
# "expected %select{'enable', 'disable', 'begin' or 'end'|'disable'}0 - ignoring"
H1B18CF6CA096: "预期 %select{'enable', 'disable', 'begin' 或 'end'|'disable'}0 - 忽略"
# "expected %select{'match'|'match', 'adjust_args', or 'append_args'}0 clause on 'omp declare variant' directive"
HED7B3D66D419: "在 'omp declare variant' 指令上预期 %select{'match'|'match', 'adjust_args' 或 'append_args'}0 子句"
# "expected %select{'val' modifier|one of 'ref', val' or 'uval' modifiers}0"
HCC26F8F297FB: "预期 %select{'val' 修饰符|'ref', val' 或 'uval' 修饰符之一}0"
# 'expected %select{assignment|assignment, compound assignment, increment, or decrement}0 expression'
H2BC7EE32B904: '预期 %select{赋值|赋值、复合赋值、递增或递减}0 表达式'
# "expected %select{identifier after '.' in |}0module name"
HF095089F6D4D: '预期 %select{在 "." 后的标识符 |}0模块名称'
# 'expected %select{identifier|unqualified-id}0'
HC1969BE019B7: '预期 %select{标识符|非限定标识符}0'
# 'expected %select{library|framework}0 name as a string'
H5FD987168935: '预期以字符串形式指定 %select{库|框架}0 名称'
# "expected %select{module exclusion with 'exclude'|'export *'}0"
H4175E9BAE37D: "期望%select{带有'exclude'的模块排除|'export *'}0"
# "expected '#pragma omp end declare %select{target|variant}0'"
H7B3C6216417A: "期望'#pragma omp end declare %select{target|variant}0'"
# "expected '#pragma omp end declare target' at end of file to match '#pragma omp %0'"
H25BEC71CAA92: "期望在文件末尾有'#pragma omp end declare target'来匹配'#pragma omp %0'"
# "expected '#pragma unused' argument to be a variable name"
HE4429A749432: "'#pragma unused'参数应为变量名"
# "expected '%0' after the %1; '%0' assumed"
HB08F71D9B939: "在%1之后期望'%0'；假设了'%0'"
# "expected '%0' clause with an argument on '#pragma omp %1' construct"
HA803E7993B4F: "在'#pragma omp %1'结构中期望带参数的'%0'子句"
# "expected '(' after '%0'"
HA365863454FD: "在'%0'后期望'('"
# "expected '(' for function-style cast or type construction"
H95D0E6661AB2: "期望'('用于函数式类型转换或类型构造"
# "expected ')' after '%0'"
H068274655B04: "在'%0'后期望')'"
# "expected ')' in preprocessor expression"
H9FA29BAED1EF: "预处理表达式中期望')'"
# "expected ')' or ',' after '%0'"
HD115318388CA: "在'%0'后期望')'或','"
# "expected ')' or ',' in '#pragma %0'"
H97FBD869E75F: "在'#pragma %0'中期望')'或','"
# "expected '+' or '-' operation"
H193C159A95C7: "期望'+'或'-'操作"
# "expected ',' after conflicting module name"
H307B5FE6EEA1: "在冲突模块名后期望','"
# "expected ',' after interop modifier"
HBE15766F267C: "在互操作修饰符后期望','"
# "expected ',' in '#pragma %0'"
H80B3D004C35A: "在'#pragma %0'中期望','"
# "expected ',' or ')' after iterator specifier"
H5B885E53A966: "在迭代器说明符后期望','或')'"
# "expected ',' or ')' at end of property accessor list"
H90761748BDB7: "在属性存取器列表末尾期望','或')'"
# "expected ',' or ')' in '%0' %select{clause|directive}1"
H27E43F9D4E4C: "在'%0' %select{子句|指令}1中期望','或')'"
# "expected ',' or '>' in template-parameter-list"
HE6FA48C9A81A: "在模板参数列表中期望','或'>'"
# "expected ',' or ']' in lambda capture list"
H01C14BB9E6E5: "在lambda捕获列表中预期','或']'"
# "expected '->' before expression type requirement"
H25053402E92B: "在表达式类型要求之前预期'->'"
# "expected '.' after pragma attribute namespace %0"
H6D0DBF9112AD: "在pragma属性命名空间%0后预期'.'"
# "expected '::' after '__super'"
HFBD8EE4CC424: "在'__super'后预期'::'"
# "expected ';' after %0 statement"
H26F61B7787AD: "在%0语句后预期';'"
# "expected ';' after '%0'"
HC22BB7A01636: "在'%0'后预期';'"
# "expected ';' after attribute list"
HC367299E9BFD: "在属性列表后预期';'"
# "expected ';' after expression"
H26209FD52998: "在表达式后预期';'"
# "expected ';' after method prototype"
H4DCD5C7E2BCB: "在方法原型后预期';'"
# "expected ';' after module name"
H20B27913626E: "在模块名后预期';'"
# "expected ';' after namespace name"
HAAD5C65924B6: "在命名空间名后预期';'"
# "expected ';' after private module fragment declaration"
H868380AB5A37: "在顶层私有模块片段声明后预期';'"
# "expected ';' after top level declarator"
H3A247DA7CE56: "在顶层声明符后预期';'"
# "expected ';' at end of declaration"
HA8E976B320DC: "在声明结尾处预期';'"
# "expected ';' at end of declaration list"
HA684210D419F: "在声明列表结尾处预期';'"
# "expected ';' at end of requirement"
HDCCCFEC70AB1: "在需求结尾处预期';'"
# "expected ';' in 'for' statement specifier"
H2C47358FD75D: "在'for'语句说明符中预期';'"
# "expected '<' after '%0'"
H1010291C9C7B: "在'%0'后预期'<'"
# "expected '= constant-expression' or end of enumerator definition"
H01AC9A3D13F6: "预期'= constant-expression'或枚举器定义的结尾"
# "expected '=' after '%0'"
H46EA9025A033: "在'%0'后预期'='"
# "expected '=' after diagnostic option"
HEF7733E47109: "在诊断选项后期望 '=' 符号"
# "expected '=' following '#pragma %select{align|options align}0' - ignored"
HCE08A9B54E2F: "在 '#pragma %select{align|options align}0' 后期望 '=' 符号 - 已忽略"
# "expected '=' following '#pragma clang section %select{invalid|bss|data|rodata|text|relro}0'"
H5BC8FFE8057E: "在 '#pragma clang section %select{invalid|bss|data|rodata|text|relro}0' 后期望 '=' 符号"
# "expected '=' for Objective-C getter"
H60371309B60A: "Objective-C getter 需要 '=' 符号"
# "expected '=' for Objective-C setter"
H8ACB8C307A32: "Objective-C setter 需要 '=' 符号"
# "expected '=' in iterator specifier"
H160A5CC58E68: "迭代器说明符中期望 '=' 符号"
# "expected '=' or another designator"
H0EFFC0B249A7: "期望 '=' 或另一个说明符"
# "expected '==' operator for 'weak' clause"
H3CB2580D57FE: "'weak' 子句期望 '==' 操作符"
# "expected 'ON' or 'OFF' or 'DEFAULT' in pragma"
HE0167BADEC73: "在 #pragma 中期望 'ON'、'OFF' 或 'DEFAULT'"
# "expected ']' to close attribute"
H21FBE19AC5CE: "期望 ']' 来关闭属性"
# "expected '__except' or '__finally' block"
HF5A94EBD6434: "期望 '__except' 或 '__finally' 块"
# "expected 'align' following '#pragma options' - ignored"
H851698FD662C: "在 '#pragma options' 后期望 'align' - 已忽略"
# "expected 'auto' or 'decltype(auto)' after concept name"
H0C6E25C16A3C: "在概念名称后期望 'auto' 或 'decltype(auto)'"
# "expected 'begin' or 'end'"
HE7122B95D2E3: "期望 'begin' 或 'end'"
# "expected 'bind' clause for 'loop' construct without an enclosing OpenMP construct"
H5C3B8520C88C: "期望 'bind' 子句用于没有包含 OpenMP 构造的 'loop' 构造"
# "expected 'case' keyword before expression"
H2E3235608C64: "在表达式前期望 'case' 关键字"
# "expected 'compare' clause with the '%0' modifier"
H19AACB74DA99: "期望带有 '%0' 修饰符的 'compare' 子句"
# "expected 'compiler', 'lib', 'user', or a string literal for the section name in '#pragma %0' - ignored"
H516A6D363B4D: "在 '#pragma %0' 的段名称中期望 'compiler'、'lib'、'user' 或字符串字面量 - 已忽略"
# "expected 'get' or 'put' in property declaration"
HB1588A447E94: "在属性声明中期望 'get' 或 'put'"
# "expected 'introduced', 'deprecated', or 'obsoleted'"
HA5AD3805D7B0: "期望 'introduced'、'deprecated' 或 'obsoleted'"
# "expected 'language', 'defined_in', 'generated_declaration', or 'USR'"
HC6089B1E2A7C: "期望 'language'、'defined_in'、'generated_declaration' 或 'USR'"
# "expected 'push', 'pop', or '(' after '#pragma clang attribute'"
H6F226585166A: "在 '#pragma clang attribute' 后期望 'push'、'pop' 或 '('"
# "expected 'reduction' clause with the 'inscan' modifier"
H2220AF809CD1: "带有 'inscan' 修饰符的 'reduction' 子句期望出现"
# "expected 'this' following '*' in lambda capture list"
HAD95524E40D1: "在 lambda 捕获列表中 '*' 后期望 'this'"
# "expected 'this' subscript expression on map clause to be 'this[0]'"
HC4A77B8603BE: "在 map 子句中的 'this' 下标表达式应为 'this[0]'"
# "expected 'volatile', 'inline', 'goto', or '('"
H4AA4A0DEF946: "期望 'volatile'、'inline'、'goto' 或 '('"
# "expected 'while' in do/while loop"
H93A6CFE12887: "在 do/while 循环中期望 'while'"
# "expected '{' after '\\%0' escape sequence"
H8BB332D21D67: "在 '\\%0' 转义序列后期望 '{'"
# "expected '{' after base class list"
HF135F437918B: "在基类列表后期望 '{'"
# "expected '{' in compound literal"
H19B6D0E23043: "复合字面量中期望 '{'"
# "expected '{' to start inferred submodule"
H195C51C6292B: "期望 '{' 开始推导的子模块"
# "expected '{' to start module '%0'"
H68A4A0E12840: "期望 '{' 开始模块 '%0'"
# "expected '}'"
HC6CF963022AD: "期望 '}'"
# 'expected HLSL Semantic identifier'
H26323C15C7D3: '期望 HLSL 语义标识符'
# 'expected OpenACC directive'
HC6E13DDCDF20: '期望 OpenACC 指令'
# "expected a 'float', 'double' or '__float128' for the first argument"
H4A7F993B766C: "第一个参数期望 'float'、'double' 或 '__float128'"
# 'expected a callable expression as %ordinal0 argument to %1, found %2'
H9D110F1CBE18: '期望 %1 的第 %ordinal0 个参数为可调用表达式，但找到 %2'
# 'expected a clang compiler command'
HFF7E5AC24A63: '期望 clang 编译命令'
# "expected a class method selector with single argument, e.g., 'colorWithCGColor:'"
H747F5E4807D4: "期望带有单个参数的类方法选择器，例如 'colorWithCGColor:'"
# "expected a class name after '~' to name a destructor"
H0B5DBF4FC4A5: "在 '~' 后期望类名以命名析构函数"
# 'expected a feature name'
H83F9EEF32768: '需要一个功能名称'
# "expected a field designator, such as '.field = 4'"
HE811DCDC9E5C: "期望一个字段指定符，例如'.field = 4'"
# 'expected a foldable binary operator in fold expression'
H442801240371: '折叠表达式中需要一个可折叠的二元操作符'
# "expected a for, while, or do-while loop to follow '%0'"
H6905E348753C: "在'%0'之后需要跟随一个for、while 或 do-while 循环"
# "expected a header attribute name ('size' or 'mtime')"
H7FCC0389B837: "期望一个头文件属性名称（如'size'或'mtime'）"
# "expected a header name after '%0'"
HC5548A9AEA32: "在'%0'之后需要指定一个头文件名称"
# 'expected a memory order clause'
H8A1509342CF4: '需要一个内存顺序子句'
# "expected a message describing the conflict with '%0'"
H3712B62CAC8D: "需要描述与'%0'冲突的说明信息"
# 'expected a module map file name'
H34A1748EFBBA: '需要一个模块映射文件名称'
# "expected a module name after '%select{module|import}0'"
H60B4E74C4DAA: "在'%select{module|import}0'之后期望一个模块名称"
# "expected a module name in '__building_module' expression"
H3E7D4309A80A: "在'__building_module'表达式中需要一个模块名称"
# "expected a module name or '*'"
HA872E74CF2C8: "需要一个模块名称或'*'"
# 'expected a platform name here'
HB3E385166F04: '此处需要一个平台名称'
# "expected a platform name, e.g., 'macos'"
H451496142CA8: "期望一个平台名称，例如'macos'"
# 'expected a property name in @synthesize'
HFCD01091BCD1: "'@synthesize'中需要指定属性名称"
# "expected a qualified name after 'typename'"
H3D60DB7C4A2E: "在'typename'之后需要一个限定名称"
# "expected a reference to a parameter specified in a 'uniform' clause"
HE4C3AD103D8E: "期望'uniform'子句中指定的参数的引用"
# 'expected a reference to an integer-typed parameter'
HD574D7423FC7: '需要一个指向整型参数的引用'
# "expected a related Objective-C class name, e.g., 'NSColor'"
H1B15D42F8530: "期望一个相关的Objective-C类名，例如'NSColor'"
# "expected a stack label or a string literal for the section name in '#pragma %0' - ignored"
HC98188AB663C: "在'#pragma %0'中期望一个栈标签或字符串字面量作为段名称 - 已忽略"
# "expected a string literal for the section name in '#pragma %0' - ignored"
HE785ABE9BD3E: "在 '#pragma %0' 中期望段名称的字符串字面量 - 已忽略"
# 'expected a type'
HBF18848DB5D9: '期望一个类型'
# "expected a version of the form 'major[.minor[.subminor]]'"
HD227DA64159B: "期望格式为 'major[.minor[.subminor]]' 的版本号"
# 'expected access to data field'
HB984B4DED1F3: '期望访问数据字段'
# "expected action or ')' in '#pragma %0' - ignored"
HA826DA8C7E15: "在 '#pragma %0' 中期望操作或 ')' - 已忽略"
# "expected addressable lvalue expression, array element%select{ or array section|, array section or array shaping expression}0%select{| of non 'omp_depend_t' type}1"
H064E98F2C05F: "期望可寻址的左值表达式%select{ 或数组切片|, 数组切片或数组成形表达式}0%select{|的非 'omp_depend_t' 类型}1"
# "expected addressable lvalue in '%0' clause"
H5CFFB735C83B: "'%0' 子句中需要可寻址的左值表达式"
# 'expected addressable reduction item for the task-based directives'
H317F6E6ED5F4: '任务导向指令需要可寻址的规约项'
# "expected an 'allocator' clause inside of the target region; provide an 'allocator' clause or use 'requires' directive with the 'dynamic_allocators' clause"
H22C155652414: "目标区域内部期望 'allocator' 子句；请提供 'allocator' 子句或在 'requires' 指令中使用 'dynamic_allocators' 子句"
# "expected an Objective-C directive after '@'"
H89CC9A1752F3: "在 '@' 后期望 Objective-C 指令"
# "expected an OpenMP 'directive' or 'sequence' attribute argument"
HB4C47A9C1389: "期望 OpenMP 'directive' 或 'sequence' 属性参数"
# 'expected an OpenMP directive'
H633B99B897DC: '期望 OpenMP 指令'
# "expected an allocator expression inside of the target region; provide an allocator expression or use 'requires' directive with the 'dynamic_allocators' clause"
H3E40EF451DD7: "目标区域内部期望分配器表达式；请提供分配器表达式或在 'requires' 指令中使用 'dynamic_allocators' 子句"
# "expected an attribute after '('"
H1D3F08841FED: "期望 '(' 后面的属性"
# 'expected an attribute name'
HD93294E62460: '期望属性名称'
# "expected an attribute that is specified using the GNU, C++11 or '__declspec' syntax"
H022D0FCF0401: "期望使用 GNU、C++11 或 '__declspec' 语法指定的属性"
# "expected an environment name, e.g., 'compute'"
HFC224EAC2A19: "期望环境名称，例如 'compute'"
# "expected an identifier or template-id after '::'"
H640FB5DADE2C: ':: 后期望标识符或模板标识符'
# "expected an identifier that corresponds to an attribute subject matcher sub-rule; '%0' matcher %select{does not support sub-rules|supports the following sub-rules: %2|}1"
H9C057C572CE2: "期望与属性对象匹配子规则对应的标识符；'%0' 匹配器 %select{不支持子规则|支持以下子规则: %2|}1"
# 'expected an identifier that corresponds to an attribute subject rule'
H294E4D252009: '期望与属性对象规则对应的标识符'
# "expected an integer argument in '#pragma %0'"
H8B88B2FBB6B4: "在'#pragma %0'中期望整数参数"
# "expected an integer or a pointer type of the outer loop counter '%0' for non-rectangular nests"
H7B769AB4785B: "在非矩形嵌套中，外层循环计数器'%0'的类型应为整数或指针类型"
# "expected at least one %0 clause for '#pragma omp %1'"
H7235197EF029: "在'#pragma omp %1'中期望至少一个%0子句"
# "expected at least one %select{'enter' or 'link'|'enter', 'link' or 'indirect'}0 clause"
H068B5F15FD0D: "期望至少一个%select{'enter'或'link'|'enter', 'link'或'indirect'}0子句"
# "expected at least one %select{'to' or 'link'|'to', 'link' or 'indirect'}0 clause"
HCCB831884601: "期望至少一个%select{'to'或'link'|'to', 'link'或'indirect'}0子句"
# "expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'"
HD1F834BB93F7: "在'#pragma omp target update'中需要指定至少一个'to'子句或'from'子句"
# "expected at least one clause on '#pragma omp %0' directive"
HF2F95AA7B57B: "在'#pragma omp %0'指令中需要至少一个子句"
# "expected attribute subject set specifier 'apply_to'"
H235FBF52B9D6: "期望属性对象设置说明符'apply_to'"
# 'expected binary operation on right hand side of assignment operator'
H56333C6C1143: '期望赋值运算符右侧存在二元操作'
# 'expected body of lambda expression'
HD20C4511EEC4: '期望lambda表达式体'
# "expected canonical name for private module '%0'"
H1D8AC0E6D7DF: "期望私有模块'%0'的规范名称"
# 'expected catch'
H0CF63E912EE1: '期望catch'
# 'expected class member or base class name'
H3D5CC6CC3E58: '期望类成员或基类名称'
# 'expected class name'
HE76725D4157E: '期望类名'
# 'expected clause-list or newline in OpenACC directive'
H545847ADF7FD: '期望在OpenACC指令中指定子句列表或换行符'
# 'expected comma in macro parameter list'
HDA341FE611DA: '期望宏参数列表中的逗号'
# 'expected concept name with optional arguments'
H5D07B2CBA3F4: '期望带有可选参数的概念名称'
# "expected configuration macro name after ','"
HAB95DA27DF2F: '期望逗号后的配置宏名称'
# "expected constant sized array of 'omp_alloctrait_t' elements, not %0"
H05FAEDD71E4D: "期望'omp_alloctrait_t'元素的固定大小数组，而非%0"
# "expected declarator on 'omp declare mapper' directive"
HB22F9750894D: "期望'omp declare mapper'指令中的说明符"
# 'expected depobj expression'
HE3D01E0D4DF5: '预期的depobj表达式'
# 'expected end of directive in pragma'
HCC93595992BD: '在#pragma指令中预期指令结束'
# 'expected end of line in preprocessor expression'
HD41DF7404CF0: '在预处理器表达式中预期行尾'
# 'expected excluded module name'
H6CF70735EF8C: '预期排除的模块名称'
# 'expected expression'
HF6BF3F627CA1: '预期表达式'
# 'expected expression containing only member accesses and/or array sections based on named variables'
HB19E72D8D293: '预期仅包含基于命名变量的成员访问和/或数组部分的表达式'
# 'expected expression with a pointer to a complete type as a base of an array shaping operation'
HB89169C408E0: '预期以数组形状操作的基础为完整类型指针的表达式'
# 'expected external declaration'
HC14A3D6A28C9: '预期外部声明'
# 'expected function body after function declarator'
HF961A21CDC61: '函数说明符后预期函数体'
# "expected identifier in '#pragma %0' - ignored"
H05B1FBF9EBC9: "在'#pragma %0'中预期标识符 - 已忽略"
# 'expected identifier in macro parameter list'
H94E463CD5EE5: '在宏参数列表中预期标识符'
# "expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&', or '||'"
H7E170CC2FF20: "预期标识符或以下运算符之一：'+', '-', '*', '&', '|', '^', '&&' 或 '||'"
# 'expected identifier or string literal'
H0AF1E0FEC1A8: '预期标识符或字符串字面量'
# 'expected identifier or string literal describing a context %select{set|selector|property}0; %select{set|selector|property}0 skipped'
HE89AF4D1E70E: '预期描述上下文%select{set|selector|property}0的标识符或字符串字面量；已跳过%select{set|selector|property}0'
# "expected identifier specifying the name of the 'omp critical' directive"
HDAF324FC0746: '预期指定"omp critical"指令名称的标识符'
# 'expected identifier that represents an attribute name'
H4FF5B028471D: '预期表示属性名称的标识符'
# 'expected initializer'
HC06E564F6549: '预期初始化器'
# "expected integer between %0 and %1 inclusive in '#pragma %2' - ignored"
HD3B45551DCCD: "在'#pragma %2'中预期%0到%1之间的整数（含）- 已忽略"
# "expected integer literal as value for header attribute '%0'"
H664A6DF4E15C: "期望头属性'%0'的值为整数字面量"
# "expected integer or identifier in '#pragma pack' - ignored"
H76DF3F452A3B: '在"#pragma pack"中预期整数或标识符 - 已忽略'
# 'expected integral or pointer type as the iterator-type, not %0'
H630D7FF60D9F: '期望迭代器类型为整型或指针类型，而非%0'
# "expected interop type: 'target' and/or 'targetsync'"
H4B471B15641F: "期望互操作类型：'target' 和/或 'targetsync'"
# 'expected iterator specification as depend modifier'
HDCFF4384248D: '期望将迭代器说明用作 depend 修饰符'
# 'expected iterator specification as map modifier'
H1207336B4021: '期望将迭代器说明用作 map 修饰符'
# "expected length on mapping of 'this' array section expression to be '1'"
HAB830A5B0BE8: "期望将 'this' 数组区域表达式的映射长度设置为 '1'"
# "expected list item of scalar type in 'lastprivate' clause with 'conditional' modifier"
HA9ADDE114CE9: "在带有 'conditional' 修饰符的 'lastprivate' 子句中，期望标量类型的列表项"
# 'expected loop invariant expression'
H5CDAE0534BDA: '期望循环不变表达式'
# "expected loop invariant expression or '<invariant1> * %0 + <invariant2>' kind of expression"
HB9C142C1B0A5: '期望循环不变表达式或类似 "<invariant1> * %0 + <invariant2>" 形式的表达式'
# "expected lower bound on mapping of 'this' array section expression to be '0' or not specified"
H191C7ACE16C2: "期望将 'this' 数组区域表达式的映射下界设为 '0' 或未指定"
# "expected lvalue expression%select{ of 'omp_depend_t' type, not %1|}0"
H766F59D547C6: "期望左值表达式%select{ 类型为 'omp_depend_t'，而非 %1|}0"
# "expected member name or ';' after declaration specifiers"
HB82CEE80D58C: "在声明说明符之后期望成员名称或 ';' "
# "expected member name or ';' after declaration specifiers; %0 is a keyword in Objective-C++"
H44CFB0200081: "在声明说明符之后期望成员名称或 ';' ；%0 是 Objective-C++ 中的关键字"
# 'expected method body'
HA77E865AEFEF: '期望方法体'
# 'expected method to %select{read|write}1 %select{dictionary|array}2 element not found on object of type %0'
H7AD9AA6CC51A: '在类型 %0 的对象上未找到用于 %select{读取|写入}1 %select{字典|数组}2 元素的方法'
# "expected modifier in '%0' clause"
HCD7B280DF3B2: "在 '%0' 子句中期望修饰符"
# 'expected module declaration'
H01C99835EAB8: '期望模块声明'
# 'expected module name'
H1C43BA17D195: '期望模块名称'
# 'expected name of accessor method'
HC25216EA2EAE: '期望访问器方法的名称'
# 'expected namespace name'
H4C29A4057DC9: '期望命名空间名称'
# "expected non-wide string literal in '#pragma %0'"
H47A50F5F135C: "在 '#pragma %0' 中期望非宽字符字面量字符串"
# "expected one of [bss|data|rodata|text|relro] section kind in '#pragma %0'"
HD85488A58A29: "在 '#pragma %0' 中期望以下之一的段类型：[bss|data|rodata|text|relro] section kind"
# "expected one of the predefined allocators for the variables with the static storage: 'omp_default_mem_alloc', 'omp_large_cap_mem_alloc', 'omp_const_mem_alloc', 'omp_high_bw_mem_alloc', 'omp_low_lat_mem_alloc', 'omp_cgroup_mem_alloc', 'omp_pteam_mem_alloc' or 'omp_thread_mem_alloc'"
H8611A8451129: "具有静态存储的变量期望预定义的分配器之一：'omp_default_mem_alloc', 'omp_large_cap_mem_alloc', 'omp_const_mem_alloc', 'omp_high_bw_mem_alloc', 'omp_low_lat_mem_alloc', 'omp_cgroup_mem_alloc', 'omp_pteam_mem_alloc' 或 'omp_thread_mem_alloc'"
# 'expected parameter declarator'
HE400FE627646: '期望参数声明符'
# 'expected parentheses around type name in %0 expression'
H29C3C3BEE053: '在%0表达式中期望类型名称周围的括号'
# "expected parenthesized parameter pack name in 'sizeof...' expression"
H872448706A49: "在'sizeof...'表达式中期望括号括起的参数包名称"
# "expected pointer in '%0' clause, type is %1"
HA28C1D2864FB: "在'%0'子句中期望指针，类型为%1"
# "expected pointer or reference to pointer in 'use_device_ptr' clause"
H8CE170DA7DFD: "在'use_device_ptr'子句中期望指针或引用到指针"
# 'expected pointer to struct as %ordinal0 argument to %1, found %2'
H2E1D0CCC5B02: '期望%1的%ordinal0参数是指向结构的指针，但找到的是%2'
# "expected pointer, array, reference to pointer, or reference to array in 'is_device_ptr clause'"
H529E9DB350DF: "在'is_device_ptr子句中期望指针、数组、指向指针的引用或指向数组的引用"
# 'expected property name'
H849B19CD5A49: '期望属性名称'
# "expected push, pop or a string literal for the section name in '#pragma %0' - ignored"
H4F1921BA3641: "在'#pragma %0'中期望push、pop或段名字符串字面量 - 忽略"
# 'expected quoted string after equals sign'
H2D60229D01D0: '在等号后面期望字符串字面量'
# "expected reference to one of the parameters of function %0%select{| or 'this'}1"
HD78611AD5D12: "期望函数%0%select{|或 'this'}1的参数之一的引用"
# 'expected selector for Objective-C %select{setter|getter}0'
HFB2F00048645: 'Objective-C %select{设置器|获取器}0期望选择器'
# 'expected selector for Objective-C method'
HC4CCDD47D676: 'Objective-C方法期望选择器'
# 'expected statement'
HFEEF58AA5565: '期望语句'
# "expected string literal %select{in %1|for diagnostic message in static_assert|for optional message in 'availability' attribute|for %select{language name|source container name|USR}1 in 'external_source_symbol' attribute|as argument of '%1' attribute}0"
HD61709E5D47F: "期望字符串字面量 %select{在%1中|在static_assert的诊断消息中|在'availability'属性的可选消息中|在'external_source_symbol'属性的%select{语言名称|源容器名称|USR}1中|作为'%1'属性的参数}0"
# "expected string literal %select{or parenthesized constant expression |}0in 'asm'"
H87FD9C867F0C: "在'asm'中期望字符串字面量 %select{或括号内的常量表达式 |}0"
# "expected string literal in '#pragma %0' - ignoring"
H0A31A7BE2E40: "在'#pragma %0'中期望字符串字面量 - 忽略"
# "expected string literal in 'clause %0' - ignoring"
H25BCA649E0CB: "在'clause %0'子句中期望字符串字面量 - 忽略"
# 'expected template'
H15B15916EEBA: '预期模板'
# "expected template name after 'template' keyword in nested name specifier"
H49E8E5AAE6BB: "在嵌套名称限定符中的'template'关键字后期望模板名称"
# 'expected template parameter'
H112129FF4EB6: '预期模板参数'
# "expected the class name after '~' to name the enclosing class"
HD0B1F9262E8D: "期望在'~'之后给出封闭类的类名"
# 'expected the name of a parameter pack'
H259207509382: '预期为umbrella、header、子模块或模块导出'
# 'expected type parameter name'
H009E83554F48: '预期模板参数名称'
# 'expected umbrella, header, submodule, or module export'
H13F866613F7D: '表达式中期望值'
# 'expected valid context selector in %0'
HF9402AD88CE1: '在 %0 中预期有效的上下文选择器'
# 'expected value in expression'
HC052EF0BAA44: "期望变量名或'this'在lambda捕获列表中"
# 'expected variable name as a base of the array %select{subscript|section}0'
HBE410C345F41: '期望变量名%select{|或当前类的数据成员}0'
# "expected variable name or 'this' in lambda capture list"
H9A94F049DF94: "预期 lambda 捕获列表中的变量名或 'this'"
# 'expected variable name%select{| or data member of current class}0'
H829F4F463842: '期望变量名%select{|或当前类的数据成员}0'
# 'expected variable name%select{|, data member of current class}0, array element or array section'
HEAE159C816D1: '期望变量名%select{|、当前类的数据成员}0、数组元素或数组切片'
# 'expected variable of pointer type'
H396A94544855: '期望指针类型的变量'
# "expected variable of the '%0' type%select{|, not %2}1"
H3293A68C1535: "期望类型为 '%0' 的变量%select{|，而非 %2}1"
# "expected variable%select{| or static data member|, static data member, or non-static data member of current class}0 of type '%1'"
H54FC8A6038F8: "期望类型为 '%1' 的变量%select{|或静态数据成员|、静态数据成员或当前类的非静态数据成员}0"
# 'expected%select{| %1}0 loop iteration variable'
H9F489F0C181E: '期望%select{| %1}0 循环迭代变量'
# "expected%select{| non-const}0 variable of type 'omp_interop_t'"
H7FA31289BDF2: '期望%select{|非const}0 类型为 omp_interop_t 的变量'
# 'expected%select{| one of}0 %1 directive name modifier%select{|s}0'
HF9EF92E2746A: '预期%select{|一种}0 %1 指令名称修饰符%select{|s}0'
# "expecting %0 '%1' to be held at start of each loop"
HFDC07BD9FDE6: "期望在每个循环的开头保持 %0 '%1'"
# "expecting %0 '%1' to be held at the end of function"
H696ED076811B: "期望在函数结尾保持 %0 '%1'"
# 'explicit %select{constructor|conversion function|deduction guide}0 is not a candidate%select{| (explicit specifier evaluates to true)}1'
H1B61513FD8B6: '显式 %select{构造函数|转换函数|推导指引}0 不是候选%select{|（显式说明符计算为true）}1'
# 'explicit %select{constructor|deduction guide}0 declared here'
H110462FEE829: '显式 %select{构造函数|推导指引}0 在此处声明'
# 'explicit %select{specialization|instantiation}0 of %select{non-|undeclared }3template %1 %2'
H3111D59957AC: '%select{非-|未声明 }3模板 %1 %2 的 %select{显式特化|实例化}0'
# 'explicit call to +initialize results in duplicate call to +initialize'
H39AD5352EF13: '显式调用 +initialize 将导致对 +initialize 的重复调用'
# 'explicit call to [super initialize] should only be in implementation of +initialize'
H9E99F53BFF8C: '显式调用 [super initialize] 应仅在 +initialize 的实现中使用'
# "explicit capture of 'this' with a capture default of '=' is a C++20 extension"
HAF0F203BEF2F: "在捕获默认值为 '=' 时显式捕获 'this' 是 C++20 扩展"
# "explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20"
H671AAB21DB7A: "在捕获默认值为 '=' 时显式捕获 'this' 与 C++20 之前的 C++ 标准不兼容"
# 'explicit constructor calls are a Microsoft extension'
H07E486E825A8: '显式构造函数调用是 Microsoft 扩展'
# 'explicit conversion functions are a C++11 extension'
H6D402C6A81B4: '显式转换函数是 C++11 扩展'
# 'explicit conversion functions are incompatible with C++98'
H325DB8CE82A7: '显式转换函数与 C++98 不兼容'
# 'explicit data sharing attribute requested here'
HC278594BF276: '此处请求显式数据共享属性'
# 'explicit data sharing attribute, data mapping attribute, or is_device_ptr clause requested here'
H5EF926721360: '此处请求显式数据共享属性、数据映射属性或 is_device_ptr 子句'
# 'explicit initialization of field %1 will not be enforced in C++20 and later because %2 has a user-declared constructor, making the type no longer an aggregate'
HF3AC30340626: '在 C++20 及以后版本中，字段 %1 的显式初始化将不再被强制执行，因为 %2 具有用户声明的构造函数，使得该类型不再为聚合类型'
# 'explicit instantiation candidate function %q0 template here %1'
H23B5BDCD19CC: '显式实例化候选函数 %q0 模板定义在此处 %1'
# "explicit instantiation cannot be 'constexpr'"
H9A1E5AE786E4: "显式实例化不能为 'constexpr'"
# "explicit instantiation cannot be 'inline'"
HD5DCEA693BA1: "显式实例化不能为 'inline'"
# 'explicit instantiation cannot have a storage class'
H2C3AA857F69D: '显式实例化不能具有存储类'
# "explicit instantiation declaration (with 'extern') follows explicit instantiation definition (without 'extern')"
HB1AC2FFED2CF: "显式实例化声明（带有'extern'）跟随显式实例化定义（不带'extern'）"
# 'explicit instantiation declaration of %0 with internal linkage'
HF062EFD01A1B: '具有内部链接性的%0的显式实例化声明'
# 'explicit instantiation declaration requires a name'
HB6C2B5BBA7F4: '显式实例化声明需要一个名称'
# "explicit instantiation declaration should not be 'dllexport'"
H2015D0FC9EDD: "显式实例化声明不应是'dllexport'"
# 'explicit instantiation definition is here'
H296BCB0F591A: '显式实例化定义在这里'
# 'explicit instantiation has dependent template arguments'
H0CCD42687978: '显式实例化的模板参数依赖于模板参数'
# 'explicit instantiation of %0 does not refer to a function template, variable template, member function, member class, or static data member'
H33CB49EB02C6: '%0的显式实例化不指向一个函数模板、变量模板、成员函数、成员类或静态数据成员'
# 'explicit instantiation of %0 in class scope'
HC730DBDD7AE4: '%0的显式实例化在类作用域内'
# 'explicit instantiation of %0 must occur at global scope'
H0F240F08C055: '%0的显式实例化必须出现在全局作用域'
# 'explicit instantiation of %0 not in a namespace enclosing %1'
HE49D377AF72F: '%0的显式实例化不在包含%1的命名空间中'
# 'explicit instantiation of %0 that occurs after an explicit specialization has no effect'
HB36244473793: '在显式特化之后出现的%0的显式实例化无效'
# 'explicit instantiation of %q0 must occur in namespace %1'
HB00768729F8E: '%q0的显式实例化必须出现在命名空间%1'
# 'explicit instantiation of %q0 must specify a template argument list'
HE88FD9250BA0: '%q0的显式实例化必须指定模板参数列表'
# 'explicit instantiation of non-templated type %0'
H31C2727CC2AA: '%0的显式实例化是一个非模板类型'
# 'explicit instantiation of typedef %0'
H2C42F0D827C6: '%0类型的显式实例化是一个typedef'
# 'explicit instantiation of undefined %select{member class|member function|static data member}0 %1 of class template %2'
HCF3C5A632D34: '类模板%2中未定义的%select{成员类|成员函数|静态数据成员}0 %1的显式实例化'
# 'explicit instantiation of undefined function template %0'
H5300C0092131: '未定义的函数模板%0的显式实例化'
# 'explicit instantiation of undefined variable template %q0'
H38D285C06249: '未定义的变量模板%q0的显式实例化'
# 'explicit instantiation refers here'
HBCDCC7E0C7EF: '显式实例化指向此处'
# 'explicit instantiation refers to member function %q0 that is not an instantiation'
H500C2DC642A9: '显式实例化指向非实例化的成员函数%q0'
# 'explicit instantiation refers to static data member %q0 that is not an instantiation'
H07ED3DC3915D: '显式实例化引用了非实例化的静态数据成员%q0'
# "explicit object parameter cannot have 'void' type"
H5DECA4F1B2FA: "显式对象参数不能具有'void'类型"
# 'explicit object parameters are incompatible with C++ standards before C++2b'
H32F147DF3434: '显式对象参数与C++2b之前的C++标准不兼容'
# 'explicit ownership qualifier on cast result has no effect'
H3D013C01B086: '显式拥有权限定符对转换结果没有影响'
# 'explicit qualification required to use member %0 from dependent base class'
H469187ADD22A: '使用来自依赖基类的成员%0需要显式限定符'
# 'explicit specialization cannot have a storage class'
HADDD65B5ED76: '显式特例化不能有存储类'
# 'explicit specialization of %0 after instantiation'
HDBBF37665EBE: '在实例化之后对%0的显式特例化'
# 'explicit specialization of %0 in function scope'
H4AB8E368275F: '在函数作用域内对%0的显式特例化'
# "explicit template instantiation cannot have a definition; if this definition is meant to be an explicit specialization, add '<>' after the 'template' keyword"
H88A1F449C08B: "显式模板实例化不能有定义；如果此定义本意是显式特例化，请在'template'关键字后添加'<>'"
# 'explicit template parameter list for lambdas is a C++20 extension'
HF9AE6F1B9252: 'lambda表达式中的显式模板参数列表是C++20扩展'
# 'explicit template parameter list for lambdas is incompatible with C++ standards before C++20'
H57BCAF2B0340: 'lambda表达式中的显式模板参数列表与C++20之前的C++标准不兼容'
# 'explicit(bool) is a C++20 extension'
H07C70F747BCD: 'explicit(bool)是C++20扩展'
# 'explicit(bool) is incompatible with C++ standards before C++20'
H2A0E673F4AE0: 'explicit(bool)与C++20之前的C++标准不兼容'
# 'explicitly assigning value of variable of type %0 to itself%select{|; did you mean to assign to member %2?}1'
HB1C6DD04C662: '显式地将类型%0变量的值赋给自己%select{|; 是否应将成员%2赋值？}1'
# "explicitly capture 'this'"
HCF140BF35536: "显式捕获'this'"
# 'explicitly cast the argument to size_t to silence this warning'
HBB0D273571B1: '将参数显式转换为size_t以消除此警告'
# 'explicitly cast the pointer to silence this warning'
H8E24FB4D1062: '将指针显式转换以消除此警告'
# "explicitly declare getter %objcinstance0 with '%1' to return an 'unowned' object"
H4E2F7B8127D2: "使用'%1'显式声明返回'unowned'对象的getter %objcinstance0"
# 'explicitly defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is implicitly deleted'
H811330B8F313: '显式默认的%select{<ERROR>|相等|三向|相等|关系}0比较运算符被隐式删除'
# 'explicitly defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 is implicitly deleted'
H4A686915F9DC: '显式默认的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0被隐式删除'
# 'explicitly defaulted function was implicitly deleted here'
HF8EF8D3E0A6F: '显式默认的函数在此处被隐式删除'
# 'explicitly defaulting this %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 with a type different from the implicit type is incompatible with C++ standards before C++20'
H5E5EF3FDD4E3: '使用与隐式类型不同的类型显式默认%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0与C++20之前的C++标准不兼容'
# 'explicitly moving variable of type %0 to itself%select{|; did you mean to move to member %2?}1'
H35CC5A2B002D: '显式将类型%0的变量移动到自身%select{|; 是否应移动到成员%2？}1'
# 'explicitly specialized declaration is here'
H0E01C428C014: '显式特化声明在此处'
# 'explicitly-defaulted %select{copy|move}0 assignment operator must return %1'
H36FB5B74F68A: '显式默认的%select{拷贝|移动}0赋值运算符必须返回%1'
# 'exponent has no digits'
H17C521E1F810: '指数没有数字'
# 'export block begins here'
HBA4BC250A89B: '导出块从此处开始'
# 'export declaration appears within anonymous namespace'
H2CCBA9D1C7AA: '导出声明出现在匿名命名空间内'
# 'export declaration appears within another export declaration'
HECEB46AE53AF: '导出声明出现在另一个导出声明内部'
# 'export declaration can only be used on functions'
H2A1BE3778EEF: '导出声明仅可用于函数'
# 'export declaration can only be used within a module purview'
HA59173758635: '导出声明仅可在模块作用域内使用'
# 'export declaration cannot be empty'
H571FAB6A011E: '导出声明不能为空'
# 'export declaration cannot be used in a private module fragment'
H22322B0D3EA4: '导出声明不能用于私有模块片段'
# 'exported templates are unsupported'
H6166D4F14CA1: '导出模板不受支持'
# 'expression cannot be followed by a postfix %0 operator; add parentheses'
HBEECC801546A: '表达式不能后跟后缀%0操作符；请添加括号'
# 'expression does not compute the number of elements in this array; element type is %0, not %1'
H23C233069DBB: '表达式未计算该数组的元素数量；元素类型为%0而非%1'
# "expression evaluates to '%0 %1 %2'"
H64BCD859D7BF: "表达式计算为'%0 %1 %2'"
# 'expression has incomplete class type %0'
H58E1F9927C3B: '表达式具有不完整的类类型%0'
# 'expression is not a string literal'
H3935D8B321FF: '表达式不是字符串字面量'
# 'expression is not an %select{integer|integral}0 constant expression'
H03AFF9CF4CF8: '表达式不是%select{整数|整型}0常量表达式'
# 'expression is not an %select{integer|integral}0 constant expression; folding it to a constant is a GNU extension'
H5CBB867EA1E8: '表达式不是一个%select{integer|integral}0常量表达式；将其折叠为常量是GNU扩展'
# 'expression is not assignable'
H5F8670A31719: '表达式不可赋值'
# 'expression must have integral or unscoped enumeration type, not %0'
H17B3769F086B: '表达式必须具有整型或未命名的枚举类型，而不是%0'
# 'expression not permitted as operand of fold expression'
H291A77DD522F: '不允许在折叠表达式中使用该表达式作为操作数'
# 'expression requires explicit conversion from %0 to %1'
HB376E0297A16: '表达式需要显式地将%0转换为%1'
# 'expression result unused'
HC432FEDE1001: '表达式结果未被使用'
# 'expression result unused; assign into a variable to force a volatile load'
HB7AF8EB968E8: '表达式结果未被使用；将其赋给一个变量以强制加载volatile变量'
# "expression result unused; should this cast be to 'void'?"
HBBF825FCCB8B: "表达式结果未被使用；是否应将此强制转换为'void'类型？"
# 'expression which evaluates to zero treated as a null pointer constant of type %0'
H0240527F1E90: '求值为零的表达式被当作类型%0的空指针常量处理'
# 'expression with side effects has no effect in an unevaluated context'
H186C82044D81: '具有副作用的表达式在未求值的上下文中没有效果'
# "expression with side effects will be evaluated despite being used as an operand to 'typeid'"
H9C60337CD3B8: "用于'typeid'操作数的具有副作用的表达式仍会被求值"
# 'extension used'
HD363255C0A95: '使用了扩展功能'
# 'extern "C" language linkage specification begins here'
H7A156727F19D: 'extern "C"语言链接规范从此处开始'
# 'extern declaration of %0 follows non-extern declaration'
HD31A31C8A91F: '%0的extern声明在非extern声明之后'
# 'extern templates are a C++11 extension'
H1884BE10DDD8: 'extern模板是C++11的扩展'
# 'extern templates are incompatible with C++98'
H1796556A5B60: 'extern模板与C++98不兼容'
# 'external function %0 declared with incompatible types in different translation units (%1 vs. %2)'
HE651F889FA02: '外部函数%0在不同翻译单元中声明的类型不兼容（%1与%2）'
# 'external variable %0 declared with incompatible types in different translation units (%1 vs. %2)'
H15B2E1B8C6FC: '外部变量%0在不同翻译单元中声明的类型不兼容（%1与%2）'
# 'external variable %0 defined in multiple translation units'
H1F8D107DE885: '外部变量%0在多个翻译单元中定义'
# "extra '&' taking address of overloaded function"
H9A83B3B4D92C: "额外的'&'操作符用于取重载函数的地址"
# "extra ';' %select{outside of a function|inside a %1|inside instance variable list|after member function definition}0"
HE280E1BDB8CF: "多余的 ';' %select{函数外|在%1内|在实例变量列表内|成员函数定义后}0"
# "extra ';' after member function definition"
H3CA5397D9B51: "在成员函数定义后多余的 ';'"
# "extra ';' outside of a function is a C++11 extension"
HEE30E6FFD401: "函数外多余的 ';' 是 C++11 扩展"
# "extra ';' outside of a function is incompatible with C++98"
HB50929FF19FE: "函数外多余的 ';' 与 C++98 不兼容"
# 'extra qualification on member %0'
HEB926F36FA1F: '成员 %0 的多余限定符'
# "extra tokens after attribute in a '#pragma clang attribute push'"
H0F837D0B4BE4: "在 '#pragma clang attribute push' 中属性后的多余标记"
# 'extra tokens at end of #%0 directive'
HBFAC5EAA75A7: "指令 '#%0' 结尾处的多余标记"
# "extra tokens at end of '#pragma %0' - ignored"
H2F08FDE9AD4F: "在 '#pragma %0' 结尾处的多余标记将被忽略"
# "extra tokens at the end of '#pragma omp %0' are ignored"
HA0D9244B087C: "在 '#pragma omp %0' 结尾处的多余标记将被忽略"
# "extraneous '%0' before ';'"
H8BD122A76CFA: "';' 前多余的 '%0'"
# "extraneous ')' after condition, expected a statement"
HFFE185AD544D: "条件后的多余的 ')', 期望一个语句"
# "extraneous 'template<>' in declaration of %0 %1"
HE8DEA9984DC2: "在 %0 %1 的声明中多余的 'template<>'"
# "extraneous 'template<>' in declaration of member %0"
H828C24444273: "在成员 %0 的声明中多余的 'template<>'"
# "extraneous 'template<>' in declaration of variable %0"
HFFC1753865A1: "在变量 %0 的声明中多余的 'template<>'"
# "extraneous closing brace ('}')"
H3D189A013717: "多余的闭合大括号 ('}')"
# 'extraneous template parameter list in alias template declaration'
HAA68A1EAD59F: '别名模板声明中的多余模板参数列表'
# 'extraneous template parameter list in concept definition'
HE58F30339D76: '概念定义中的多余模板参数列表'
# 'extraneous template parameter list in template specialization'
H37A5BAADFAAC: '模板特化中的多余模板参数列表'
# 'extraneous template parameter list in template specialization or out-of-line template definition'
HBFB0FFADD00D: '模板特化或模板外联定义中的多余模板参数列表'
# "failed requirement '%0'; 'enable_if' cannot be used to disable this declaration"
H6A26091751B1: "无法满足要求 '%0'; 'enable_if' 不能用于禁用此声明"
# "failed to deduce triple for target architecture '%0'; specify the triple using '-fopenmp-targets' and '-Xopenmp-target' instead"
HAEA08639936D: "无法推断目标架构 '%0' 的目标三元组；请改用 '-fopenmp-targets' 和 '-Xopenmp-target' 指定三元组"
# 'failed to expand response file: %0'
H14746831D212: '无法展开响应文件：%0'
# "failed to find module file for module '%0'"
H265A065BBB4D: "无法找到模块 '%0' 的模块文件"
# "failed to hash content for '%0' because memory buffer cannot be retrieved"
H13A2DD939D67: "无法为 '%0' 哈希内容，因为无法获取内存缓冲区"
# "failed to process suppression mapping file '%0': %1"
H61E7856A5801: "处理抑制映射文件 '%0' 时出错：%1"
# "failing because %select{environment variable 'FORCE_CLANG_DIAGNOSTICS_CRASH' is set|'-gen-reproducer' is used}0"
HE0DD8241D56F: '触发失败，因为 %select{环境变量 "FORCE_CLANG_DIAGNOSTICS_CRASH" 已设置|使用了 "-gen-reproducer" 选项}0'
# 'failure when lexing a character literal'
H36FAC94ACBBF: '解析字符字面量时发生错误'
# 'failure when lexing a numeric literal'
H514A5139F05F: '解析数字字面量时发生错误'
# 'failure when lexing a string literal'
H628F82057288: '解析字符串字面量时发生错误'
# 'fallthrough annotation does not directly precede switch label'
H0941315663A3: 'fallthrough 注解未直接位于 switch 标签之前'
# 'fallthrough annotation in unreachable code'
HF1B980EE596A: '不可达代码中的 fallthrough 注解'
# 'fallthrough annotation is outside switch statement'
H1D7245256264: 'switch 语句外部的 fallthrough 注解'
# 'fast enumeration variables cannot be modified in ARC by default; declare the variable __strong to allow this'
H0BD569725A75: '默认情况下 ARC 不允许修改快速枚举变量；请将变量声明为 __strong 以启用此操作'
# 'feature %0 requires support of %1 feature'
HA4C52697EC12: '特性 %0 需要 %1 特性支持'
# 'feature cannot be %select{introduced|deprecated|obsoleted}0 in %1 version %2 before it was %select{introduced|deprecated|obsoleted}3 in version %4; attribute ignored'
H18649406044A: '特性无法在 %1 版本 %2 中 %select{引入|弃用|淘汰}0，因为它在版本 %4 中 %select{尚未引入|未弃用|未淘汰}3；属性被忽略'
# "feature flag '%0' is ignored since the feature is read only"
H67D49FF0C7F8: "特性标志 '%0' 被忽略，因为该特性是只读的"
# "feature flag '%0' must start with either '+' to enable the feature or '-' to disable it; flag ignored"
HE0833D141647: "特性标志 '%0' 必须以 '+' 启用或 '-' 禁用特征；标志被忽略"
# 'field %0 can overwrite instance variable %1 with variable sized type %2 in superclass %3'
H6914F3D605AE: '字段 %0 可能用超类 %3 中的可变大小类型 %2 覆盖实例变量 %1'
# 'field %0 declared as a function'
HEA705CD2A4BF: '字段 %0 被声明为函数'
# 'field %0 declared here'
HBC2A949CCB44: '字段 %0 在此处声明'
# 'field %0 declared with incompatible types in different translation units (%1 vs. %2)'
H9B5B1B6B054E: '字段 %0 在不同的翻译单元中声明的类型不兼容（%1 与 %2）'
# 'field %0 has type %1 here'
H3B91A03ADD90: '字段 %0 在此处的类型为 %1'
# "field %0 in '%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' not inside structure"
H161B48990AE3: "字段 %0 在 '%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' 中未位于结构体内"
# 'field %0 is uninitialized when used here'
H215FDF8256E9: '字段 %0 在此处使用时未初始化'
# 'field %0 with variable sized type %1 is not at the end of class'
H33E4FFCBD3EE: '具有可变大小类型的字段 %0（%1）未位于类的末尾'
# 'field %0 with variable sized type %1 is not visible to subclasses and can conflict with their instance variables'
HF18E29D99032: '具有可变大小类型的字段 %0（%1）对子类不可见，可能导致与其实例变量冲突'
# 'field %0 with variable sized type %1 not at the end of a struct or class is a GNU extension'
H4A43BA47311C: '结构体或类末尾未放置的具有可变大小类型的字段 %0（%1）是GNU扩展'
# 'field %1 within %0 is less aligned than %2 and is usually due to %0 being packed, which can lead to unaligned accesses'
HA45C4FF93B3E: '%0 中的字段 %1 的对齐方式比 %2 低，这通常是因为 %0 被压缩，可能导致未对齐的访问'
# 'field %select{%1|in %1}0 requires explicit initialization but is not explicitly initialized'
H84C1F3A9AA55: '字段 %select{%1|in %1}0 需要显式初始化但未显式初始化'
# 'field %select{width|precision}0 should have type %1, but argument has type %2'
H8AF459399447: '字段 %select{width|precision}0 的类型应为 %1，但参数类型为 %2'
# 'field designator %0 does not refer to a non-static data member'
HC04EA556E581: '字段指定符 %0 不指向非静态数据成员'
# 'field designator %0 does not refer to any field in type %1'
H2BAA71F8012E: '字段指定符 %0 不指向类型 %1 的任何字段'
# 'field designator %0 does not refer to any field in type %1; did you mean %2?'
HE8FCC93993E6: '字段指定符 %0 不指向类型 %1 的任何字段；您是否指 %2？'
# 'field designator cannot initialize a %select{non-struct, non-union|non-class}0 type %1'
H22AF1F955E3D: '字段指定符不能初始化 %select{non-struct, non-union|non-class}0 类型 %1'
# 'field designator refers here'
H4EC4B8573557: '字段指定符在此处引用'
# 'field has %select{incomplete|sizeless}0 type %1'
HAB06B0829266: '字段具有 %select{incomplete|sizeless}0 类型 %1'
# 'field has name %0 here'
H5D746560C0CD: '字段在此处的名称为 %0'
# 'field has non-trivial ownership qualification'
HC3F83642EF10: '字段具有非平凡的所有权限定符'
# 'field is non-trivial to %select{copy|default-initialize}0'
H1D2827B95FDF: '字段对 %select{copy|default-initialize}0 操作是非平凡的'
# 'field may not be qualified with an address space'
H8FECB3E29FF3: '字段不能用地址空间进行限定'
# 'field of illegal %select{type|pointer type}0 %1 declared here'
H7B96A2670B39: '非法的%select{类型|指针类型}0 %1在此处声明'
# 'field of type %0 has %select{private|protected}2 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}1constructor'
H3E9701CFFDEE: '类型%0的字段具有%select{私有|保护}2 %select{默认|拷贝|移动|*ERROR*|*ERROR*|*ERROR*|}1构造函数'
# 'field of type %1 has %select{private|protected}2 destructor'
H40B677C32C44: '类型%1的字段具有%select{私有|保护}2 析构函数'
# "fields must have a constant size: 'variable length array in structure' extension will never be supported"
H4D0FA4262CAB: '字段必须具有固定大小：结构体中的"可变长度数组"扩展将永远不会被支持'
# "file '%0' could not be located in expected %1"
H3AFCF68EDB4D: '无法在预期的%1中找到文件"%0"'
# "file '%0' from the precompiled header has been overridden"
H0CD8B8C2C117: '来自预编译头的文件"%0"已被覆盖'
# "file '%0' has been modified since the %select{precompiled header|module file|AST file}1 '%2' was built: %select{size|mtime|content}3 changed%select{| (was %5, now %6)}4"
H031EEE30BF07: '自%select{预编译头|模块文件|AST文件}1 "%2"构建以来，文件"%0"已被修改：%select{大小|修改时间|内容}3发生更改%select{|（原为%5，现为%6）}4'
# "file '%0' is not a module file"
H5DD90DFEF976: '文件"%0"不是模块文件'
# "file '%0' is too large for Clang to process"
H9AA7CD92D17E: '文件"%0"过大，Clang无法处理'
# "file '%0' modified since it was first processed"
H1DA05AEA2D52: '文件"%0"自首次处理后已被修改'
# "file '%0' specified by '--extract-api-ignores=' not found"
HC79263152CF4: '通过"--extract-api-ignores="指定的文件"%0"未找到'
# "file '%0' specified by '-fmodules-embed-file=' not found"
HE609B0415A4D: '通过"-fmodules-embed-file="指定的文件"%0"未找到'
# "file '%1' is not a valid precompiled %select{PCH|module|AST}0 file: %2"
H208E3D0A2BB0: '文件"%1"不是有效的预编译%select{PCH|模块|AST}0文件：%2'
# 'file entered %0 time%s0 using %1B (%human1B) of space%plural{0:|: plus %2B (%human2B) for macro expansions}2'
H6D5FEB2AA58C: '文件被输入 %0 time%s0，使用 %1B (%human1B) 的空间%plural{0:|: 加上 %2B (%human2B) 用于宏展开}2'
# 'filter expression has non-integral type %0'
H8F952076C959: '过滤表达式具有非整数类型%0'
# 'final overrider of %q0 in %1'
H0C345A3BEA34: '%1中的%q0最终重写者'
# "finished building module '%0'"
H243A4EC2890E: '已完成模块"%0"的构建'
# 'first argument in call to %0 is a pointer to non-trivially copyable type %1'
HD27C5E590173: '对%0的调用中的第一个参数是指向非平凡可拷贝类型%1的指针'
# 'first argument to %0 must be a pipe type'
H3249D08A7B4F: '对%0的调用中的第一个参数必须是管道类型'
# "first argument to 'swift_async' must be either 'none', 'swift_private', or 'not_swift_private'"
HF444E5B58050: "对'swift_async'的调用中的第一个参数必须是'none'、'swift_private'或'not_swift_private'"
# "first argument to 'va_arg' is of type %0 and not 'va_list'"
H18598D04D35B: "'va_arg' 的第一个参数类型为 %0，而不是 'va_list'"
# 'first argument to __builtin_annotation must be an integer'
H2F65E4EF2060: '__builtin_annotation 的第一个参数必须是整数'
# 'first argument to __builtin_call_with_static_chain must be a non-member call expression'
HF21FFE70E0AD: '__builtin_call_with_static_chain 的第一个参数必须是非成员调用表达式'
# 'first argument to __builtin_call_with_static_chain must not be a block call'
HAAFE474DF4AA: '__builtin_call_with_static_chain 的第一个参数不能是块调用'
# 'first argument to __builtin_call_with_static_chain must not be a builtin call'
HF06ABEE7311C: '__builtin_call_with_static_chain 的第一个参数不能是内置函数调用'
# 'first argument to __builtin_call_with_static_chain must not be a pseudo-destructor call'
HFC90CCCE3212: '__builtin_call_with_static_chain 的第一个参数不能是伪析构函数调用'
# 'first argument to __builtin_convertvector must be a vector'
HF416CD096831: '__builtin_convertvector 的第一个参数必须是一个向量'
# 'first field of a transparent union cannot have %select{floating point|vector}0 type %1; transparent_union attribute ignored'
HCF8EE366AB6A: '透明联合的第一个字段不能具有 %select{浮点|向量}0 类型 %1；transparent_union 属性被忽略'
# 'first non-designated initializer is here'
H3AA2DBB89701: '第一个非指定初始化器在此处'
# 'first parameter of %0 must have type %1'
HE845E4B59857: '%0 的第一个参数必须具有类型 %1'
# 'first two arguments to __builtin_convertvector must have the same number of elements'
HF134017C1A48: '__builtin_convertvector 的前两个参数必须具有相同数量的元素'
# "flag '%0' is ignored when flag '%1' is present"
H83C2C7BB9944: "当标志 '%1' 存在时，标志 '%0' 被忽略"
# "flag '%0' results in undefined behavior with '%1' conversion specifier"
H3E280AED1AE3: "标志 '%0' 与 '%1' 转换说明符会导致未定义行为"
# 'flat namespace libraries are not supported'
H5F018FAC5A55: '扁平命名空间库不受支持'
# 'flexible array initialization is a GNU extension'
H2B7FB7A2090E: '灵活数组初始化是 GNU 扩展'
# 'flexible array initialization is not yet supported'
H4465FD687CED: '灵活数组初始化尚未支持'
# 'flexible array member %0 in a union is a GNU extension'
H87BF69264D2B: '联合中的灵活数组成员 %0 是 GNU 扩展'
# 'flexible array member %0 in a union is a Microsoft extension'
HFF7472E02D1C: '联合中的灵活数组成员 %0 是 Microsoft 扩展'
# 'flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a GNU extension'
HADE10FBB32E9: '空的 %select{结构|接口|联合|类|枚举}1 中的灵活数组成员 %0 是 GNU 扩展'
# 'flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a Microsoft extension'
H9C2765356C50: '空的 %select{结构|接口|联合|类|枚举}1 中的灵活数组成员 %0 是 Microsoft 扩展'
# 'flexible array member %0 not allowed in %select{struct|interface|union|class|enum}1 which has a virtual base class'
HEF0666641494: '柔性数组成员%0不允许在具有虚基类的%select{struct|interface|union|class|enum}1中'
# 'flexible array member %0 of type %1 with non-trivial destruction'
H07E92B7CB701: '类型为%1且具有非平凡析构的柔性数组成员%0'
# 'flexible array member %0 with type %1 is not at the end of %select{struct|interface|union|class|enum}2'
HC60DC08C387B: '类型为%1的柔性数组成员%0不在%select{struct|interface|union|class|enum}2的末尾'
# 'flexible array members are a C99 feature'
H04521DEE401E: '柔性数组成员是C99特性'
# 'flexible array requires brace-enclosed initializer'
H8CC54601E715: '柔性数组需要花括号包围的初始化器'
# "float ABI '%0' is not supported by current library"
H4A77B1741C96: "浮点ABI '%0'不受当前库支持"
# 'floating point arithmetic produces %select{an infinity|a NaN}0'
HE17E4C75C5CF: '浮点运算产生%select{无穷大|NaN}0'
# 'floating point classification requires argument of floating point type (passed in %0)'
HD0C7777CBCB2: '浮点分类需要浮点类型的参数（传递了%0）'
# 'floating point literal in preprocessor expression'
HB66AC9BD4411: '预处理表达式中的浮点字面量'
# 'floating-point comparison is always %select{true|false}0; constant cannot be represented exactly in type %1'
HCE8BE2CDB468: '浮点比较始终为%select{true|false}0；常量无法在类型%1中精确表示'
# 'for loop has empty body'
HE73C4C3A1FCE: 'for循环具有空的循环体'
# 'for range declaration must declare a variable'
HCCF9CE851541: '范围for声明必须声明一个变量'
# 'for type %0'
HE30274CCC76F: '对于类型%0'
# 'force_cuda_host_device end pragma without matching force_cuda_host_device begin'
H8F7AF4F2F3B0: '没有对应的force_cuda_host_device开始指令的force_cuda_host_device结束指令'
# 'format argument is %select{a value|an indirect field width|an indirect precision|an auxiliary value}0, but it should be %select{a value|an indirect field width|an indirect precision|an auxiliary value}1'
H26324CE63C64: '格式参数是%select{一个值|一个间接字段宽度|一个间接精度|一个辅助值}0，但它应该是%select{一个值|一个间接字段宽度|一个间接精度|一个辅助值}1'
# 'format argument modifies specifier at position %0, but it should modify specifier at position %1'
HE2EBF92B2A88: '格式参数修改了位置%0的说明符，但它应该修改位置%1的说明符'
# 'format argument not a string type'
H84E99A867F54: '格式参数不是字符串类型'
# 'format attribute cannot specify the implicit this argument as the format string'
H6DFBB5CF7F53: '格式属性不能将隐式this参数指定为格式字符串'
# "format specifier '%0' is incompatible with '%1'"
H4D29848904BC: "格式说明符'%0'与'%1'不兼容"
# 'format specifies type %0 but the argument has %select{type|underlying type}2 %1'
H2B1918042742: '格式指定类型%0，但参数具有%select{类型|底层类型}2 %1'
# "format string contains '\\0' within the string body"
H262604652293: "格式字符串在字符串正文中包含'\\0'"
# 'format string is defined here'
H2D8041B9330A: '格式字符串在此处定义'
# 'format string is empty'
HCF4821840281: '格式字符串为空'
# 'format string is not a string literal'
HA31C16ADFE78: '格式字符串不是字符串字面量'
# 'format string is not a string literal (potentially insecure)'
HC6BB1E1C18C5: '格式字符串不是字符串字面量（潜在不安全）'
# 'format string is not null-terminated'
H1BFF49AB9B87: '格式字符串未以空字符结尾'
# 'format string missing'
HF57059BFF07F: '缺少格式字符串'
# 'format string should not be a wide string'
H5D46A69914C2: '格式字符串不应是宽字符串'
# 'forward declaration of %0'
H9E3BA9144F24: '%0的前向声明'
# 'forward declaration of %0 cannot have a nested name specifier'
HED9D019594EF: '%0的前向声明不能带有嵌套名称限定符'
# 'forward declaration of class here'
H169D8B5BC4E6: '类的前向声明在此处'
# 'forward declaration of non-parameterized class %0 cannot have type parameters'
H5EA8F1567F5D: '非参数化类%0的前向声明不能带有类型参数'
# 'forward declaration of template entity is here'
H61734FDBAB98: '模板实体的前向声明在此处'
# "forward references to 'enum' types are a Microsoft extension"
H747D15D3C5A0: '枚举类型的前向引用是Microsoft扩展'
# "found '<::' after a %select{template name|addrspace_cast|const_cast|dynamic_cast|reinterpret_cast|static_cast}0 which forms the digraph '<:' (aka '[') and a ':', did you mean '< ::'?"
HFDE68D3C1582: "在%select{模板名称|addrspace_cast|const_cast|dynamic_cast|reinterpret_cast|static_cast}0之后发现了'<::'，这形成了双字符符号'<:'（即'['）和一个':'，是否应为'<::'？"
# "found near match '%0'"
HE96C9DD0F351: "找到近似匹配项'%0'"
# "friend cannot be declared in an explicit instantiation; if this declaration is meant to be a friend declaration, remove the 'template' keyword"
H2CA4FF8AC2DD: "friend声明不能出现在显式实例化中；如果此声明本意是friend声明，请移除'template'关键字"
# 'friend declaration cannot be a concept'
HB24446765643: 'friend声明不能是一个概念'
# 'friend declaration cannot have a pure-specifier'
HC11ADC45D1D2: 'friend声明不能带有纯说明符'
# 'friend declaration expands pack %0 that is declared it its own template parameter list'
H7F18F2309FFC: 'friend声明扩展了其自身模板参数列表中声明的参数包%0'
# 'friend declaration naming a member of the declaring class is incompatible with C++98'
H785F5E24B496: '命名声明类成员的友元声明与C++98不兼容'
# 'friend declaration of %0 does not match any declaration in %1'
H31DFE021DF93: '%0的友元声明与%1中的任何声明不匹配'
# 'friend declaration specifying a default argument must be a definition'
H55D4B490E76D: '指定默认参数的友元声明必须是一个定义'
# 'friend declaration specifying a default argument must be the only declaration'
H21926C78D225: '指定默认参数的友元声明必须是唯一的声明'
# 'friend declaration with a constraint that depends on an enclosing template parameter must be a definition'
HC3DC9462CF4B: '依赖于包含模板参数的约束的友元声明必须是一个定义'
# 'friend declared here'
H4C2593C39E2F: '此处声明的友元'
# 'friend function %0 retaining previous language linkage is an extension'
H45895F884047: '保留先前语言链接的友元函数%0是扩展'
# 'friend function %1 is a %select{private|protected}0 member of %3'
H559C2702128F: '友元函数%1是%3的%select{私有|受保护}0成员'
# 'friend function cannot be defined in a local class'
H01D22F1D90F1: '不能在局部类中定义友元函数'
# 'friend function definition cannot be qualified with %0'
H87D42EF13E75: '友元函数定义不能用%0限定'
# 'friend function specialization cannot be defined'
HE48A55696A0C: '不能定义友元函数特化'
# 'friend type templates must use an elaborated type'
H81BB485691B6: '友元类型模板必须使用扩展类型'
# 'friends can only be classes or functions'
HABE505726BE2: '友元只能是类或函数'
# 'friends cannot be members of the declaring class'
H0C1CF26733ED: '友元不能是声明类的成员'
# "from 'diagnose_if' attribute on %0:"
HB7602983E09F: '来自%0上的"diagnose_if"属性：'
# "function %0 declared 'noreturn' should not return"
H05EC2FA28594: '声明为noreturn的函数%0不应返回'
# 'function %0 is unsafe'
H16AE74CB24AD: '函数%0不安全'
# 'function %0 with deduced return type cannot be used before it is defined'
H55B75567CEBA: '具有推导返回类型的函数%0在定义前不能使用'
# 'function %0 with unknown type must be given a function type'
H5580EE2709E6: '类型未知的函数%0必须指定函数类型'
# 'function by that name is mangled as "%0"'
HD8E36422062F: '该名称的函数被编码为"%0"'
# 'function cannot return %select{array|function}0 type %1'
H00D7FE6EC486: '函数不能返回%select{数组|函数}0类型%1'
# 'function cannot return qualified void type %0'
H6C0F9155F7F7: '函数不能返回修饰的void类型%0'
# 'function declaration cannot become a multiversioned function after first usage'
HC4FCD39E4392: '函数声明在首次使用后不能成为多版本函数'
# 'function declaration cannot have variably modified type'
HC763DB755E39: '函数声明不能具有可变修改后的类型'
# "function declaration is expected after 'declare %select{simd|variant}0' directive"
HCE4F7AEAC2D0: '在声明%select{simd|variant}0指令后应有函数声明'
# "function declaration is missing %select{'target'|'cpu_specific' or 'cpu_dispatch'|'target_version'}0 attribute in a multiversioned function"
H3FE487F1B347: "在多版本函数中，函数声明缺少%select{'target'|'cpu_specific' 或 'cpu_dispatch'|'target_version'}0属性"
# 'function declared %0 was previously declared %1, which has different SME function attributes'
HF900531E932D: '函数声明%0之前被声明为%1，其具有不同的SME函数属性'
# "function declared '%0' here was previously declared %select{'%2'|without calling convention}1"
H2073EFB350A2: "在此处声明的函数'%0'之前被声明为%select{'%2'|无调用约定}1"
# "function declared in block scope cannot have 'static' storage class"
H60B5EC75E0B8: "块作用域内的函数声明不能具有'static'存储类"
# 'function declared non-throwing here'
H03F3D9700027: '函数在此处声明为不抛出异常'
# 'function declared with %0 attribute was previously declared without the %0 attribute'
H5B84619C2423: '带有%0属性的函数声明之前被声明为没有该%0属性'
# 'function declared with regparm(%0) attribute was previously declared %plural{0:without the regparm|:with the regparm(%1)}1 attribute'
HF6A7160FBDE6: '声明带有regparm(%0)属性的函数之前被声明为%plural{0:无regparm|:带有regparm(%1)}1属性'
# "function definition declared 'typedef'"
H4E2B82F177E3: "此处的函数定义声明了'typedef'"
# 'function definition does not declare parameters'
HD54A2FF99A28: '函数定义未声明参数'
# 'function definition inside an Objective-C container is deprecated'
HE7254FE08BD0: '在Objective-C容器内的函数定义已弃用'
# 'function definition is not allowed here'
HE3336279F815: '此处不允许函数定义'
# 'function definition with pure-specifier is a Microsoft extension'
HDD1E7812B50D: '带有pure-specifier的函数定义是Microsoft扩展'
# 'function does not return %0'
H7977746969A8: '函数未返回%0'
# "function executed in streaming-SVE mode requires 'sme'"
H6F533435BD63: "在流式SVE模式下执行的函数需要'sme'"
# "function is a coroutine due to use of '%0' here"
H3E5959ADA928: '由于此处使用‘%0’，该函数是一个协程'
# 'function is implicitly deleted because its declared type does not match the type of an implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0'
H2629CD02AC41: '函数因声明类型与隐含的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0类型不匹配而被隐式删除'
# 'function multiversioning caused by this declaration'
HF2D62F7767DB: '由该声明引发的函数多版本化'
# "function multiversioning doesn't support %select{feature|architecture}0 '%1'"
H9210168C8D12: '函数多版本化不支持%select{特性|架构}0 "%1"'
# 'function multiversioning is currently only supported on Linux'
H16DA1069458D: '函数多版本化目前仅在Linux系统上支持'
# 'function multiversioning is not supported on the current target'
H7E39D7302E01: '当前目标平台不支持函数多版本化'
# "function name is not allowed in 'link' clause"
H0E47E3134914: '函数名不允许出现在"link"子句中'
# 'function parameter %0 with unknown value cannot be used in a constant expression'
H01EB1CAEE1FB: '具有未知值的函数参数%0不能用于常量表达式'
# 'function previously declared with an %select{explicit|implicit}0 exception specification redeclared with an %select{implicit|explicit}0 exception specification'
H74E61DFB1137: '函数先前使用%select{显式|隐式}0异常规范声明，但现使用%select{隐式|显式}0异常规范重新声明'
# 'function returns a type %0 marked with [[clang::coro_return_type]] but is neither a coroutine nor a coroutine wrapper; non-coroutines should be marked with [[clang::coro_wrapper]] to allow returning coroutine return type'
H6390B743719E: '函数返回带有[[clang::coro_return_type]]标记的类型%0，但它既不是协程也不是协程包装器；非协程应使用[[clang::coro_wrapper]]标记以允许返回协程返回类型'
# 'function scope depth exceeded maximum of %0'
H7DB5DD972DEA: '函数作用域深度超过最大值%0'
# "function static variables are not permitted in functions to which an OpenACC 'routine' directive applies"
HE3AED765A103: '应用OpenACC "routine"指令的函数中不允许使用静态变量'
# 'function template %q0 matches specialization %1'
HA3A32C570475: '函数模板%q0与特化模板%1匹配'
# 'function template partial specialization is not allowed'
HA3F0ADD5EDBB: '不允许函数模板的部分特化'
# 'function template specialization %0 ambiguously refers to more than one function template; explicitly specify%select{| additional}1 template arguments to identify a particular function template'
H64BC13156614: '函数模板特化%0模棱两可地指向多个函数模板；请显式指定%select{|附加}1模板参数以指定特定的函数模板'
# "function template with 'sycl_kernel' attribute must have a 'void' return type"
HE8E9EA85C4E9: '带有"sycl_kernel"属性的函数模板必须具有"void"返回类型'
# "function template with 'sycl_kernel' attribute must have a single parameter"
H852CD6495192: '带有"sycl_kernel"属性的函数模板必须具有单一参数'
# 'function try block in constexpr %select{function|constructor}0 is a C++20 extension'
H5EFE05C3D7E9: '函数constexpr %select{函数|构造函数}0中的try块是C++20扩展'
# 'function try block in constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
HACF74D9C1B64: '函数constexpr %select{函数|构造函数}0中的try块与C++20之前的语言标准不兼容'
# 'function type may not be qualified with an address space'
H193B814022E3: '函数类型不能用地址空间进行限定'
# 'function type with %0 attribute must have C linkage'
H39A9B5046A90: '带有%0属性的函数类型必须具有C语言链接性'
# "function using ZA state requires 'sme'"
H355762BCE254: "使用 ZA 状态的函数需要 'sme'"
# "function using ZT0 state requires 'sme2'"
H00330EB861A8: "使用 ZT0 状态的函数需要 'sme2'"
# "function with '#pragma omp declare variant' has a different %select{calling convention|return type|constexpr specification|inline specification|storage class|linkage}0"
H77243261DC29: "带有 '#pragma omp declare variant' 指令的函数具有不同的 %select{调用约定|返回类型|constexpr 说明|内联说明|存储类别|链接性}0"
# "function with '#pragma omp declare variant' must have a prototype when 'append_args' is used"
H6A83415B36DA: "当使用 'append_args' 时，带有 '#pragma omp declare variant' 的函数必须有原型"
# "function with 'device_type(%0)' is not available on %select{device|host}1"
HB35512790F72: '设备类型（%0）的函数在 %select{设备|主机}1 上不可用'
# 'function with deduced return type cannot be virtual'
H4BED7E854F85: '具有推导返回类型的函数不能是 virtual'
# 'function with no prototype cannot use the %0 calling convention'
H83A590AC3D6C: '没有原型的函数不能使用 %0 调用约定'
# "function with trailing return type must specify return type 'auto', not %0"
HBA312AD67336: '具有尾随返回类型的函数必须指定返回类型为 auto，而不是 %0'
# 'function-like macro %0 is not defined'
H7F9F07CB89B9: '函数式宏 %0 未定义'
# 'function-style cast to a builtin type can only take one argument'
H5995CF0D518F: '向内置类型使用函数式转换只能接受一个参数'
# 'functional-style cast to %0 has incompatible initializer of type %1'
H0F52DA9B703F: '将 %0 的函数式转换具有不兼容的类型 %1 的初始化器'
# 'functions cannot be declared in an anonymous %select{struct|union}0'
H50EACF1C1B1C: '不能在匿名 %select{struct|union}0 中声明函数'
# "functions may not be declared with 'cmse_nonsecure_call' attribute"
H21052FB1BA63: '带有 cmse_nonsecure_call 属性的函数不能被声明'
# 'functions that differ only in their return type cannot be overloaded'
H24E04D8DAB80: '仅返回类型不同的函数不能被重载'
# 'generalized initializer lists are a C++11 extension'
HA239925474B5: '通用初始化列表是 C++11 扩展'
# 'generalized initializer lists are incompatible with C++98'
HCEA06465013C: '通用初始化列表与 C++98 不兼容'
# 'generated arguments #%0 in round-trip: %1'
H9232807EF50E: '往返中的生成参数 #%0：%1'
# 'generated arguments do not match in round-trip'
HDDB24B24E48C: '往返中的生成参数不匹配'
# 'generated arguments parse failed in round-trip'
HA646C4AED02A: '往返中的生成参数解析失败'
# 'generic lambdas are incompatible with C++11'
H0E2372801126: '通用 lambdas 与 C++11 不兼容'
# 'getter name mismatch between property redeclaration (%1) and its original declaration (%0)'
HCB66D133764C: '属性重声明（%1）和其原始声明（%0）的getter名称不匹配'
# "glob '%0' did not match any header file"
H7F85F549D444: "glob '%0' 未匹配到任何头文件"
# 'global sampler requires a const or constant address space qualifier'
H418F4CC80105: '全局采样器需要const或constant地址空间限定符'
# 'guarded_by declared here'
H0D3E968182E3: 'guarded_by 声明于此处'
# 'half precision constant requires cl_khr_fp16'
H4CC0B372F96B: '半精度常量需要cl_khr_fp16'
# 'hardware TLS register is not supported for the %0 sub-architecture'
HDE3B68F7C8A6: '%0 子架构不支持硬件TLS寄存器'
# "header attribute '%0' specified multiple times"
H7E7CB9EE75BF: "头文件属性 '%0' 被多次指定"
# "header file %0 (aka '%1') cannot be imported because it is not known to be a header unit"
H0A389CC3DB5F: "头文件 %0（别名 '%1'）无法导入，因为它未被识别为头单元"
# "header file '%0' input '%1' does not match the type of prior input in api extraction; use '-x %2' to override"
HCC1F871B655D: "头文件 '%0' 的输入 '%1' 与API提取中的先前输入类型不匹配；使用 '-x %2' 覆盖"
# "header file '%0' input type '%1' does not match type of prior input in module compilation; use '-x %2' to override"
H089F6388D5E8: "头文件 '%0' 的输入类型 '%1' 与模块编译中的先前输入类型不匹配；使用 '-x %2' 覆盖"
# 'heap allocation performed here'
H3CBBD5C4CC88: '此处执行堆分配'
# 'hexadecimal floating %select{constant|literal}0 requires %select{an exponent|a significand}1'
HEA69D9247DD1: '十六进制浮点%select{常量|字面量}0 需要%select{指数|有效数字}1'
# 'hexadecimal floating constants are a C99 feature'
H42D5F9E3F4DF: '十六进制浮点常量是C99特性'
# 'hexadecimal floating literals are a C++17 feature'
H37A919BEDE1E: '十六进制浮点字面量是C++17特性'
# 'hexadecimal floating literals are incompatible with C++ standards before C++17'
HDD6000DF6583: '十六进制浮点字面量与C++17之前的C++标准不兼容'
# 'hidden overloaded virtual function %q0 declared here%select{|: different classes%diff{ ($ vs $)|}2,3|: different number of parameters (%2 vs %3)|: type mismatch at %ordinal2 parameter%diff{ ($ vs $)|}3,4|: different return type%diff{ ($ vs $)|}2,3|: different qualifiers (%2 vs %3)|: different exception specifications}1'
HAF71C2F007E8: '被隐藏的重载虚函数 %q0 声明于此处%select{|: 不同的类%diff{ ($ vs $)|}2,3|: 参数数量不同（%2 vs %3）|: 第%ordinal2参数类型不匹配%diff{ ($ vs $)|}3,4|: 返回类型不同%diff{ ($ vs $)|}2,3|: 限定符不同（%2 vs %3）|: 异常规格不同}1'
# "hidden visibility cannot be applied to 'dllexport' declaration"
HF663B246106D: "隐藏可见性不能应用于'dllexport'声明"
# 'higher order bits are zeroes after implicit conversion'
H69351DA797D5: '隐式转换后高位为零'
# 'host variable declared here'
H46B0F8E7BD93: '主机变量声明于此处'
# "identifier %0 after '~' in destructor name does not name a type"
H83FECEE0EB8D: "析构函数名称中'~'后的标识符 %0 不是一个类型"
# 'identifier %0 in object destruction expression does not name a type'
H9BF7AFAC2ABF: '对象销毁表达式中的标识符 %0 未命名一个类型'
# 'identifier %0 in object destruction expression does not name the type %1 of the object being destroyed'
H3AA5F97C4B64: '对象销毁表达式中的标识符 %0 不是正在销毁的对象类型 %1'
# "identifier %0 is reserved because %select{<ERROR>|it starts with '_' at global scope|it starts with '_' and has C language linkage|it starts with '__'|it starts with '_' followed by a capital letter|it contains '__'}1"
HB25A0B12A970: "标识符 %0 被保留，因为 %select{<ERROR>|它在全局作用域以 '_' 开头|它以 '_' 开头且具有C语言链接性|它以 '__' 开头|它以 '_' 后跟大写字母开头|它包含 '__'}1"
# 'identifier %0 preceded by whitespace in a literal operator declaration is deprecated'
H0DD590ABAF7E: '字面量运算符声明中标识符 %0 前有空格已被弃用'
# 'identifier after literal will be treated as a reserved user-defined literal suffix in C++11'
HC12CCB91962D: '字面量后的标识符在C++11中将被视为保留的用户定义字面量后缀'
# 'identifier after literal will be treated as a user-defined literal suffix in C++11'
HBE6CD4B6A8AE: '字面量后的标识符在C++11中将被视为用户定义字面量后缀'
# 'identifier contains Unicode character <U+%0> that is invisible in some environments'
H5D7B884070AB: '标识符包含在某些环境中不可见的Unicode字符 <U+%0>'
# "identifier followed by '<' indicates a class template specialization but %0 %select{does not refer to a template|refers to a function template|<unused>|refers to a variable template|<unused>|<unused>|refers to a concept}1"
HAF5607DFBCE7: "由 '<' 后缀标识的类模板特化但 %0 %select{不引用模板|引用函数模板|<未使用>|引用变量模板|<未使用>|<未使用>|引用概念}1"
# 'if statement has empty body'
H1093D3B0523A: 'if语句有空的主体'
# 'if you supply your own aligned allocation functions, use -faligned-allocation to silence this diagnostic'
H71B886D5B0E4: '如果您提供了自己的对齐分配函数，请使用 -faligned-allocation 选项来抑制此诊断信息'
# 'ifunc resolver function must return a pointer'
H3E2AB07FAA23: 'ifunc解析函数必须返回一个指针'
# "ignored 'inline' attribute on kernel function %0"
HD7F59CCBC545: "内核函数 %0 上的 'inline' 属性被忽略"
# "ignored asm label '%0' on automatic variable"
H457253219067: "自动变量上的 asm 标签 '%0' 被忽略"
# 'ignored trigraph would end block comment'
HC0EDD32FEF14: '被忽略的三元组会导致块注释结束'
# 'ignoring %0 attribute because its argument is invalid'
H5CBA55A0FD5C: '忽略 %0 属性，因为其参数无效'
# 'ignoring %select{return value|temporary}0 of type %2 declared with %1 attribute%select{|: %4}3'
H18EB408CFE62: '忽略使用 %1 属性声明的类型 %2 的 %select{返回值|临时对象}0%select{|: %4}3'
# "ignoring '%0' as it conflicts with that implied by '%1' (%2)"
HB9837B039EA4: "忽略 '%0'，因为它与 '%1' 隐含的选项 (%2) 冲突"
# "ignoring '%0' option as it cannot be used with %select{implicit usage of|}1 -mabicalls and the N64 ABI"
H17CC723C2497: "忽略 '%0' 选项，因为它不能与 %select{隐式使用|}1 -mabicalls 和 N64 ABI 一起使用"
# "ignoring '%0' option as it is not currently supported for processor '%1'"
H14E6B917A2E6: "忽略 '%0' 选项，因为它当前不支持处理器 '%1'"
# "ignoring '%0' option as it is not currently supported for target '%1'"
H4AA39F54EF26: "忽略 '%0' 选项，因为它当前不支持目标 '%1'"
# "ignoring '%0' option for offload arch '%1' as it is not currently supported there. Use it with an offload arch containing '%2' instead"
H788152E08844: "忽略为offload架构'%1'指定的'%0'选项，因为当前不支持该选项。请改用包含'%2'的offload架构"
# "ignoring '%select{static|inline}0' keyword on explicit template instantiation"
H8A80FA7727CA: "忽略显式模板实例化中的'%select{static|inline}0'关键字"
# "ignoring '-f%select{no-|}0raw-string-literals', which is only valid for C and C++ standards before C++11"
H135D75731B01: "忽略'-f%select{no-|}0raw-string-literals'选项，该选项仅适用于C和C++11之前的版本"
# "ignoring '-mabs=2008' option because the '%0' architecture does not support it"
H5F88EE5F0A3D: "忽略'-mabs=2008'选项，因为'%0'架构不支持该选项"
# "ignoring '-mabs=legacy' option because the '%0' architecture does not support it"
HE0FE9F3B46CA: "忽略'-mabs=legacy'选项，因为'%0'架构不支持该选项"
# "ignoring '-mcompact-branches=' option because the '%0' architecture does not support it"
H60C9F0D89DB6: "忽略'-mcompact-branches='选项，因为'%0'架构不支持该选项"
# "ignoring '-mgpopt' option as it cannot be used with %select{|the implicit usage of }0-mabicalls"
H2A6F793FDFBC: "忽略'-mgpopt'选项，因为其不能与%select{|the implicit usage of }0-mabicalls同时使用"
# "ignoring '-mlong-calls' option as it is not currently supported with %select{|the implicit usage of }0-mabicalls"
HD076A9DC69A3: "忽略'-mlong-calls'选项，因为当前不支持与%select{|the implicit usage of }0-mabicalls同时使用"
# "ignoring '-mnan=2008' option because the '%0' architecture does not support it"
H29C27F0049E3: "忽略'-mnan=2008'选项，因为'%0'架构不支持该选项"
# "ignoring '-mnan=legacy' option because the '%0' architecture does not support it"
HADAF322768AC: "忽略'-mnan=legacy'选项，因为'%0'架构不支持该选项"
# 'ignoring -fapple-kext which is valid for C++ and Objective-C++ only'
H88A745D4B73F: '忽略仅适用于C++和Objective-C++的-fapple-kext选项'
# 'ignoring -fdiscard-value-names for LLVM Bitcode'
HC86237F887FA: '忽略LLVM位码中的-fdiscard-value-names选项'
# "ignoring -fverify-debuginfo-preserve-export=%0 because -fverify-debuginfo-preserve wasn't enabled"
H36FCA7FF86DB: '忽略-fverify-debuginfo-preserve-export=%0选项，因为未启用-fverify-debuginfo-preserve'
# 'ignoring __declspec(allocator) because the function return type %0 is not a pointer or reference type'
H6AAEF2701683: '忽略__declspec(allocator)，因为函数返回类型%0不是指针或引用类型'
# "ignoring availability attribute %select{on '+load' method|with constructor attribute|with destructor attribute}0"
H24871179ED63: "忽略%select{在'+load'方法上的|带有构造函数属性的|带有析构函数属性的}0可用性属性"
# "ignoring extension '%0' because the '%1' architecture does not support it"
HD131D7C5772F: "忽略扩展'%0'，因为'%1'架构不支持该扩展"
# "ignoring invalid -ftabstop value '%0', using default value %1"
H55F6E19B595A: "忽略无效的-ftabstop值'%0'，使用默认值%1"
# "ignoring invalid /arch: argument '%0'; for %select{64|32}1-bit expected one of %2"
HF5AE60D7E4BF: "忽略无效的/arch:参数'%0'；在%select{64|32}1位模式下应指定%2中的一个"
# 'ignoring redefinition of Objective-C qualifier macro'
HE01ADCD1C19E: '忽略Objective-C限定符宏的重复定义'
# 'ignoring return value of function declared with %0 attribute'
H0B36C4D66510: '忽略使用%0属性声明的函数的返回值'
# 'ignoring return value of function declared with %0 attribute%select{|: %2}1'
H9DECD2C6A7A4: '忽略声明带有%0属性的函数的返回值%select{|: %2}1'
# 'ignoring temporary created by a constructor declared with %0 attribute%select{|: %2}1'
H0FFFAF84F31C: '忽略由声明带有%0属性的构造函数创建的临时对象%select{|: %2}1'
# "ignoring the 'branch-protection' attribute because the '%0' architecture does not support it"
HF5FC687425B2: "由于'%0'架构不支持该属性，忽略'branch-protection'属性"
# 'illegal OpenMP user-defined mapper identifier'
H4FE25A4B348F: '非法的OpenMP用户定义映射器标识符'
# 'illegal call to %0, expected %1 argument type'
H4DEE4185FC7F: '对%0的非法调用，期望%1参数类型'
# 'illegal call to enqueue_kernel, incorrect argument types'
H96AA6DCB3DCC: '对enqueue_kernel的非法调用，参数类型不正确'
# 'illegal call to enqueue_kernel, parameter needs to be specified as integer type'
H8F7144077DA2: '对enqueue_kernel的非法调用，参数需要指定为整数类型'
# 'illegal character encoding in character literal'
H44B6CA76305B: '字符字面量中的非法字符编码'
# 'illegal character encoding in string literal'
H2EE26865FBAD: '字符串字面量中的非法字符编码'
# 'illegal device builtin %select{surface|texture}0 reference class template %1 declared here'
H7BB2FD0ACCED: '非法的设备内置%select{surface|texture}0引用类模板%1在此处声明'
# 'illegal device builtin %select{surface|texture}0 reference type %1 declared here'
H1DEC140E0334: '非法的设备内置%select{surface|texture}0引用类型%1在此处声明'
# 'illegal initializer (only variables can be initialized)'
H371A1BFF13F4: '非法的初始化器（仅变量可以被初始化）'
# 'illegal initializer type %0'
H000E8C02D9A4: '非法的初始化器类型%0'
# 'illegal interface qualifier'
H247C18DEFCA4: '非法的接口限定符'
# 'illegal operation on Objective-C container subscripting'
H1CDC7C944B48: 'Objective-C容器下标操作的非法操作'
# 'illegal qualifiers on @catch parameter'
H2C6EDFE337AA: '@catch参数上的非法限定符'
# "illegal redeclaration of 'readwrite' property in class extension %0 (perhaps you intended this to be a 'readwrite' redeclaration of a 'readonly' public property?)"
H77F956612F13: "在类扩展%0中非法重新声明'readwrite'属性（也许您本意是重新声明一个公开的'readonly'属性为'readwrite'？）"
# "illegal redeclaration of property in class extension %0 (attribute must be 'readwrite', while its primary must be 'readonly')"
HA09E774D29B3: "在类扩展%0中非法重新声明属性（属性必须为'readwrite'，而其主属性必须为'readonly'）"
# 'illegal scalar extension cast on argument %0 to %select{|in}1out paramemter'
HF91E5CAEA96B: '参数%0到%select{|in}1out参数的非法标量扩展转换'
# 'illegal storage class on file-scoped variable'
H601564466459: '文件作用域变量上的非法存储类'
# 'illegal storage class on function'
H930E494BEBBE: '函数上使用了非法的存储类'
# 'illegal type %0 used in a boxed expression'
H5782BEFABE5B: '在打包表达式中使用了非法类型%0'
# 'illegal vector component name %0'
H6F3BE393AEDE: '非法的向量组件名称%0'
# 'illegal visibility specification'
H39F781806C46: '非法的可见性说明'
# 'imaginary constants are a C2y extension'
HAF201E910158: '虚数常量是C2y扩展'
# 'imaginary constants are a GNU extension'
H539EC610843E: '虚数常量是GNU扩展'
# 'imaginary constants are incompatible with C standards before C2y'
H8F7EDEA31FE9: '虚数常量与C2y之前的C标准不兼容'
# 'imaginary types are not supported'
H8AEF701858F7: '不支持虚数类型'
# 'immediate function %0 used before it is defined'
H1A240E8F6E49: '立即函数%0在其定义之前被使用'
# 'implementing deprecated %select{method|class|category}0'
H9AA979884A67: '实现已弃用的%select{方法|类|分类}0'
# 'implementing unavailable method'
H0D7D4644123A: '实现不可用的方法'
# 'implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 inferred target collision: call to both %select{__device__|__global__|__host__|__host__ __device__}1 and %select{__device__|__global__|__host__|__host__ __device__}2 members'
HDD95624FC57A: '隐式%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0推断的目标冲突：同时调用了%select{__device__|__global__|__host__|__host__ __device__}1和%select{__device__|__global__|__host__|__host__ __device__}2成员'
# 'implicit boolean conversion of Objective-C object literal always evaluates to true'
HFAC6148E9355: 'Objective-C对象字面量的隐式布尔转换始终计算为true'
# "implicit capture of 'this' with a capture default of '=' is deprecated"
H7D01BFC1D4A1: '使用默认捕获方式"="隐式捕获"this"已弃用'
# 'implicit capture of lambda object due to conversion to block pointer here'
H9CBFA98934C5: '由于此处转换为块指针，隐式捕获了lambda对象'
# 'implicit cast from type %0 to type %1 drops __unaligned qualifier'
HBCE299280FC0: '从类型%0到类型%1的隐式转换会丢失__unaligned限定符'
# 'implicit conversion between pointer-to-function and pointer-to-object is a Microsoft extension'
HE1B9297E3DCF: '函数指针与对象指针之间的隐式转换是Microsoft扩展'
# "implicit conversion between vector types ('%0' and '%1') is deprecated; in the future, the behavior implied by '-fno-lax-vector-conversions' will be the default"
HD9008DAA3AF0: '向量类型（"%0"和"%1"）之间的隐式转换已弃用；未来，"-fno-lax-vector-conversions"选项指定的行为将成为默认'
# 'implicit conversion changes signedness: %0 to %1'
H2AEC008E19C8: '隐式转换改变了符号性：%0到%1'
# 'implicit conversion discards imaginary component: %0 to %1'
H5E6175D2FC4A: '隐式转换丢弃了虚数部分：%0到%1'
# 'implicit conversion from %0 cannot fit within the range of values for %1'
HC3B95ADC5255: '来自 %0 的隐式转换无法适应 %1 的取值范围'
# 'implicit conversion from %0 to %1 changes non-zero value from %2 to %3'
H5699AB9A4A11: '来自 %0 到 %1 的隐式转换将非零值从 %2 改变为 %3'
# 'implicit conversion from %0 to %1 changes value from %2 to %3'
H3C62B43256C2: '来自 %0 到 %1 的隐式转换将值从 %2 改变为 %3'
# 'implicit conversion from %0 to %1 is not permitted in C++'
HD43915D50111: '在 C++ 中不允许来自 %0 到 %1 的隐式转换'
# 'implicit conversion from %0 to %1 may lose precision'
H1D559B11094C: '来自 %0 到 %1 的隐式转换可能导致精度丢失'
# 'implicit conversion from %2 to %3 changes value from %0 to %1'
H9616CD29DFC9: '来自 %2 到 %3 的隐式转换将值从 %0 改变为 %1'
# 'implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is a C++11 extension'
H1C73815D89AE: '来自类型为 %0 的数组大小表达式的隐式转换到 %select{integral|enumeration}1 类型 %2 是 C++11 的扩展'
# 'implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is incompatible with C++98'
HBA0FE5371598: '来自类型为 %0 的数组大小表达式的隐式转换到 %select{integral|enumeration}1 类型 %2 与 C++98 不兼容'
# "implicit conversion from constant value %0 to 'BOOL'; the only well defined values for 'BOOL' are YES and NO"
H9F3E57EE843E: "来自常量值 %0 到 'BOOL' 的隐式转换；'BOOL' 的唯一定义值是 YES 和 NO"
# 'implicit conversion from enumeration type %0 to different enumeration type %1'
HEE824DA3A047: '来自枚举类型 %0 到不同枚举类型 %1 的隐式转换'
# "implicit conversion from floating-point type %0 to 'BOOL'"
H4747E2EB6787: "来自浮点类型 %0 到 'BOOL' 的隐式转换"
# "implicit conversion from integral type %0 to 'BOOL'"
H2BF4B2ABD201: "来自整数类型 %0 到 'BOOL' 的隐式转换"
# 'implicit conversion from nullable pointer %0 to non-nullable pointer type %1'
H2C9C47D2B30E: '来自可为空指针 %0 到不可为空指针类型 %1 的隐式转换'
# 'implicit conversion increases floating-point precision: %0 to %1'
HA48CBAE7D71E: '隐式转换提升浮点精度：%0 到 %1'
# 'implicit conversion loses floating-point precision: %0 to %1'
H8151E8B82266: '隐式转换丢失浮点精度：%0 到 %1'
# 'implicit conversion loses integer precision: %0 to %1'
H7E75B58A91F6: '隐式转换丢失整数精度：%0 到 %1'
# 'implicit conversion of %select{NULL|nullptr}0 constant to %1'
H81DB38ED2223: '%select{NULL|nullptr}0 常量到 %1 的隐式转换'
# 'implicit conversion of out of range value from %0 to %1 is undefined'
H60829B0B819C: '来自 %0 到 %1 的隐式转换超出范围的值是未定义的'
# 'implicit conversion truncates vector: %0 to %1'
H678147335701: '隐式转换截断向量：%0 到 %1'
# 'implicit conversion turns floating-point number into bool: %0 to %1'
HBD45EEBA1C30: '隐式转换将浮点数转为 bool：%0 到 %1'
# 'implicit conversion turns floating-point number into integer: %0 to %1'
H1859EAB52A1F: '隐式转换将浮点数转换为整数：%0 到 %1'
# 'implicit conversion turns string literal into bool: %0 to %1'
H0BABC92466FD: '隐式转换将字符串字面量转换为布尔值：%0 到 %1'
# 'implicit conversion turns vector to scalar: %0 to %1'
HB2E373F67C4B: '隐式转换将向量转换为标量：%0 到 %1'
# 'implicit conversion when assigning computation result loses floating-point precision: %0 to %1'
H063DB898AD67: '赋值时的隐式转换导致浮点精度丢失：%0 到 %1'
# 'implicit conversions between vector types (%0 and %1) are not permitted'
HDD25DAA03F93: '向量类型之间的隐式转换（%0 和 %1）不允许'
# 'implicit declaration introduced by elaborated type conflicts with a %select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|type alias template|template template argument}0 of the same name'
H0AA0DBCCB1F5: '通过显式类型引入的隐式声明与同名的%select{非结构体类型|非类类型|非联合类型|非枚举类型|typedef|类型别名|模板|类型别名模板|模板模板参数}0冲突'
# 'implicit declaration of function %0'
H1E9139CA3E1D: '函数 %0 的隐式声明'
# "implicit deduction guide declared as '%0'"
H2EE915923496: "隐式推导指引声明为 '%0'"
# 'implicit default constructor suppressed by user-declared constructor'
H2B519469152F: '用户声明的构造函数抑制了隐式默认构造函数'
# 'implicit instantiation of undefined member %0'
H2427990A2EAB: '未定义成员 %0 的隐式实例化'
# 'implicit truncation from %2 to a one-bit wide bit-field changes value from %0 to %1'
H46C1BDEE4300: '从 %2 截断到 1 位宽的位域时，值从 %0 变为 %1'
# 'implicit truncation from %2 to bit-field changes value from %0 to %1'
HB32D8742297B: '从 %2 截断到位域时，值从 %0 变为 %1'
# 'implicit use of sequentially-consistent atomic may incur stronger memory barriers than necessary'
H162AB39C9F24: '隐式使用顺序一致的原子操作可能导致不必要的更强内存屏障'
# "implicitly declaring library function '%0' with type %1"
H452F7C0F821A: "隐式声明库函数 '%0' 的类型为 %1"
# 'implicitly determined as %0'
HD0131FA6D64A: '隐式确定为 %0'
# "implicitly disabling vptr sanitizer because rtti wasn't enabled"
HABA9C105D8F8: '隐式禁用 vptr sanitizer 因为未启用 rtti'
# 'import %select{module|name}0 (%1) does not match the import %select{module|name}0 (%2) of the previous declaration'
HE913E2E83F88: '导入的%select{模块|名称}0（%1）与先前声明的%select{模块|名称}0（%2）不匹配'
# 'import %select{module|name}0 cannot be applied to a function with a definition'
HB24CB23A8286: '无法将具有定义的函数应用%select{模块|名称}0导入'
# 'import of C++ module \'%0\' appears within extern "C" language linkage specification'
HDAEE51A4DB06: 'C++ 模块导入 \'%0\' 出现在 extern "C" 语言链接规范内'
# "import of module '%0' appears within %1"
H08448256C67A: "模块 '%0' 的导入出现在 %1 内"
# "import of module '%0' appears within its own %select{interface|implementation}1"
HBF7F549ECBD5: "模块 '%0' 的导入出现在其自身的 %select{接口|实现}1 中"
# "import of module '%0' appears within same top-level module '%1'"
H25D86D4DF122: "模块 '%0' 的导入出现在同一顶层模块 '%1' 内"
# "import of module '%0' imported non C++20 importable modules"
H861EDFB67C5B: "导入了被遮蔽的模块 '%0'"
# "import of shadowed module '%0'"
HECE190C4501D: "导入被遮蔽的模块 '%0'"
# "imported AST from '%0' had been generated for a different target, current: %1, imported: %2"
H30A99270FD50: "从 '%0' 导入的 AST 是为不同目标生成的，当前目标: %1，导入目标: %2"
# "imported by %select{|module '%2' in }1'%0'"
HBA6CF98B38A4: "通过%select{ |模块'%2'在}1'%0'导入"
# 'importing an implementation partition unit in a module interface is not recommended. Names from %0 may not be reachable'
H4BCD18B5E018: '在模块接口中导入实现分区单元不被推荐。%0中的名称可能无法访问'
# "importing module '%0'%select{| into '%3'}2 from '%1'"
HD074A7D9BA2D: "从'%1'%select{ |到'%3'}2导入模块'%0'"
# 'imports must immediately follow the module declaration'
H25C0CF982742: '导入必须紧跟模块声明之后'
# 'impossible constraint in asm: cannot store value into a register'
HEC9C616BA3F9: 'asm中不可能的约束：无法将值存储到寄存器'
# 'in %select{implicit|defaulted}0 %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 for %2 first required here'
H7F88B1ED021A: '在%select{隐式|默认}0 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}1为%2首次需要此处'
# "in call to '%0'"
H5F44B6591F5A: "在转储结构体时，调用带有参数 '(%0)' 的打印函数"
# "in call to printing function with arguments '(%0)' while dumping struct"
H5B10BE57CF69: "在转储结构时调用参数为'(%0)'的打印函数"
# 'in defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator for %1 first required here'
H41C2C013E2E2: '在%1的默认%select{<ERROR>|相等|三向|相等|关系}0比较运算符中首次需要此处'
# 'in evaluating default argument here'
HA6EC671D8C49: '在此处评估默认参数'
# 'in evaluation of exception specification for %q0 needed here'
H94CE96486393: '在评估%q0所需的异常规范时'
# 'in first definition, possible difference is here'
HAF3474709EF4: '在首次定义中，可能的差异在此处'
# "in implicit call to 'operator%select{!=|*|++}0' for iterator of type %1"
HA1274A4A4765: "在类型 %1 的迭代器隐式调用 'operator%select{!=|*|++}0' 运算符时"
# 'in implicit initialization for inherited constructor of %0'
HE4CCA87F39AA: '在继承构造函数%0的隐式初始化中'
# 'in implicit initialization of %select{array element %1 with omitted initializer|field %1 with omitted initializer|trailing array elements in runtime-sized array new}0'
HD4BCA75D333B: '在隐式初始化%select{省略初始值的数组元素%1|省略初始值的域%1|运行时尺寸数组new的末尾数组元素}0时'
# 'in implicit initialization of binding declaration %0'
H6B3B1A4A0790: '在初始化此处需要的绑定声明%0时'
# 'in initialization of temporary of type %0 created to list-initialize this reference'
H5C5815C0F326: '在初始化为此引用进行列表初始化(type %0类型)创建的临时对象时'
# "in instantiation of default argument for '%0' required here"
H920C89F748D0: '在实例化%0的默认参数时需要此处'
# "in instantiation of default function argument expression for '%0' required here"
H05CBF7F0C1EE: '在实例化%0的默认函数参数表达式时需要此处'
# 'in instantiation of default member initializer %q0 requested here'
HD2F44CDF38B1: '在实例化此处请求的默认成员初始化器%q0时'
# 'in instantiation of enumeration %q0 requested here'
H6EB646EE227A: '在实例化此处请求的枚举%q0时'
# 'in instantiation of exception specification for %0 requested here'
H3C01A542E6EB: '在实例化此处请求的%0异常说明时'
# 'in instantiation of function template specialization %q0 requested here'
HAEB9C4D2EE7B: '在实例化此处请求的函数模板特化%q0时'
# 'in instantiation of member class %q0 requested here'
H5CE23327E7F1: '在实例化此处请求的成员类%q0时'
# 'in instantiation of member function %q0 requested here'
H748A89FD0314: '在实例化此处请求的成员函数%q0时'
# 'in instantiation of requirement here'
HE12670012001: '在实例化此处的约束条件时'
# 'in instantiation of requirement parameters here'
HCD143B7FE64F: '在实例化此处的约束参数时'
# 'in instantiation of static data member %q0 requested here'
H0491530140D7: '在实例化此处请求的静态数据成员%q0时'
# 'in instantiation of template class %q0 requested here'
H65B85839EF55: '在实例化此处请求的模板类%q0时'
# 'in instantiation of template type alias %0 requested here'
HAECA7764FC0E: '在实例化此处请求的模板类型别名%0时'
# 'in instantiation of variable template specialization %q0 requested here'
H0FA1B781E861: '在实例化此处请求的变量模板特化%q0时'
# "in pattern '%1': %0"
H2F43FF1537BC: "在模式'%1'中：%0"
# 'in second definition, possible difference is here'
HEC9D50C16660: '在第二个定义中，可能的差异在此处'
# 'in template expansion here'
H1E2D3625EAB4: '在模板展开时此处'
# 'in the default initializer of %0'
H6D9691DC0D28: '在%0的默认初始化器中'
# 'in value-initialization of type %0 here'
H74E349C94BB1: '在此处%0类型的值初始化中'
# 'in%select{| implicit}0 constructor here'
H24F20A5C047E: '在%select{| 隐式}0构造函数中'
# 'in-class initializer for static data member is not a constant expression'
H9B69A27F211E: '类内静态数据成员的初始值设定项不是常量表达式'
# 'in-class initializer for static data member is not a constant expression; folding it to a constant is a GNU extension'
HA2848C2F37A8: '类内静态数据成员的初始值设定项不是常量表达式；将其折叠为常量是GNU扩展'
# 'in-class initializer for static data member of type %0 is a GNU extension'
H46A5C414A183: '类型%0的类内静态数据成员初始值设定项是GNU扩展'
# "in-class initializer for static data member of type %0 requires 'constexpr' specifier"
H7E9F22B76B86: '类型%0的类内静态数据成员需要添加constexpr限定符'
# 'in_reduction variable must have the same reduction operation as in a task_reduction clause'
H7647CFB2C410: '规约变量必须与任务规约条款中的规约操作一致'
# "include location '%0' is unsafe for cross-compilation"
H62F3D6400A8A: '交叉编译时，包含位置%0存在安全风险'
# "include of non-modular header inside framework module '%0': '%1'"
H82B29FF5B7DD: '在框架模块%0内包含非模块化头文件：%1'
# "include of non-modular header inside module '%0': '%1'"
H747C5EDF3216: '在模块%0内包含非模块化头文件：%1'
# "include path for libstdc++ headers not found; pass '-stdlib=libc++' on the command line to use the libc++ standard library instead"
H45B1E0C04AB4: '未找到libstdc++头文件的包含路径；请通过命令行传递-stdlib=libc++以改用libc++标准库'
# "include the header <%0> or explicitly provide a declaration for '%1'"
HBFC18315E2CB: '包含头文件<%0>或显式为%1提供声明'
# 'incompatible block pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
HA4D550DCCECE: '不兼容的块指针类型 %select{%diff{将$赋值给$|将不同类型赋值}0,1|%diff{将$传给类型$的参数|传给不同类型参数}0,1|%diff{从结果类型$的函数返回$|从函数返回不同类型}0,1|%diff{将$转换为类型$|转换类型}0,1|%diff{用类型$的表达式初始化$|用不同类型的表达式初始化}0,1|%diff{将$发送给类型$的参数|发送给不同类型参数}0,1|%diff{将$转换为类型$|转换类型}0,1}2'
# 'incompatible constant for this __builtin_neon function'
H338324E39A33: '该__builtin_neon函数的常量参数类型不兼容'
# 'incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
H803DA0209C00: '不兼容的函数指针类型 %select{%diff{将$赋值给$|将不同类型赋值}0,1|%diff{将$传给类型$的参数|传给不同类型参数}0,1|%diff{从结果类型$的函数返回$|从函数返回不同类型}0,1|%diff{将$转换为类型$|转换类型}0,1|%diff{用类型$的表达式初始化$|用不同类型的表达式初始化}0,1|%diff{将$发送给类型$的参数|发送给不同类型参数}0,1|%diff{将$转换为类型$|转换类型}0,1}2%select{|; 使用*解引用|; 使用&取地址|; 移除*|; 移除&}3'
# 'incompatible integer to pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
H48B50F4A5A68: '不兼容的整数到指针转换 %select{%diff{将$赋值给$|将不同类型赋值}0,1|%diff{将$传给类型$的参数|传给不同类型参数}0,1|%diff{从结果类型$的函数返回$|从函数返回不同类型}0,1|%diff{将$转换为类型$|转换类型}0,1|%diff{用类型$的表达式初始化$|用不同类型的表达式初始化}0,1|%diff{将$发送给类型$的参数|发送给不同类型参数}0,1|%diff{将$转换为类型$|转换类型}0,1}2%select{|; 使用*解引用|; 使用&取地址|; 移除*|; 移除&}3'
# 'incompatible operand types (%0 and %1)'
HCEE400E94353: '不兼容的操作数类型（%0和%1）'
# 'incompatible operand types%diff{ ($ and $)|}0,1'
H1FD3FD989888: '不兼容的操作数类型%diff{ ($和$)|}0,1'
# 'incompatible pointer to integer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
HFD878F5F2922: '不兼容的指针到整数转换 %select{%diff{将$赋值给$|将不同类型赋值}0,1|%diff{将$传给类型$的参数|传给不同类型参数}0,1|%diff{从结果类型$的函数返回$|从函数返回不同类型}0,1|%diff{将$转换为类型$|转换类型}0,1|%diff{用类型$的表达式初始化$|用不同类型的表达式初始化}0,1|%diff{将$发送给类型$的参数|发送给不同类型参数}0,1|%diff{将$转换为类型$|转换类型}0,1}2%select{|; 使用*解引用|; 使用&取地址|; 移除*|; 移除&}3'
# 'incompatible pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
HBA7B4F7FCD76: '指针类型不兼容 %select{%diff{将$赋给$|将不同类型赋值}0,1|%diff{将$传给类型为$的参数|传给不同类型的参数}0,1|%diff{从结果类型为$的函数返回$|函数返回类型不匹配}0,1|%diff{将$转换为类型$|类型间转换}0,1|%diff{用类型$的表达式初始化$|用不同类型的表达式初始化}0,1|%diff{将$传给类型为$的参数|传给不同类型的参数}0,1|%diff{将$转换为类型$|类型间转换}0,1}2%select{|; 使用*解引用|; 取地址使用&|; 移除*|; 移除&}3'
# 'incompatible pointer types passing retainable parameter of type %0to a CF function expecting %1 type'
H85C3F4475A3D: '将类型%0的可保留参数传给期望类型%1的CF函数时指针类型不兼容'
# 'incompatible redeclaration of library function %0'
H4DCB8A7133E4: '库函数%0的不兼容重声明'
# 'incompatible types casting %0 to %1 with a %select{__bridge|__bridge_transfer|__bridge_retained}2 cast'
HA70D951974C7: '使用%select{__bridge|__bridge_transfer|__bridge_retained}2类型转换将%0转为%1时类型不兼容'
# 'incompatible vector types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
H349444057F6C: '向量类型不兼容 %select{%diff{将$赋给$|将不同类型赋值}0,1|%diff{将$传给类型为$的参数|传给不同类型的参数}0,1|%diff{从结果类型为$的函数返回$|函数返回类型不匹配}0,1|%diff{将$转换为类型$|类型间转换}0,1|%diff{用类型$的表达式初始化$|用不同类型的表达式初始化}0,1|%diff{将$传给类型为$的参数|传给不同类型的参数}0,1|%diff{将$转换为类型$|类型间转换}0,1}2'
# 'incomplete definition of type %0'
H74F733EC60E9: '类型%0的定义不完整'
# "incomplete delimited universal character name; treating as '\\' '%0' '{' identifier"
H45A3D640545C: "不完整的限定通用名称; 将视为 '\\' '%0' '{' 标识符"
# 'incomplete format specifier'
HC2682570C017: '格式说明符不完整'
# 'incomplete receiver type %0'
H6C117CF6E37A: '接收者类型%0不完整'
# 'incomplete result type %0 in function definition'
HA8E1F3068B20: '函数定义中结果类型%0不完整'
# 'incomplete result type %0 in lambda expression'
H69E2641DED85: 'lambda表达式中结果类型%0不完整'
# "incomplete type %0 in a '_Generic' association is a C2y extension"
H7D3852AE4A16: "'_Generic' 关联中的不完整类型%0是C2y扩展"
# 'incomplete type %0 is not a literal type'
H8AFDEC1F2348: '不完整类型%0不是字面类型'
# 'incomplete type %0 is not assignable'
HF862B3215822: '不完整类型%0不可赋值'
# 'incomplete type %0 named in nested name specifier'
HCA7665DF5910: '嵌套命名限定符中指定的不完整类型%0'
# 'incomplete type %0 used in a boxed expression'
HF426C73BD83F: '在包装表达式中使用不完整类型%0'
# 'incomplete type %0 used in type trait expression'
H4539C0CCBFB9: '在类型特征表达式中使用不完整类型%0'
# 'incomplete type %0 where a complete type is required'
H95C11FF1D056: '在需要完整类型的位置使用不完整类型%0'
# 'incomplete type in call to object of type %0'
HB57B0356D109: '调用类型%0的对象时使用了不完整类型'
# 'incomplete universal character name'
H0184822E59BB: '通用名称不完整'
# "incomplete universal character name; treating as '\\' followed by identifier"
H5B8C01DBAD90: "不完整的通用字符名；视为'\\'后跟标识符"
# 'inconsistent number of instance variables specified'
H7EB07F9DCA1E: '指定的实例变量数量不一致'
# "incorrect adjust_args type, expected 'need_device_ptr' or 'nothing'"
H34BB37A9E639: "adjust_args类型不正确，预期为'need_device_ptr'或'nothing'"
# 'incorrect format for -preamble-bytes=N,END'
HD764A19076F3: '-preamble-bytes=N,END 的格式不正确'
# "incorrect map type modifier, expected one of: 'always', 'close', 'mapper'%select{|, 'present'|, 'present', 'iterator'}0%select{|, 'ompx_hold'}1%select{|, 'self'}2"
H6BCE6C4F91C6: "不正确的映射类型修饰符，预期为以下之一：'always', 'close', 'mapper'%select{|, 'present'|, 'present', 'iterator'}0%select{|, 'ompx_hold'}1%select{|, 'self'}2"
# "incorrect map type, expected one of 'to', 'from', 'tofrom', 'alloc', 'release', or 'delete'"
HFC0556B7E292: "不正确的映射类型，预期为'to', 'from', 'tofrom', 'alloc', 'release'或'delete'"
# 'incorrect number of bits in integer (expected %0 bits, have %1)'
H39F86512F6F1: '整数中的位数不正确（预期%0位，当前有%1位）'
# 'incorrect number of bits in vector operand (expected %select{|a multiple of}0 %1 bits, have %2)'
HDF4134C84931: '向量操作数位数不正确（期望%select{ |的倍数}0%1位，实际%2位）'
# "incorrect reduction identifier, expected one of '+', '*', '&', '|', '^', '&&', '||', 'min' or 'max' or declare reduction for type %0"
HD90D2B65D413: "不正确的归约标识符，预期为'+', '*', '&', '|', '^', '&&', '||', 'min'或'max'，或为类型%0声明归约"
# "incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max' or declare reduction for type %0"
HC80B58A26C84: "不正确的归约标识符，预期为'+', '-', '*', '&', '|', '^', '&&', '||', 'min'或'max'，或为类型%0声明归约"
# 'incorrect use of #pragma clang force_cuda_host_device begin|end'
HB4E983FB1A7D: '错误使用 #pragma clang force_cuda_host_device begin|end'
# "incorrect use of '#pragma fenv_access (on|off)' - ignored"
HB0DD6B333D8B: '#pragma fenv_access (on|off) 的使用不正确 - 已忽略'
# "incorrect use of '#pragma ms_struct on|off' - ignored"
HB1C2DABF7753: '#pragma ms_struct on|off 的使用不正确 - 已忽略'
# 'increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable %0'
H1F62FE8343E9: 'OpenMP for循环的增量子句必须对循环变量%0执行简单的加法或减法'
# 'increment expression must cause %0 to %select{decrease|increase}1 on each iteration of OpenMP for loop'
H6AE9805023F0: '增量表达式必须在每次OpenMP for循环迭代中使%0 %select{减少|增加}1'
# 'incremented enumerator value %0 is not representable in the largest integer type'
H33F55260A9EF: '递增的枚举值%0无法用最大的整数类型表示'
# 'incrementing expression of type bool is deprecated and incompatible with C++17'
HB438D9D07956: 'bool类型的递增表达式已弃用，并与C++17不兼容'
# "indeterminate value can only initialize an object of type 'unsigned char'%select{, 'char',|}1 or 'std::byte'; %0 is invalid"
H26C79B7B3090: "不确定的值只能初始化类型为'unsigned char'%select{, 'char',|}1或'std::byte'的对象；%0无效"
# 'index %0 must appear exactly once in the permutation clause'
H907BCB3D7A64: '索引%0必须在排列子句中恰好出现一次'
# 'index for __builtin_shufflevector must be a constant integer'
H2AA72873C8D9: '__builtin_shufflevector的索引必须是常量整数'
# 'index for __builtin_shufflevector must be less than the total number of vector elements'
HDC5D16284BAC: '__builtin_shufflevector 的索引必须小于向量元素的总数'
# 'index for __builtin_shufflevector not within the bounds of the input vectors; index of -1 found at position %0 is not permitted in a constexpr context'
H0F3D61BA78F9: '__builtin_shufflevector 的索引超出输入向量的边界；在位置 %0 发现的 -1 索引在 constexpr 上下文中不允许'
# 'indexing expression is invalid because subscript type %0 has multiple type conversion functions'
H28D375C7CDB6: '下标表达式无效，因为下标类型 %0 具有多个类型转换函数'
# 'indexing expression is invalid because subscript type %0 is not an Objective-C pointer'
H76E63693A71C: '下标表达式无效，因为下标类型 %0 不是 Objective-C 指针'
# 'indexing expression is invalid because subscript type %0 is not an integral or Objective-C pointer type'
H5DB003FBDC67: '下标表达式无效，因为下标类型 %0 不是整型或 Objective-C 指针类型'
# 'indexing of array without known bound is not allowed in a constant expression'
HE2B8FD1CE633: '在常量表达式中不允许对未知边界的数组进行下标访问'
# 'indirect goto in function with no address-of-label expressions'
H145FEAAFA432: '在没有标签地址表达式的函数中使用间接 goto'
# 'indirection not permitted on operand of type %0'
H2DF3DCAF7C13: '操作数类型 %0 不允许进行间接寻址'
# 'indirection of non-volatile null pointer will be deleted, not trap'
H016B5CE240D6: '对非易失性空指针的间接寻址将被删除，而非触发异常'
# 'indirection requires pointer operand (%0 invalid)'
H17A67BCCC65A: '间接寻址需要指针操作数 (%0 无效)'
# "inferred framework modules cannot be 'explicit'"
HAC0CEE5A9591: '推断的框架模块不能是 `explicit`'
# 'inferred submodule cannot be a framework submodule'
H3C9148B14284: '推断的子模块不能是框架子模块'
# 'inferred submodules require a module with an umbrella'
HB4F6C039EA5A: '推断的子模块需要一个具有顶层模块的模块'
# "inferring '_Nonnull' for pointer type within %select{array|reference}0 is deprecated"
H0BCF4D33599B: '在 %select{数组|引用}0 中为指针类型推断 `_Nonnull` 已弃用'
# 'inheritance model does not match %select{definition|previous declaration}0'
H6F4F77A5056C: '继承模型与 %select{定义|之前的声明}0 不匹配'
# 'inheritance model ignored on %select{primary template|partial specialization}0'
H5E5E4985C4D2: '在 %select{主模板|偏特化}0 上忽略继承模型'
# 'inherited from base class %0 here'
H942CB9135C88: '从此基类 %0 继承而来'
# 'inherited virtual base class %1 has %select{private|protected}2 destructor'
HC776172C0FE5: '继承的虚基类 %1 具有 %select{私有|保护}2 析构函数'
# 'inheriting constructors are incompatible with C++98'
H811CC4188AC3: '继承构造函数与 C++98 不兼容'
# 'inherits from superclass %0 here'
HFC19FC83A6FB: '从此父类 %0 继承'
# 'init method must return a type related to its receiver type'
HE0B5DF2EAC96: 'init方法必须返回与其接收器类型相关的类型'
# 'init methods must return a type related to the receiver type'
H77EF2E241D1F: 'init方法必须返回与接收器类型相关的类型'
# 'init methods must return an object pointer type, not %0'
HA49BF476668F: 'init方法必须返回对象指针类型，而非%0'
# "initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')"
H55BD0EE327C7: 'OpenMP for循环的初始化子句不在规范形式（var = init 或 T var = init）'
# 'initialization is not supported for __shared__ variables'
H36A01643C5A6: '__shared__变量的初始化不受支持'
# 'initialization of %0 may run twice when built into a shared library: it has hidden visibility and external linkage'
H8FC0CAE3AC23: '具有隐藏可见性和外部链接性的%0初始化在构建为共享库时可能执行两次'
# "initialization of %select{|signed }0char array with UTF-8 string literal is not permitted by %select{'-fchar8_t'|C++20}1"
H2A8B3176C3CF: "使用%select{'-fchar8_t'|C++20}1时不允许用UTF-8字符串字面量初始化%select{有符号 |}0char数组"
# 'initialization of an array %diff{of type $ from a compound literal of type $|from a compound literal}0,1 is a GNU extension'
HA729653B7153: '从复合字面量类型$初始化数组%diff{类型$到|来自}0,1的扩展是GNU扩展'
# 'initialization of flexible array member is not allowed'
H080F42BFBE3B: '不允许初始化柔性数组成员'
# 'initialization of incomplete type %0'
H8382A60542C7: '初始化不完整类型%0'
# 'initialization of initializer_list object is incompatible with C++98'
HB868A7DFE86A: 'initializer_list对象的初始化与C++98不兼容'
# 'initialization of non-aggregate type %0 with a designated initializer list'
HD9BEB3E28681: '使用指定初始化列表初始化非聚合类型%0'
# 'initialization of non-aggregate type %0 with an initializer list'
HD61976EAB0C6: '使用初始化列表初始化非聚合类型%0'
# 'initialization of pointer of type %0 to null from a constant boolean expression'
HF7B6BD10B980: '从常量布尔表达式将类型%0指针初始化为null'
# 'initialization statement is not supported when iterating over Objective-C collection'
H6990A52E0D21: '在遍历Objective-C集合时不支持初始化语句'
# 'initialize the variable %0 to silence this warning'
HFBFEA45EAD29: '初始化变量%0以消除此警告'
# 'initialized flexible array member %0 is here'
H040CBD4967B6: '此处初始化了柔性数组成员%0'
# 'initialized here %0'
H6E543F660366: '此处初始化%0'
# 'initialized lambda capture packs are incompatible with C++ standards before C++20'
H4508A321B7A7: '已初始化的lambda捕获包与C++20之前的标准不兼容'
# 'initialized lambda captures are a C++14 extension'
HE17291BEDE3D: '已初始化的lambda捕获是C++14扩展'
# 'initialized lambda captures are incompatible with C++ standards before C++14'
H4B4A5D06C778: 'C++14之前的C++标准不支持初始化的lambda捕获'
# 'initialized lambda pack captures are a C++20 extension'
H7BA4847E4BDF: '初始化的lambda包捕获是C++20扩展特性'
# 'initializer %0 does not name a non-static data member or base class; did you mean the %select{base class|member}1 %2?'
HBFA8CB0E43F8: '初始化器%0未命名非静态数据成员或基类；是否指%select{基类|成员}1%2？'
# 'initializer %select{partially |}0overrides prior initialization of this subobject'
H5DE4CB24B2D2: '初始化器%select{部分|}0覆盖了此子对象的先前初始化'
# 'initializer element is not a compile-time constant'
H132D68BCCE73: '初始化器元素不是编译时常量'
# 'initializer for aggregate is not a compile-time constant'
H6A5ECCAF1E62: '聚合类型的初始化器不是编译时常量'
# 'initializer for aggregate with no elements requires explicit braces'
H2820D73AEF2F: '无元素的聚合类型初始化需要显式的大括号'
# 'initializer for functional-style cast to %0 contains multiple expressions'
H98881129A20C: '对%0的函数式类型转换初始化器包含多个表达式'
# 'initializer for functional-style cast to %0 is empty'
H4EA4C8E23F55: '对%0的函数式类型转换初始化器为空'
# 'initializer for lambda capture %0 contains multiple expressions'
H66A3A7273E8A: 'lambda捕获%0的初始化器包含多个表达式'
# 'initializer for sizeless type %0 cannot be empty'
H8FFA617F38FD: '无大小类型%0的初始化器不能为空'
# 'initializer for thread-local variable must be a constant expression'
HD7C0523C87D0: '线程局部变量的初始化器必须是常量表达式'
# 'initializer for variable %0 with type %1 contains multiple expressions'
HA7D83169E121: '变量%0（类型%1）的初始化器包含多个表达式'
# 'initializer for variable %0 with type %1 is empty'
HD6A61B62F49C: '变量%0（类型%1）的初始化器为空'
# 'initializer for virtual base class %0 of abstract class %1 will never be used'
H377D13F4BA4B: '抽象类%1的虚基类%0初始化器永远不会被使用'
# "initializer list cannot be used on the %select{left|right}0 hand side of operator '%1'"
H08A1BB46A564: '运算符"%1"的%select{左|右}0边不能使用初始化列表'
# 'initializer missing for lambda capture %0'
H362962332DA4: 'lambda捕获%0缺少初始化器'
# 'initializer of %0 is not a constant expression'
HF34500BAECA9: '%0的初始化器不是常量表达式'
# 'initializer of %0 is unknown'
H4815D272C20B: '%0的初始化器未知'
# 'initializer of weak variable %0 is not considered constant because it may be different at runtime'
HBD6BC73EA44F: '弱符号变量%0的初始化器在运行时可能不同，因此不被视为常量'
# 'initializer on function does not look like a pure-specifier'
H79A85F4AF5C7: '函数上的初始化器看起来不像纯说明符'
# 'initializer order does not match the declaration order'
HBA21FCA776B9: '初始化器顺序与声明顺序不匹配'
# 'initializer priorities are not supported in HLSL'
HFAA073E424F4: 'HLSL不支持初始化器优先级'
# 'initializer would partially override prior initialization of object of type %1 with non-trivial destruction'
H52C4E394B1C2: '初始化器将部分覆盖类型%1的先前初始化，该类型具有非平凡的析构函数'
# 'initializer-string for char array is too long'
HF948F6263A8D: '字符数组的初始化字符串太长'
# 'initializer-string for char array is too long, array size is %0 but initializer has size %1 (including the null terminating character)'
H17CD335B9F9F: '字符数组的初始化字符串太长，数组大小为%0，但初始化器的大小为%1（包括空终止字符）'
# 'initializing %0 from an empty initializer list is incompatible with C++98'
H822723DC0E42: '从空初始化列表初始化%0与C++98不兼容'
# "initializing 'char8_t' array with plain string literal"
H1EA4AB240813: "使用普通字符串字面量初始化'char8_t'数组"
# "initializing an array from a '%0' predefined identifier is a Microsoft extension"
H8573434E16CF: "使用'%0'预定义标识符初始化数组是Microsoft扩展"
# 'initializing char array with wide string literal'
H698D73717CFB: '使用宽字符串字面量初始化字符数组'
# 'initializing field %0 with default member initializer'
HC1BC6A14F9CB: '使用默认成员初始化器初始化字段%0'
# 'initializing multiple members of union'
HC7C97F10525A: '初始化联合的多个成员'
# 'initializing parameter %0 with default argument'
H20102CE039A6: '使用默认参数值初始化参数%0'
# 'initializing pointer member %0 to point to a temporary object whose lifetime is shorter than the lifetime of the constructed object'
H705DCA77F9DC: '指针成员%0被初始化为指向构造对象生命周期较短的临时对象'
# 'initializing pointer member %0 with the stack address of %select{variable|parameter}2 %1'
HF09BD5727610: '指针成员%0被初始化为%select{变量|参数}2 %1的栈地址'
# 'initializing wide char array with incompatible wide string literal'
HA0905D8F9102: '使用不兼容的宽字符串字面量初始化宽字符数组'
# 'initializing wide char array with non-wide string literal'
H708EA2B0EAB3: '使用非宽字符串字面量初始化宽字符数组'
# 'inline assembly label %0 declared here'
H1FAD9492270E: '此处声明了内联汇编标签%0'
# 'inline declaration of %0 follows non-inline definition'
H9E262DCDBF26: '内联声明%0跟随非内联定义'
# 'inline declaration of %0 not allowed in block scope'
H0812ED282234: '块作用域中不允许内联声明%0'
# 'inline function %q0 is not defined'
HC9FA92373F42: '内联函数 %q0 未定义'
# 'inline function not defined%select{| before the private module fragment}0'
H195EBE25939A: '内联函数未定义%select{| 在私有模块片段之前}0'
# 'inline function performs a conversion which is forbidden in ARC'
H46AB09EDECD4: '内联函数执行了ARC中禁止的转换'
# 'inline namespace reopened as a non-inline namespace'
H46A1E728D683: '内联命名空间以非内联命名空间重新打开'
# 'inline namespaces are a C++11 feature'
H39D356D1A5FD: '内联命名空间是C++11特性'
# 'inline namespaces are incompatible with C++98'
HFE4E3495E8EA: '内联命名空间与C++98不兼容'
# 'inline nested namespace definition is a C++20 extension'
HF12053D31358: '内联嵌套命名空间定义是C++20扩展'
# 'inline nested namespace definition is incompatible with C++ standards before C++20'
HDC23554C291A: '内联嵌套命名空间定义与C++20之前的C++标准不兼容'
# 'inline variable %q0 is not defined'
H2B60738BBC75: '内联变量 %q0 未定义'
# 'inline variables are a C++17 extension'
H427269D7064C: '内联变量是C++17扩展'
# 'inline variables are incompatible with C++ standards before C++17'
HCE89C300F33E: '内联变量与C++17之前的C++标准不兼容'
# "inner loops must be tightly nested inside a '%0' clause on a '%1' construct"
HE18366CA8367: "内部循环必须紧密嵌套在 '%0' 子句中的 '%1' 构造体内"
# 'input conversion stopped due to an input byte that does not belong to the input codeset UTF-8'
HC2B0606B1239: '输入转换因不属于输入字符集 UTF-8 的输入字节而停止'
# "input is not a PCH file: '%0'"
H0BA9CA2C72E0: "输入不是PCH文件: '%0'"
# "insert '%0;' to silence this warning"
H7C4DAFCB5A75: "插入 '%0;' 以静默此警告"
# "insert '%select{_Nonnull|_Nullable|_Null_unspecified}0' if the %select{pointer|block pointer|member pointer|array parameter}1 %select{should never be null|may be null|should not declare nullability}0"
H95F6AD57B128: "插入 '%select{_Nonnull|_Nullable|_Null_unspecified}0' 如果 %select{指针|块指针|成员指针|数组参数}1 %select{不应为null|可为null|不应声明空值}0"
# "insert ',' before '...' to silence this warning"
H84706E906BF0: "在 '...' 前插入 ',' 以静默此警告"
# "insert 'break;' to avoid fall-through"
H4EC7EA05AEDF: "插入 'break;' 以避免 fall-through"
# 'insert an explicit cast to silence this issue'
H21D74C2B0346: '显式插入强制转换以静默此问题'
# "install_name does not match: '%0' (provided) vs '%1' (found)"
H748B1AE34A35: "install_name 不匹配: '%0' (提供) vs '%1' (找到)"
# 'instance method %0 found instead of class method %1'
H1FCFE23050D1: '找到实例方法%0 而非类方法%1'
# "instance method %0 is being used on 'Class' which is not in the root class"
H214A12BD7783: "实例方法%0 被用在 'Class' 类型上，而该类型不在根类层级中"
# "instance method %objcinstance0 not found (return type defaults to 'id')"
HAFE085EFCB1C: "未找到实例方法%objcinstance0（返回类型默认为 'id'）"
# "instance method %objcinstance0 not found (return type defaults to 'id'); did you mean %objcinstance2?"
H44E31EFE4C27: "未找到实例方法%objcinstance0（返回类型默认为 'id'）；您是否是指 %objcinstance2？"
# 'instance variable %0 accessed in class method'
H3EADF48ACA9A: '在类方法中直接访问实例变量%0'
# 'instance variable %0 declared with incompatible types in different translation units (%1 vs. %2)'
HBFCDBA937742: '实例变量%0 在不同翻译单元中被声明为不兼容的类型（%1 与 %2）'
# 'instance variable %0 has conflicting bit-field width'
H2B77404519CC: '实例变量%0 的位段宽度冲突'
# 'instance variable %0 has conflicting type%diff{: $ vs $|}1,2'
H9D5CF719769D: '实例变量%0 的类型冲突%diff{: $ vs $|}1,2'
# 'instance variable %0 is being directly accessed'
H3F2D0ABA6990: '实例变量%0 正在被直接访问'
# 'instance variable %0 is private'
HDB3564656CA2: '实例变量%0 是私有成员'
# 'instance variable %0 is protected'
HD16F20CBE669: '实例变量%0 是受保护成员'
# 'instance variable is already declared'
H801D25BC5C9A: '实例变量已在此处声明'
# 'instance variable is declared here'
H1FC75F163FBE: '实例变量在此处声明'
# 'instance variable of type %0 has %select{private|protected}1 destructor'
HA9F26F512B98: '类型为 %0 的实例变量具有%select{私有|受保护}1 析构函数'
# 'instance variables cannot be of reference type'
HCCF4E9A4856E: '实例变量不能是引用类型'
# 'instance variables may not be placed in %select{categories|class extension}0'
H0D800B785119: '不能在%select{分类|类扩展}0 中声明实例变量'
# 'instance variables must have a constant size'
H99AB003B5614: '实例变量必须具有固定大小'
# 'instantiated into assembly here'
H396FFF689BB5: '在此处实例化为汇编代码'
# 'instantiating fold expression with %0 arguments exceeded expression nesting limit of %1'
H467EDA4122CE: '使用 %0 个参数展开折叠表达式超过表达式嵌套限制（%1）'
# 'instantiation of %q0 is different in different modules'
H7179BAA1427A: '不同模块中的%q0 实例化结果不同'
# "instantiation of '%0' not supported yet"
H5578212F4DA3: "对 '%0' 的实例化尚未支持"
# 'instantiation of function %q0 required here, but no definition is available'
H88BC3AB38294: '此处需要函数 %q0 的实例化，但未找到定义'
# 'instantiation of variable %q0 required here, but no definition is available'
H4C7FC0EFFE4E: '此处需要变量 %q0 的实例化，但未找到定义'
# 'integer constant expression evaluates to value %0 that cannot be represented in a %1-bit %select{signed|unsigned}2 integer type'
HA689EA8A19CC: '整型常量表达式计算得到无法用%1位%select{有符号|无符号}2整型表示的值 %0'
# 'integer constant not in range of enumerated type %0'
H38F9A13FA923: '整型常量超出枚举类型 %0 的取值范围'
# 'integer literal is too large to be represented in a signed integer type, interpreting as unsigned'
H510046C2B2ED: '整型字面量过大，无法用有符号整型表示，将解释为无符号类型'
# 'integer literal is too large to be represented in any %select{signed |}0integer type'
H586D057CD6B8: '整型字面量过大，无法用任何%select{有符号 |}0整型类型表示'
# "integer literal is too large to be represented in type 'long' and is subject to undefined behavior under C++98, interpreting as 'unsigned long'; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards"
H84C22AB83CDC: "整型字面量过大，无法用类型 'long' 表示，根据C++98的规范解释为 'unsigned long'；在C++11及以后，该字面量将%select{具有类型 'long long'|被视为非法}0"
# "integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C++98; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards"
H4C2C8A72E536: "整型字面量过大，无法用类型 'long' 表示，根据C89的规范解释为 'unsigned long'；在C++11及以后，该字面量将%select{具有类型 'long long'|被视为非法}0"
# "integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C89; this literal will %select{have type 'long long'|be ill-formed}0 in C99 onwards"
H58DBBF3A9BD1: "整型字面量过大，无法用类型 'long' 表示，根据C89的规范解释为 'unsigned long'；在C99及以后，该字面量将%select{具有类型 'long long'|被视为非法}0"
# 'integer overflow in preprocessor expression'
H24214C6EA913: '预处理表达式中的整数溢出'
# 'integer sequences must have integral element type'
H16392B2B25B5: '整数序列必须具有整型元素类型'
# 'integer sequences must have non-negative sequence length'
HC3DBF19F94A9: '整数序列必须具有非负长度'
# 'integer value %0 is outside the valid range of values [%1, %2] for the enumeration type %3'
HB6C02E17F94C: '整数值 %0 超出枚举类型 %3 的有效取值范围 [%1, %2]'
# 'integral constant expression has incomplete class type %0'
H52768B5A0D44: '整型常量表达式具有不完整的类类型 %0'
# 'integral constant expression requires explicit conversion from %0 to %1'
H482F498F126E: '整型常量表达式需要显式将 %0 转换为 %1'
# 'interface type %1 cannot be %select{returned|passed}0 by value; did you forget * in %1?'
H5F16699831A7: '接口类型 %1 不能%select{返回|传递}0按值；是否在 %1 中漏掉了 *？'
# 'interface type cannot be statically allocated'
HFB7A102C4547: '接口类型不能静态分配'
# 'interface type cannot inherit from %select{struct|non-public interface|class}0 %1'
HE603DB4B7CDD: '接口类型不能从%select{结构体|非公开接口|类}0 %1 继承'
# "interface types cannot specify '%select{private|protected}0' access"
H5BB34D1AC02B: "接口类型不能指定 '%select{私有|受保护}0' 访问权限"
# "interop type '%0' cannot be specified more than once"
H92EFF909211E: "互操作类型 '%0' 不能被指定超过一次"
# 'interop variable %0 used in multiple action clauses'
H6D1E048E9343: '互操作变量 %0 在多个动作子句中使用'
# "interop variable must be of type 'omp_interop_t'"
H4EE913CC5003: "互操作变量必须为类型 'omp_interop_t'"
# 'interrupt service routine cannot be called directly'
H0EEEBB03E095: '中断服务例程不能直接调用'
# "interrupt service routine with vfp enabled may clobber the interruptee's vfp state"
H55034798B0BD: '启用 VFP 的中断服务例程可能破坏被中断的 VFP 状态'
# 'introduce a parameter name to make %0 part of the selector'
HF88F126D64B8: '引入参数名称以将 %0 作为选择器的一部分'
# 'invalid #ident directive'
H33DD8376B05A: '无效的 #ident 指令'
# 'invalid %% escape in inline assembly string'
HDBE197B56289: '内联汇编字符串中无效的 %% 转义'
# "invalid %0 at end of declaration; did you mean '='?"
H6911F0CCF565: "声明结尾处的无效 %0；是否应为 '='？"
# 'invalid %select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3'
H06A881D8D9FE: '无效的 %select{算术运算在|按位操作在|比较|条件表达式在|复合赋值}0 %select{浮点|枚举}1 类型 %2 %plural{2:与|4:从|:和}0 %select{枚举|浮点}1 类型 %3'
# 'invalid %select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2'
H796D4C8F35F6: '不同枚举类型之间的无效 %select{算术运算|按位操作|比较|条件表达式|复合赋值}0%diff{ ($ 和 $)|}1,2'
# 'invalid %select{branch|return|throw}0 %select{out of|into}1 OpenACC Compute/Combined Construct'
H898CA374F6B7: '无效的 %select{分支|返回|抛出}0 %select{跳出|进入}1 OpenACC 计算/组合构造'
# 'invalid %select{constructor|destructor}0 declaration'
HDEF8993ADCB9: '无效的 %select{构造函数|析构函数}0 声明'
# "invalid 'this' expression on 'map' clause"
H008D791665EC: "'map' 子句中对 'this' 表达式的无效使用"
# "invalid -Xopenmp-target argument: '%0', options requiring arguments are unsupported"
H705427655A77: "无效的 -Xopenmp-target 参数: '%0'，需要参数的选项不受支持"
# "invalid C++ ABI name '%0'"
H8F1C2E5DB890: "无效的 C++ ABI 名称 '%0'"
# "invalid CoreFoundation Runtime ABI '%0'; must be one of 'objc', 'standalone', 'swift', 'swift-5.0', 'swift-4.2', 'swift-4.1'"
H91493C3284DF: "无效的 CoreFoundation 运行时 ABI '%0'；必须为 'objc', 'standalone', 'swift', 'swift-5.0', 'swift-4.2', 'swift-4.1' 中的一个"
# 'invalid Darwin version number: %0'
HA0C57A49CA76: '无效的 Darwin 版本号: %0'
# "invalid OS value '%0' in '%1'"
H00BD3F016742: "'%1' 中的无效操作系统值 '%0'"
# 'invalid OpenACC clause %0'
HA3099393E590: '无效的 OpenACC 子句 %0'
# "invalid OpenACC directive %select{%1|'%1 %2'}0"
H74A42ADBF419: "无效的OpenACC指令 %select{%1|'%1 %2'}0"
# 'invalid PCS type'
H696D824B4D2C: '无效的PCS类型'
# "invalid RVV vector size '%0', expected size is '%1' based on LMUL of type and '-mrvv-vector-bits'"
H96A03531A0AD: "无效的RVV向量大小'%0'，根据类型LMUL和'-mrvv-vector-bits'参数，预期的大小应为'%1'"
# "invalid SVE vector size '%0', must match value set by '-msve-vector-bits' ('%1')"
HF993CA8A3093: "无效的SVE向量大小'%0'，必须与'-msve-vector-bits'设置的值'%1'一致"
# 'invalid UTF-8 in comment'
H58EB41DE8F48: '注释中的无效UTF-8编码'
# "invalid Xarch argument: '%0', not all driver options can be forwared via Xarch argument"
HA12658A01ACA: "无效的Xarch参数：'%0'，并非所有驱动选项都可通过Xarch参数传递"
# "invalid Xarch argument: '%0', options requiring arguments are unsupported"
H7917BEC4B42C: "无效的Xarch参数：'%0'，需要参数的选项不被支持"
# 'invalid __hlsl_resource_t type attributes'
H9A97FF7B54BE: '无效的__hlsl_resource_t类型属性'
# 'invalid address discrimination mode %0'
H1D217687F248: '无效的地址区分模式%0'
# "invalid alignment option in '#pragma %select{align|options align}0' - ignored"
H410475644E70: "在'#pragma %select{align|options align}0'中指定了无效的对齐选项 - 已忽略"
# "invalid application of '%0' to %select{an incomplete|sizeless}1 type %2"
H3984632B643A: "将'%0'应用于%select{不完整|无大小}1类型%2是无效的"
# "invalid application of '%0' to WebAssembly table"
HA443432F106F: "将'%0'应用于WebAssembly表无效"
# "invalid application of '%0' to a function type"
HFD1A077F0D84: "将'%0'应用于函数类型无效"
# "invalid application of '%0' to a void type"
H3290D1C688B6: "将'%0'应用于void类型无效"
# "invalid application of '%select{sizeof|alignof|typeof|typeof_unqual}0' to bit-field"
H4D97635BE644: "将'%select{sizeof|alignof|typeof|typeof_unqual}0'应用于位域无效"
# "invalid application of '__builtin_omp_required_simd_align' to an expression, only type is allowed"
H0F35C466B34C: '__builtin_omp_required_simd_align只能用于类型，不能应用于表达式'
# "invalid application of 'alignof' to a field of a class still being defined"
H584C8A2541E4: "将'alignof'应用于仍在定义中的类的字段无效"
# "invalid application of 'offsetof' to a field of a virtual base"
H7E5DD90FD952: "将'offsetof'应用于虚基类的字段无效"
# "invalid arch name '%0'"
H053EB6DE40C8: "无效的架构名称'%0'"
# "invalid arch name '%0', %1"
HAF3A77CFBCF8: "无效的架构名称'%0'，%1"
# 'invalid argument %0 to function: %1, expecting a generic pointer argument'
H45B49DB90594: '函数%1的参数%0无效：期望一个通用指针参数'
# "invalid argument '%0' not allowed with '%1'"
H5F814EC912CC: "与'%1'不能同时使用的无效参数'%0'"
# "invalid argument '%0' only allowed with '%1'"
HCD365CC8E5D4: "仅允许与'%1'一起使用的无效参数'%0'"
# "invalid argument '%0' to -%1"
H8405E80D8137: "选项-%1的无效参数'%0'"
# "invalid argument '%0' to -malign-branch=; each element must be one of: %1"
H20657E1CDBBF: "选项-malign-branch=的无效参数'%0'；每个元素必须是以下之一： %1"
# "invalid argument '%0' to -mfpu=; must be one of: 64, 32, none, 0 (alias for none)"
HF131652C4C29: "选项-mfpu=的无效参数'%0'；必须为以下之一：64、32、none、0（等同于none）"
# "invalid argument '%0' to -msimd=; must be one of: none, lsx, lasx"
H2BA112BC46B6: "选项-msimd=的无效参数'%0'；必须为以下之一：none、lsx、lasx"
# "invalid argument '%0' to atomic attribute; valid options are: 'remote_memory', 'fine_grained_memory', 'ignore_denormal_mode' (optionally prefixed with 'no_')"
H438B1A442EF4: "原子属性的无效参数'%0'；有效选项包括：'remote_memory', 'fine_grained_memory', 'ignore_denormal_mode'（可选前缀'no_'）"
# "invalid argument '-mno-amdgpu-ieee' only allowed with relaxed NaN handling"
H507F0448DDCC: "无效选项 '-mno-amdgpu-ieee' 仅在启用宽松NaN处理时允许"
# "invalid argument in '%0', only integer or 'auto' is supported"
H40210717B247: "在'%0'中参数无效，仅支持整数或'auto'"
# "invalid argument in '%0', only integers are supported"
H7CC5EAE0927D: "在'%0'中参数无效，仅支持整数"
# 'invalid argument of type %0; expected an integer type'
HDC97D348BCF9: '类型%0的无效参数；期望一个整数类型'
# 'invalid argument to convert to character'
H035CE8B39D0F: '无法转换为字符类型的无效参数'
# 'invalid argument type %0 to unary expression'
HB7A2329B026C: '一元表达式参数类型%0无效'
# 'invalid argument type to function %0 (expecting %1 having %2)'
H740D8FB32D84: '函数%0的参数类型%1无效（应为%2类型）'
# 'invalid argument: symbol must be a device-side function or global variable'
HB29E0DD1BCB5: '无效参数：符号必须是设备端函数或全局变量'
# "invalid argument; expected 'disable'"
H14256C1A2363: "无效参数；期望'disable'"
# "invalid argument; expected 'enable'%select{|, 'full'}0%select{|, 'assume_safety'}1 or 'disable'"
H369903756AB7: "无效参数；期望'enable'%select{|, 'full'}0%select{|, 'assume_safety'}1 或 'disable'"
# 'invalid authentication key %0'
H1380B8ED725A: '无效的认证密钥%0'
# 'invalid block pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
H1E4447440EDF: '块指针转换无效%select{%diff{将$分配给$|不同类型的赋值}0,1|%diff{将$传递给类型$的参数|传递到不同类型参数}0,1|%diff{从返回类型$的函数返回$|函数返回类型不匹配}0,1|%diff{将$转换为类型$|不同类型的转换}0,1|%diff{用类型$的表达式初始化$|表达式类型与初始化类型不匹配}0,1|%diff{将$发送到类型$的参数|发送到不同类型参数}0,1|%diff{将$强制转换为类型$|不同类型的强制转换}0,1}2'
# 'invalid block variable declaration - must be %select{const qualified|initialized}0'
HF892D907A5A7: '无效的块变量声明 - 必须是%select{const限定|已初始化}0'
# "invalid block variable declaration - using 'extern' storage class is disallowed"
H2029EAB9FA9A: "无效的块变量声明 - 不允许使用'extern'存储类"
# 'invalid branch into OpenACC Compute/Combined Construct'
HC49FDF0B5C89: '无效的进入OpenACC Compute/Combined Construct的分支'
# 'invalid branch out of OpenACC Compute/Combined Construct'
H921800904C81: '无效的退出OpenACC Compute/Combined Construct的分支'
# "invalid branch protection option '%0' in '%1'"
H69A222420F22: "在'%1'中的分支保护选项'%0'无效"
# "invalid character '%0' in raw string delimiter; use PREFIX( )PREFIX to delimit raw string"
H82170E32D0E4: "原始字符串分隔符中的无效字符'%0'；使用PREFIX( )PREFIX来分隔原始字符串"
# "invalid comparison flag %0; use 'layout_compatible' or 'must_be_null'"
H677EA1A68EB0: "无效的比较标志%0；使用'layout_compatible'或'must_be_null'"
# "invalid component '%0' used; expected 'x', 'y', 'z', or 'w'"
H32632D0CDE2F: "无效的组件'%0'；应使用'x'、'y'、'z'或'w'"
# 'invalid constructor from class in system header, should not be explicit'
HEFC602372E3E: '来自系统头文件的类的无效构造函数，不应显式声明'
# 'invalid conversion between ext-vector type %0 and %1'
H4E43BF77A891: '不同类型大小的向量类型%0和%1之间的无效转换'
# 'invalid conversion between vector type %0 and integer type %1 of different size'
HAD5A2EB8C76E: '不同类型大小的向量类型%0和整型类型%1之间的无效转换'
# 'invalid conversion between vector type %0 and scalar type %1'
H0E21BE8324C1: '向量类型%0和标量类型%1之间的无效转换'
# 'invalid conversion between vector type%diff{ $ and $|}0,1 of different size'
H62FB40425AFD: '不同大小的向量类型%diff{ $和$|}0,1之间的无效转换'
# "invalid conversion specifier '%0'"
H36DE3CE25255: "无效的格式说明符'%0'"
# 'invalid covariant return for virtual function: %1 is a %select{private|protected}2 base class of %0'
HB307942D226E: '虚函数的协变返回类型无效：%1是%0的%select{私有|保护}2基类'
# 'invalid cpu feature string for builtin'
H63D2023D3150: '内置函数的无效CPU特性字符串'
# 'invalid cpu name for builtin'
HD2B5E0F427CF: '内置函数的无效CPU名称'
# 'invalid custom discrimination'
HBF55CC3D0D6C: '无效的自定义判别式'
# 'invalid declaration inside %select{tbuffer|cbuffer}0'
H75299BE36932: '在%select{tbuffer|cbuffer}0内部的无效声明'
# 'invalid declaration specifier in template non-type parameter'
HE0A0675789D7: '模板非类型参数中的无效声明说明符'
# 'invalid diagnostic type for \'diagnose_if\'; use "error" or "warning" instead'
HD2E5D476D869: '无效的诊断类型用于\'diagnose_if\'; 使用"error"或"warning"代替'
# "invalid digit '%0' in %select{decimal|octal|binary}1 constant"
H6F9BD80EC0BE: "无效的数字'%0'在%select{十进制|八进制|二进制}1常量中"
# "invalid digit '%0' in escape sequence"
HF729B18CD0D2: "无效的数字'%0'在转义序列中"
# "invalid escape sequence '%0' in an unevaluated string literal"
HF58F976119B7: "无效的转义序列'%0'在未求值的字符串字面量中"
# "invalid exception model '%select{none|sjlj|seh|dwarf|wasm}0' for target '%1'"
H00FCEE8853CC: "目标'%1'的无效异常模型'%select{none|sjlj|seh|dwarf|wasm}0'"
# 'invalid expected %0: %1'
HE0DC8B702320: '无效的预期%0: %1'
# 'invalid explicit object parameter type %0 in lambda with capture; the type must be the same as, or derived from, the lambda'
H98E01B807F8E: '具有捕获的lambda的显式对象参数类型%0无效; 类型必须与lambda相同或派生自lambda'
# 'invalid explicit object parameter type %0 in lambda with capture; the type must derive publicly from the lambda'
H607716F86E02: '具有捕获的lambda的显式对象参数类型%0无效; 类型必须公开派生自lambda'
# 'invalid extra discrimination selection %0'
HAC5AAEAB2B1D: '无效的额外判别选择%0'
# 'invalid feature combination: %0'
H53E34DDB7754: '无效的特性组合: %0'
# 'invalid field is here'
H6F033E1FBEC9: '无效的字段在此处'
# 'invalid filename for #line directive'
H5BFFCF48D855: '#line指令的无效文件名'
# 'invalid filename for line marker directive'
H6AF3C8643D27: '行标记指令的无效文件名'
# 'invalid flag line marker directive'
H5CC65A10A5E0: '无效的标志行标记指令'
# "invalid float ABI '%0'"
H606FAE3A11E2: "无效的浮点ABI '%0'"
# "invalid iOS deployment version '%0', iOS 10 is the maximum deployment target for 32-bit targets"
HD422F25540A2: "无效的iOS部署版本'%0', iOS 10是32位目标的最大部署目标"
# 'invalid index %0 for pack %1 of size %2'
H1627FB393F43: '大小为%2的参数包%1的无效索引%0'
# "invalid input constraint '%0' in asm"
H09D927559067: "asm中无效的输入约束'%0'"
# "invalid input for analyzer-config option '%0', that expects %1 value"
HB14EB9C7A93F: "分析器配置选项'%0'的无效输入，该选项需要%1值"
# "invalid input for checker option '%0', that expects %1"
H784B521FDFA9: "检查器选项'%0'的无效输入，该选项需要%1"
# "invalid input size for constraint '%0'"
H8F6CDB6F0449: "约束 '%0' 的输入大小无效"
# "invalid integral value '%1' in '%0'"
H6E04ED0681B7: "在 '%0' 中，整数值 '%1' 无效"
# "invalid invocation of method '%0' on a temporary object while it is in the '%1' state"
H6C0DF8705FCA: "当临时对象处于 '%1' 状态时，对方法 '%0' 的调用无效"
# "invalid invocation of method '%0' on object '%1' while it is in the '%2' state"
HD38690B94C13: "当对象 '%1' 处于 '%2' 状态时，对方法 '%0' 的调用无效"
# "invalid library name in argument '%0'"
H64F3D932433A: "参数 '%0' 中的库名称无效"
# "invalid line marker flag '2': cannot pop empty include stack"
H37DFD44E19FB: "无效的行标记标志 '2': 无法弹出空的包含栈"
# "invalid linker name in argument '%0'"
HC2FCA31CF12C: "参数 '%0' 中的链接器名称无效"
# 'invalid literal operator parameter type %0, did you mean %1?'
H0C90111229B8: '字面运算符参数类型 %0 无效，是否应为 %1？'
# "invalid lvalue in asm input for constraint '%0'"
H2CA59C9EF59C: "约束 '%0' 的内联汇编输入中的左值无效"
# 'invalid lvalue in asm output'
HED6C7D31AA01: '内联汇编输出中的左值无效'
# 'invalid matrix element type %0'
H9CDCD6DAE3BE: '无效的矩阵元素类型 %0'
# 'invalid newline character in raw string delimiter; use PREFIX( )PREFIX to delimit raw string'
HF6C358E90110: '原始字符串定界符中的换行符无效；请使用 PREFIX( )PREFIX 来定界原始字符串'
# 'invalid number of arguments to function: %0'
H3D5EA8973A6F: '函数参数数量无效: %0'
# "invalid offload arch combinations: '%0' and '%1' (for a specific processor, a feature should either exist in all offload archs, or not exist in any offload archs)"
H92F337A26551: "无效的offload架构组合: '%0' 和 '%1'（对于特定处理器，特性应存在于所有offload架构中，或不存在于任何offload架构中）"
# 'invalid operand number in inline asm string'
H3DCCD1026997: '内联汇编字符串中的操作数编号无效'
# 'invalid operand of type %0 where %1 or a vector of such type is required'
HD52C15C02D70: '操作数类型 %0 无效，需要类型 %1 或该类型的向量'
# 'invalid operand of type %0 where floating, complex or a vector of such types is required'
HC1A341FFC462: '操作数类型 %0 无效，需要浮点、复数或该类型的向量'
# 'invalid operand of type %0%select{| where a scalar or vector is required}1'
H848780E5A063: '操作数类型 %0%select{|（需要标量或向量类型）}1 无效'
# 'invalid operands to binary expression (%0 and %1)'
HC5560B091967: '二进制表达式中的操作数类型无效 (%0 和 %1)'
# "invalid option '%0' for %select{cpu_specific|cpu_dispatch}1"
HEFAAB35E81AF: "选项 '%0' 无效，%select{cpu_specific|cpu_dispatch}1"
# "invalid option '%0' not of the form <from-file>;<to-file>"
HCB5BB85712F1: "无效的选项 '%0'，不符合<from-file>;<to-file>的格式"
# 'invalid option combination; LASX depends on LSX'
H7E946D645C29: '无效的选项组合；LASX依赖于LSX'
# "invalid or misplaced branch protection specification '%0'"
H9377B8FCDAC3: "无效或放置位置错误的分支保护规范 '%0'"
# "invalid or unsupported offload target: '%0'"
H4E7457AF1786: "无效或不受支持的offload目标: '%0'"
# "invalid or unsupported rounding mode in '#pragma STDC FENV_ROUND' - ignored"
HDB0B7F11E503: "在 '#pragma STDC FENV_ROUND' 中指定了无效或不受支持的舍入模式 - 已忽略"
# "invalid output constraint '%0' in asm"
H686C32E03A9D: "asm中的无效输出约束 '%0'"
# "invalid output size for constraint '%0'"
HA9017C3CAD23: "约束 '%0' 的输出大小无效"
# "invalid output type '%0' for use with gcc tool"
H1AE0ECD8B562: "与gcc工具一起使用时无效的输出类型 '%0'"
# "invalid parameter name: '%0' is a keyword"
HBA4C66D8A8AA: "无效的参数名称：'%0' 是一个关键字"
# 'invalid parameter type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator; found %1, expected %2%select{| or %4}3'
H1333988BA8FC: '默认的%select{<ERROR>|相等|三向|相等|关系}0比较运算符的参数类型无效；找到%1，期望%2%select{|或 %4}3'
# 'invalid parameter type for non-member defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator; found %1, expected class or reference to a constant class'
HEB967961C960: '非成员默认的%select{<ERROR>|相等|三向|相等|关系}0比较运算符的参数类型无效；找到%1，期望类或常量类的引用'
# 'invalid pipe access modifier (expecting %0)'
HA4FFF117B821: '无效的管道访问修饰符（期望%0）'
# 'invalid position specified for %select{field width|field precision}0'
H5DF564C1B18C: '为%select{字段宽度|字段精度}0指定的无效位置'
# "invalid preprocessing directive%select{|, did you mean '#%1'?}0"
H852ECDD7D2C3: '无效的预处理指令%select{|，您是指"#%1"?}0'
# 'invalid profile : %0'
H35AB0F2CB838: '无效的配置文件： %0'
# 'invalid protocol qualifiers on non-ObjC type'
H3723A726B37F: '非ObjC类型上的无效协议限定符'
# 'invalid prototype, variadic arguments are not allowed in OpenCL'
H5E1888FFA26E: '无效的原型，在OpenCL中不允许使用可变参数'
# "invalid range expression of type %0; did you mean to dereference it with '*'?"
H1FCBEB4D2213: '类型为%0的无效区间表达式；您是否打算用"*"进行解引用？'
# "invalid range expression of type %0; no viable '%select{begin|end}1' function available"
H76B630AFA57F: '类型为%0的无效区间表达式；没有可用的"%select{begin|end}1"函数'
# "invalid range following '-' in expected %0"
H99FD9B7E0352: '在预期的%0中，"-"后的区间无效'
# "invalid reduction operator,  expected '+', '*', 'max', 'min', '&', '|', '^', '&&', or '||'"
H3407BE2F5E5D: "无效的约简运算符，预期为 '+', '*', 'max', 'min', '&', '|', '^', '&&' 或 '||'"
# 'invalid reference to function %0: constraints not satisfied'
H9E6FAF3D6010: '对函数%0的无效引用：约束条件未满足'
# 'invalid reinterpretation: sizes of %0 and %1 must match'
HC6E0606A101D: '无效的重新解释：%0和%1的大小必须匹配'
# "invalid resource class specifier '%0' for packoffset, expected 'c'"
H2B96C40BB1F0: "packoffset的无效资源类指定符'%0'，预期为'c'"
# 'invalid rounding argument'
HD77BD554C068: '无效的舍入参数'
# "invalid runtime library name in argument '%0'"
HCC4F20591ADF: "参数'%0'中无效的运行时库名称"
# 'invalid size value'
H41C03C7DB477: '无效的大小值'
# "invalid space specifier '%0' used; expected 'space' followed by an integer, like space1"
HB8CFB0AAB2CD: "使用的无效空间指定符'%0'；预期为后跟整数的'space'，例如space1"
# 'invalid special register for builtin'
H26E533E2D360: '内置函数的无效特殊寄存器'
# 'invalid storage class specifier in function declarator'
HF2FD2E42B318: '函数说明符中的无效存储类说明符'
# "invalid string literal, ignoring final '\\'"
H550F921F116D: "无效的字符串文字，忽略末尾的'\\'"
# "invalid suffix '%0' on %select{integer|floating|fixed-point}1 constant"
HFE61994BB7A3: "在%select{整型|浮点型|定点型}1常量上的无效后缀'%0'"
# 'invalid suffix on literal; C++11 requires a space between literal and identifier'
H3AC3DC712C63: '文字的无效后缀；C++11要求文字和标识符之间有一个空格'
# "invalid tag %0 on '%1' %select{directive|clause}2"
HB6EF4B837656: "在'%1'的%select{指令|子句}2上的无效标签%0"
# "invalid target ID '%0'; format is a processor name followed by an optional colon-delimited list of features followed by an enable/disable sign (e.g., 'gfx908:sramecc+:xnack-')"
HF2F065F66FFD: "无效的目标ID'%0'；格式为处理器名称后可接用冒号分隔的功能列表，再接启用/禁用符号（例如'gfx908:sramecc+:xnack-'）"
# 'invalid target type %0 for dynamic_cast; target type must be a reference or pointer type to a defined class'
HFE4D2B7D8E06: 'dynamic_cast的无效目标类型%0；目标类型必须是对已定义类的引用或指针类型'
# "invalid thread model '%0' in '%1' for this target"
HE75965380195: "在此目标的'%1'中的无效线程模型'%0'"
# "invalid thread pointer reading mode '%0'"
H602D0823E0FB: "无效的线程指针读取模式'%0'"
# 'invalid token at start of a preprocessor expression'
HAAFAB4DB043C: '预处理器表达式开头的无效标记'
# 'invalid token in macro parameter list'
HA6A8BDC08D89: '宏参数列表中的无效标记'
# 'invalid transaction abort code'
H75E4D8742736: '无效的事务中止代码'
# 'invalid type %0 as argument of iboutletcollection attribute'
HE41F37E3851B: 'iboutletcollection属性的参数类型%0无效'
# 'invalid type %0 in asm %select{input|output}1'
H2A71CC82E6A7: '汇编%select{输入|输出}1中的类型%0无效'
# "invalid type %0 in asm input for constraint '%1'"
H1E6A37C4D619: "汇编输入的约束'%1'中类型%0无效"
# 'invalid type %0 is a %select{member|base}1 of %2'
HB6D9D0DC110A: '无效类型%0是%select{成员|基类}1的%2'
# 'invalid type %0 to %1 operator'
H4C8C1A65C2A4: '无效类型%0到%1运算符'
# 'invalid universal character'
H73C6676CA247: '无效通用字符'
# "invalid unwind library name in argument '%0'"
HD675186A50F6: "参数'%0'中的解扰库名称无效"
# "invalid use of '__funcref' keyword outside the WebAssembly triple"
H5B018C340841: "在WebAssembly架构外使用'__funcref'关键字的无效用法"
# "invalid use of '__super', %0 has no base classes"
HC8BFC8F3D816: '无效的__super用法，%0没有基类'
# "invalid use of '__super', this keyword can only be used inside class or member function scope"
H02BB07D5882C: '无效的__super用法，此关键字只能在类或成员函数作用域内使用'
# "invalid use of 'this' %select{outside of a non-static member function|in a function with an explicit object parameter}0"
H9633100217CB: "在%select{非静态成员函数外部|带有显式对象参数的函数中}0使用'this'无效"
# 'invalid use of PPC MMA type'
H23BD562DB2DF: 'PowerPC MMA类型的无效用法'
# 'invalid use of a cast in an inline asm context requiring an lvalue'
H5D073F64410B: '在需要左值的内联汇编上下文中对强制类型转换的无效使用'
# 'invalid use of incomplete type %0'
H7FE8554F5009: '无效的不完全类型%0的用法'
# 'invalid use of member %0 in %select{static|explicit object}1 member function'
H50EBCD910232: '在%select{静态|显式对象}1成员函数中对成员%0的无效使用'
# 'invalid use of non-static data member %0'
H59D616D352F1: '非静态数据成员%0的无效使用'
# 'invalid use of pointer to member type after %select{.*|->*}0'
H48A2AD1643D5: '%select{.*|->*}0之后的成员指针类型无效'
# 'invalid validator version : %0; format of validator version is "<major>.<minor>" (ex:"1.4")'
H4B1AA82F67A0: '无效的验证程序版本：%0；验证程序版本格式应为"<主版本>.<次版本>"（例如："1.4"）'
# 'invalid validator version : %0; if validator major version is 0, minor version must also be 0'
HD365448B0579: '无效的验证程序版本：%0；如果验证程序主版本号为0，则次版本号也必须为0'
# 'invalid validator version : %0; validator version must be less than or equal to current internal version'
HED613B352B91: '无效的验证器版本：%0；验证器版本必须小于或等于当前内部版本'
# "invalid value '%1' in '%0'"
H7E000E39503F: "在'%0'中无效的值'%1'"
# "invalid value '%1' in '%0', expected one of: %2"
H22924648CBBA: "在'%0'中无效的值'%1'，期望其中一个：%2"
# "invalid value '%1' in '%0', value must be '%2' or greater"
H38383851595E: "在'%0'中无效的值'%1'，值必须是'%2'或更大"
# "invalid value '%1' in '%0', value must be 'none' or a positive integer"
H9E8659EA6C7E: "在'%0'中无效的值'%1'；对齐必须是2的幂次方"
# "invalid value '%1' in '%0'; alignment must be a power of 2"
H2DA82E98A2A4: "选项 '%0' 中无效值 '%1'；对齐必须为2的幂"
# "invalid value for 'default' clause; expected 'present' or 'none'"
H8D0169FE239F: "'default' 子句无效值；预期 'present' 或 'none'"
# 'invalid vector element type %0'
HEFB9A08F90A0: "在'%0'中无效的版本号"
# "invalid version number in '%0'"
H561E007CCA86: "无效的虚拟文件系统覆盖文件'%0'"
# "invalid virtual filesystem overlay file '%0'"
HBFF79FC3240A: "无效的虚拟文件系统覆盖文件 '%0'"
# "invoking a pointer to a 'const &' member function on an rvalue is a C++20 extension"
HDCED919CDE9E: "对右值调用指向'const &'成员函数的指针与C++20之前的C++标准不兼容"
# "invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++20"
H06659E61779A: "在C++20之前，对rvalue调用'const &'成员函数指针与C++标准冲突"
# "isa trait '%0' is not known to the current target; verify the spelling or consider restricting the context selector with the 'arch' selector further"
H0ED9A7F36C30: "目标架构未识别特性 '%0'；请检查拼写或通过'arch'选择器限制上下文"
# "it could also be property %select{of type %1|without attribute '%1'|with attribute '%1'|with getter %1|with setter %1}0 declared here"
H91A939A34A63: "它也可能是属性 %select{类型 %1|无 '%1' 属性|具有 '%1' 属性|具有 getter %1|具有 setter %1}0 在此处声明"
# 'it delegates to'
H01E41C702CFA: '其委托到'
# 'iterator step expression %0 evaluates to 0'
H68A0F13C3B50: '迭代器步长表达式%0不是整型表达式'
# 'iterator step expression %0 is not the integral expression'
H5E0FE51F5C8D: '支撑该属性的实例变量%0未在此属性的访问器中被引用'
# "ivar %0 which backs the property is not referenced in this property's accessor"
HB68211D86C75: "连接参数期望附加值：'%0'"
# "joined argument expects additional value: '%0'"
H67B5A91D2948: "连接参数需要额外值：'%0'"
# "joined argument treated as '%0'; did you mean '%1'?"
HAC9E756384DA: "合并的参数被当作'%0'处理；您是指'%1'吗？"
# 'jump bypasses OpenMP structured block'
H38D141B68E15: '跳跃绕过了OpenMP结构化块'
# 'jump bypasses auto release push of @autoreleasepool block'
H673B2CE5E964: '跳跃绕过了@autoreleasepool块的自动释放推送'
# 'jump bypasses initialization of @catch block'
HBE63405914D4: '跳跃绕过了@catch块的初始化'
# 'jump bypasses initialization of @finally block'
HC258EB27DC7D: '跳跃绕过了@finally块的初始化'
# 'jump bypasses initialization of @synchronized block'
HB49518EF658F: '跳跃绕过了@synchronized块的初始化'
# 'jump bypasses initialization of @try block'
H4F2203657B83: '跳跃绕过了@try块的初始化'
# 'jump bypasses initialization of VLA type alias'
H06AE800C9022: '跳跃绕过了VLA类型别名的初始化'
# 'jump bypasses initialization of VLA typedef'
H539D32051794: '跳跃绕过了VLA类型定义的初始化'
# 'jump bypasses initialization of __except block'
H8945BA31631C: '跳跃绕过了__except块的初始化'
# 'jump bypasses initialization of __finally block'
HDC8606BFB8A0: '跳跃绕过了__finally块的初始化'
# 'jump bypasses initialization of __strong variable'
H4091D3DFA80B: '跳跃绕过了__strong变量的初始化'
# 'jump bypasses initialization of __try block'
H17A1FDC40633: '跳跃绕过了__try块的初始化'
# 'jump bypasses initialization of __weak variable'
H2D2E5414450F: '跳跃绕过了__weak变量的初始化'
# 'jump bypasses initialization of catch block'
H1AD4DA299533: '跳跃绕过了catch块的初始化'
# 'jump bypasses initialization of non-POD variable'
H7894E3C8480C: '跳跃绕过了非POD变量的初始化'
# 'jump bypasses initialization of try block'
H35C99F3D2CF6: '跳跃绕过了try块的初始化'
# 'jump bypasses initialization of variable length array'
HD2CC21B5B2B9: '跳跃绕过了可变长度数组的初始化'
# 'jump bypasses initialization of variable of non-trivial C struct type'
H8DC117DB27D9: '跳跃绕过了非平凡C结构体类型的变量初始化'
# 'jump bypasses initialization of variable with __attribute__((cleanup))'
H816408F197AB: '跳跃绕过了带有__attribute__((cleanup))属性的变量的初始化'
# 'jump bypasses setup of __block variable'
H8FF055D54D20: '跳转跳过了__block变量的设置'
# 'jump bypasses variable initialization'
HDE484302CFDD: '跳转跳过了变量初始化'
# 'jump bypasses variable with a non-trivial destructor'
H65EAD2757089: '跳转跳过了具有非平凡析构函数的变量'
# 'jump enters Objective-C fast enumeration loop'
H0B68A5227D3D: '跳转进入Objective-C快速枚举循环'
# 'jump enters a statement expression'
HAF0C1FFF2BB0: '跳转进入语句表达式'
# 'jump enters controlled statement of consteval if'
H9FCC3E0998D5: '跳转进入consteval if的控制语句'
# 'jump enters controlled statement of constexpr if'
H53B0DD3B4BCF: '跳转进入constexpr if的控制语句'
# 'jump enters controlled statement of if available'
H0D6B49E1C06A: '跳转进入if available的控制语句'
# 'jump enters lifetime of a compound literal that is non-trivial to destruct'
H84D2F4FDA1F2: '跳转进入复合字面量的生命周期，其析构过程非平凡'
# 'jump enters lifetime of block which captures a C struct that is non-trivial to destroy'
HB60961C86BE4: '跳转进入捕获了非平凡可销毁C结构的块的生命周期'
# 'jump enters lifetime of block which captures a destructible C++ object'
HFA59EFDF1B62: '跳转进入捕获了可销毁C++对象的块的生命周期'
# 'jump enters lifetime of block which strongly captures a variable'
H2E28FE1D13B9: '跳转进入强捕获变量的块的生命周期'
# 'jump enters lifetime of block which weakly captures a variable'
H8ED7B1ED0204: '跳转进入弱捕获变量的块的生命周期'
# 'jump exits @catch block'
H00823EBB1453: '跳转退出@catch块'
# 'jump exits @finally block'
HDE9FECD28D12: '跳转退出@finally块'
# 'jump exits @synchronized block'
H2C2C500585D3: '跳转退出@synchronized块'
# 'jump exits @try block'
H60631B3B104F: '跳转退出@try块'
# 'jump exits __except block'
HF0ECDC1D667A: '跳转退出__except块'
# 'jump exits __finally block'
HEF15A26AC2B4: '跳转退出__finally块'
# 'jump exits __try block'
HA371EC6EABEF: '跳转退出__try块'
# 'jump exits autoreleasepool block'
HFA1102E13121: 'jump exits autoreleasepool块'
# 'jump exits catch block'
HB15A540E97C0: 'jump exits catch块'
# 'jump exits lifetime of a compound literal that is non-trivial to destruct'
H581CCAF33BA1: 'jump exits 非平凡析构的复合字面量的生命周期'
# 'jump exits lifetime of block which captures a C struct that is non-trivial to destroy'
H145F09CDB728: 'jump exits 捕获了非平凡销毁C结构体的block的生命周期'
# 'jump exits lifetime of block which captures a destructible C++ object'
HFD90BDF2A71A: 'jump exits 捕获了可析构C++对象的block的生命周期'
# 'jump exits lifetime of block which strongly captures a variable'
H633C0158D8CE: 'jump exits 强捕获变量的block的生命周期'
# 'jump exits lifetime of block which weakly captures a variable'
H3C3B445ACF96: 'jump exits 弱捕获变量的block的生命周期'
# 'jump exits scope of OpenMP structured block'
H3960249ABF56: 'jump exits OpenMP结构化块的作用域'
# 'jump exits scope of __block variable'
HCAFFF794B0B7: 'jump exits __block变量的作用域'
# 'jump exits scope of __strong variable'
H09130C2189DF: 'jump exits __strong变量的作用域'
# 'jump exits scope of __weak variable'
H425A195D6F14: 'jump exits __weak变量的作用域'
# 'jump exits scope of lifetime-extended temporary with non-trivial destructor'
H18BAD42D7AAF: 'jump exits 非平凡析构的临时对象的生命周期'
# 'jump exits scope of variable with __attribute__((cleanup))'
H4BF0CCE50F51: 'jump exits __attribute__((cleanup))变量的作用域'
# 'jump exits scope of variable with non-trivial destructor'
HD66C6E5AB564: 'jump exits 非平凡析构函数的变量的作用域'
# 'jump exits try block'
HE15267C61E24: 'jump exits try块'
# 'jump from switch statement to this case label is incompatible with C++98'
HFD45DFD4341B: '从switch语句跳转到此case标签与C++98不兼容'
# 'jump from this %select{indirect|asm}0 goto statement to one of its possible targets is incompatible with C++98'
H6B5196F09490: '从此%select{indirect|asm}0 goto语句跳转到其可能目标与C++98不兼容'
# 'jump from this goto statement to its label is a Microsoft extension'
HF443D2C187C8: '从此goto语句跳转到其标签是Microsoft扩展'
# 'jump from this goto statement to its label is incompatible with C++98'
H91A60091F523: '从此goto语句跳转到其标签与C++98不兼容'
# 'jump out of __finally block has undefined behavior'
HC63318A29EFB: '从__finally块跳出具有未定义行为'
# 'kernel call to non-global function %0'
HE2C1F06E4669: '内核调用非全局函数 %0'
# 'kernel function %0 is a member function; this may not be accepted by nvcc'
H6C2BA696CEAF: '内核函数 %0 是成员函数；这可能不被 nvcc 接受'
# 'kernel function %0 must be a free function or static member function'
H16FEF3B5D436: '内核函数 %0 必须是自由函数或静态成员函数'
# 'kernel function type %0 must have void return type'
H95AC5DFCBCA0: '内核函数类型 %0 必须具有 void 返回类型'
# 'kernel functions cannot be class members'
H49F7A4460E40: '内核函数不能是类成员'
# 'kernel functions cannot be declared static'
H4969597F9236: '内核函数不能被声明为 static'
# 'kernel functions cannot be used in a template declaration, instantiation or specialization'
HD5AD84DAA9C6: '内核函数不能在模板声明、实例化或特化中使用'
# 'kernel must have void return type'
H2245CF70F0F9: '内核必须具有 void 返回类型'
# 'kernel parameter cannot be declared as a pointer to a pointer'
HA03E5339986E: '内核参数不能被声明为指针到指针'
# "keyword '%0' will be made available as an identifier %select{here|for the remainder of the translation unit}1"
HB2136B9BC89D: "关键字 '%0' 将作为标识符 %select{此处|在翻译单元的剩余部分}1 提供"
# 'keyword is hidden by macro definition'
HB53596605CAF: '关键字被宏定义隐藏'
# "known but unsupported action '%1' for '#pragma %0' - ignored"
H07B6796F45BE: "已知但不受支持的 '#pragma %0' 操作 '%1' - 已忽略"
# "label '%0' is reserved: use a different label name for -X<label>"
H0A75EFF64B4C: "标签 '%0' 是保留的：为 -X<label> 使用不同的标签名称"
# 'label at end of compound statement is a C++23 extension'
H696C9202732B: '复合语句末尾的标签是 C++23 扩展'
# 'label at end of compound statement is a C23 extension'
H24E471EE8FE1: '复合语句末尾的标签是 C23 扩展'
# 'label at end of compound statement is incompatible with C standards before C23'
H8E280A51EBD5: '复合语句末尾的标签与 C23 之前的 C 标准不兼容'
# 'label at end of compound statement is incompatible with C++ standards before C++23'
H1F208E16CB25: '复合语句末尾的标签与 C++23 之前的 C++ 标准不兼容'
# 'label followed by a declaration is a C23 extension'
HE476C0C2BE2F: '后跟声明的标签是 C23 扩展'
# 'label followed by a declaration is incompatible with C standards before C23'
H8299673D895A: '后跟声明的标签与 C23 之前的 C 标准不兼容'
# 'lambda %0 is inaccessible due to ambiguity:%1'
H165915C96E61: 'Lambda %0 因歧义而不可访问:%1'
# 'lambda call operator should not be explicitly specialized or instantiated'
H3541695AB458: 'lambda调用运算符不应显式特化或实例化'
# 'lambda cannot be both mutable and static'
H057D935E257D: 'lambda不能同时是mutable和static'
# 'lambda cannot be declared %0'
H523BA4919111: 'lambda不能被声明为%0'
# 'lambda capture %0 is not %select{used|required to be captured for this use}1'
HED12D4324492: 'lambda捕获%0未被%select{使用|为此用途要求捕获}1'
# 'lambda closure types are non-literal types before C++17'
H3BDD817E383F: '在C++17之前lambda闭包类型是非字面类型'
# 'lambda expression begins here'
H0582B6A6C9FD: 'lambda表达式始于此处'
# 'lambda expression in an unevaluated operand'
H2B5A38CCEDAB: '未求值的操作数中的lambda表达式'
# 'lambda expression in default argument cannot capture any entity'
H31423DFF8FC2: 'lambda表达式在默认参数中不能捕获任何实体'
# 'lambda expressions are incompatible with C++98'
HAE0AFEA72154: 'lambda表达式与C++98不兼容'
# 'lambda template parameter list cannot be empty'
H33C909CD1D80: 'lambda模板参数列表不能为空'
# 'lambda without a parameter clause is a C++23 extension'
HD70498A5F3EC: '无参数子句的lambda是C++23扩展'
# 'lambdas are a %select{C++11|clang HLSL}0 extension'
HD58884723190: 'lambda是%select{C++11|clang HLSL}0扩展'
# "language not recognized: '%0'"
H102C1DB9CB0E: "未识别的语言: '%0'"
# 'large atomic operation may incur significant performance penalty; the access size (%0 bytes) exceeds the max lock-free size (%1 bytes)'
H31655F77BD73: '大原子操作可能导致显著性能损失；访问大小（%0字节）超过最大无锁大小（%1字节）'
# 'left hand operand of type %0 to compound assignment cannot be truncated when used with right hand operand of type %1'
H00D9FE7F4F87: '类型为%0的左操作数在与类型%1的右操作数复合赋值时不能被截断'
# 'left hand operand to %0 must be a %select{|pointer to }1class compatible with the right hand operand, but is %2'
HE8A81161D486: '复合赋值运算符%0的左操作数必须与右操作数兼容的%select{|指向}1类类型，但实际类型为%2'
# "left hand side of assignment operation('%0') must match one side of the sub-operation on the right hand side('%1' and '%2')"
HA99FEEFA45D5: '赋值运算的左侧（‘%0’）必须与右侧的子运算（‘%1’和‘%2’）的一侧匹配'
# 'left operand of comma operator has no effect'
H1D36CC5E4D5A: '逗号运算符的左操作数无效果'
# 'left shift of negative value %0'
HF788BD55C118: '对负值%0进行左移操作'
# "length modifier '%0' results in undefined behavior or no effect with '%1' conversion specifier"
HDCB24BE7C9E8: "长度修饰符'%0'与'%1'转换说明符组合会导致未定义行为或无效果"
# 'line marker directive requires a positive integer argument'
H8A0833C758AF: '行标记指令需要一个正整数参数'
# 'line splicing in Doxygen comments are not supported'
HD6510289D84D: 'Doxygen注释中的行拼接不受支持'
# "linking module '%0': %1"
H78786E2D2737: "链接模块'%0'时发生错误：%1"
# 'list item of type %0 is not valid for specified reduction operation: unable to provide default initialization value'
H5FEA755CA374: '类型为%0的列表项不适合指定的约简操作：无法提供默认初始化值'
# 'literal construction method %0 has incompatible signature'
H9A98E6827407: '文字构造方法%0具有不兼容的函数签名'
# 'literal operator %0 must be in a namespace or global scope'
H6F0C93D8CF92: '文字操作符%0必须位于命名空间或全局作用域中'
# 'literal operator cannot have a default argument'
H2D253A373F0C: '文字操作符不能具有默认参数'
# 'literal operator must have C++ linkage'
HACF64718BD51: '文字操作符必须具有C++链接性'
# 'literal operator template cannot have any parameters'
HDB57FAFF64D9: '文字操作符模板不能有任何参数'
# 'literal operators are incompatible with C++98'
HC63AE1FBA425: '文字操作符与C++98不兼容'
# 'local %select{struct|interface|union|class|enum}0 cannot be declared __module_private__'
H4E0562614A60: '局部%select{结构|接口|联合|类|枚举}0不能声明为__module_private__'
# 'local declaration nearly matches'
HA030BEFE649C: '局部声明几乎匹配'
# 'local declaration of %0 hides instance variable'
H09900D49A0E3: '局部声明的%0会隐藏实例变量'
# 'local type %0 as template argument is incompatible with C++98'
H6116FD3EFF04: '将局部类型%0作为模板参数与C++98不兼容'
# "local variable '%0' should not be used in 'declare target' directive;"
HF2D2B034481C: "局部变量'%0'不应在'declare target'指令中使用;"
# "local variable cannot be declared 'constinit'"
HE35DCF249418: "局部变量不能声明为'constinit'"
# "locking '%0' to build module '%1'"
H36ABFAB03219: "锁定'%0'以构建模块'%1'"
# 'logical expression with vector %select{type %1 and non-vector type %2|types %1 and %2}0 is only supported in C++'
H1200F428FBB0: '向量%select{类型%1与非向量类型%2|类型%1和类型%2}0的逻辑表达式仅在C++中支持'
# 'logical not is only applied to the left hand side of this %select{comparison|bitwise operator}0'
H9E8ECD267F25: '逻辑非仅应用于此%select{比较运算符|位运算符}0的左操作数'
# 'lookup from the current scope refers here'
H9AFA3EAEA36F: '当前作用域的查找指向此处'
# 'lookup in the object type %0 refers here'
H3FD57FB46E2B: '在对象类型%0中的查找指向此处'
# 'lookup of %0 in member access expression is ambiguous'
H52F57D0BB44E: '成员访问表达式中的%0查找是模棱两可的'
# 'lookup of %0 in member access expression is ambiguous; using member of %1'
H632E112FD2AD: '成员访问表达式中的%0查找是模棱两可的；使用%1的成员'
# "loop iteration variable in the associated loop of 'omp %1' directive may not be %0, predetermined as %2"
H777624FA6F75: "与'omp %1'指令关联的循环迭代变量不能是%0，已被预设为%2"
# 'loop step is expected to be %select{negative|positive}0 due to this condition'
HF9B9B19EF744: '由于此条件，循环步长应为%select{负|正}0'
# 'loop to be fully unrolled must have a constant trip count'
HF58CAD452050: '要完全展开的循环必须具有常量迭代次数'
# 'loop variable %0 %diff{of type $ binds to a temporary constructed from type $|binds to a temporary constructed from a different type}1,2'
H8E540E772339: '循环变量%0 %diff{类型$绑定到由类型$构造的临时对象|绑定到由不同类型构造的临时对象}1,2'
# 'loop variable %0 binds to a temporary value produced by a range of type %1'
HDD2F7E9780FE: '循环变量%0绑定到类型%1的范围生成的临时值'
# 'loop variable %0 creates a copy from type %1'
H0EB738A6DA64: '循环变量%0从类型%1创建副本'
# "loop variable %0 may not be declared %select{'extern'|'static'|'__private_extern__'|'auto'|'register'|'constexpr'|'thread_local'}1"
HD1C2B82FE9FA: "循环变量%0不能被声明为%select{'extern'|'static'|'__private_extern__'|'auto'|'register'|'constexpr'|'thread_local'}1"
# "loop variable of loop associated with an OpenACC '%0' construct must be of integer, pointer, or random-access-iterator type (is %1)"
HDE685F11E1FA: "与OpenACC '%0'结构关联的循环变量必须是整型、指针或随机访问迭代器类型（当前为%1）"
# 'loop will run at most once (loop increment never executed)'
H41A7771F3080: '该循环最多执行一次（循环增量从未被执行）'
# "loop with a '%0' clause may not exist in the region of a '%1' clause%select{| on a '%3' construct}2"
H31D69B81DD7A: "带有'%0'子句的循环不能存在于'%1'子句%select{|的'%3'结构}2区域中"
# 'mac68k alignment pragma is not supported on this target'
H13A22B895D9E: '此目标不支持mac68k对齐#pragma'
# 'macro %0 defined here'
H224BD0DEAAD4: '宏%0在此处定义'
# 'macro %0 has been marked as deprecated%select{|: %2}1'
HB9E9BBB38434: '宏%0已被标记为已弃用%select{|: %2}1'
# 'macro %0 has been marked as final and should not be %select{undefined|redefined}1'
H416ADCAF4BDC: '宏%0已被标记为最终且不应%select{未定义|重新定义}1'
# 'macro %0 has been marked as unsafe for use in headers%select{|: %2}1'
H0BD2BA6647E5: '宏%0已被标记为在头文件中不安全%select{|: %2}1'
# "macro '%0' contains embedded newline; text after the newline is ignored"
HCA29C3134207: "宏'%0'包含嵌入的换行符；换行符后的文本将被忽略"
# "macro '%0' was %select{defined|undef'd}1 in the AST file '%2' but %select{undef'd|defined}1 on the command line"
HEF8B87D78B88: "宏'%0'在AST文件'%2'中%select{已定义|未定义}1，但在命令行中%select{未定义|已定义}1"
# "macro expansion producing 'defined' has undefined behavior"
H6CE80CBEAD13: "生成'defined'的宏展开会导致未定义行为"
# 'macro is not used'
HB7A93ECCBE4F: '该宏未被使用'
# "macro marked '%select{deprecated|restrict_expansion|final}0' here"
H36EC3D2C5C8F: "此处标记的宏为'%select{已弃用|限制展开|最终版本}0'"
# 'macro name is a reserved identifier'
H75F2505E76F7: '宏名是保留的标识符'
# 'macro name missing'
H64036DCA4179: '缺少宏名'
# 'macro name must be an identifier'
HA83E076252EC: '宏名必须是标识符'
# "macro was %select{defined|#undef'd}0 here"
H90411BE5521B: '宏在此处%select{被定义|#undef}0'
# 'magnitude of floating-point constant too large for type %0; maximum is %1'
HC45BAE211EEF: '浮点常量的大小对类型%0来说过大；最大值为%1'
# 'magnitude of floating-point constant too small for type %0; minimum is %1'
H77948F2AADFE: '浮点常量的大小对类型%0来说过小；最小值为%1'
# 'main cannot be declared as a variable %select{in the global scope|with C language linkage}0'
HDFAAFDDA66C4: 'main不能声明为变量%select{在全局作用域中|具有C语言链接性}0'
# 'main file cannot be included recursively when building a preamble'
HFA8D0D05FC55: '构建预编译头时主文件不能递归包含'
# "malformed block record in PCH file: '%0'"
H89FF1C99B4CC: "PCH文件中的块记录格式错误: '%0'"
# "malformed or corrupted AST file: '%0'"
HCB00083D669D: "AST文件格式错误或已损坏: '%0'"
# "malformed sanitizer coverage allowlist: '%0'"
HA08307F61916: "sanitizer coverage 允许列表格式错误: '%0'"
# "malformed sanitizer coverage ignorelist: '%0'"
HF4CE0A42147C: "sanitizer coverage 忽略列表格式错误: '%0'"
# "malformed sanitizer ignorelist: '%0'"
H98473149CB24: "sanitizer 忽略列表格式错误: '%0'"
# "malformed sanitizer metadata ignorelist: '%0'"
H7E49790904E8: "sanitizer 元数据忽略列表格式错误: '%0'"
# 'mangled name of %0 will change in C++17 due to non-throwing exception specification in function signature'
HC8027193700F: '由于函数签名中的非抛出异常规范，在C++17中%0的装饰名称将改变'
# "map type '%0' is previous specified here"
H3204C79CA043: '映射类型"%0"在此处之前已指定'
# 'map type is already specified'
HF4D36EA9229E: '映射类型已指定'
# "map type modifier '%0' is not allowed for '#pragma omp %1'"
H5A1E07271479: "映射类型修饰符'%0'不允许用于'#pragma omp %1'"
# 'mapper type must be of struct, union or class type'
H3D3958379C94: '映射器类型必须为结构体、联合或类类型'
# 'mapping of union members is not allowed'
HD27CBEC61BC1: '联合成员的映射是不允许的'
# "mark %0 as '%select{final|sealed}1' to silence this warning"
HF7273FC85EE1: "将%0标记为'%select{final|sealed}1'以消除此警告"
# "mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity"
H5A25A1F05320: "将'operator=='声明为const，或添加匹配的'operator!='以解决歧义"
# 'marked %0 here'
HE33E97AC0225: '此处标记的%0'
# "marked as 'declare variant' here"
H721AFFF82622: "此处标记为'declare variant'"
# "marked as 'device_type(%0)' here"
HF283C800233B: "此处标记为'device_type(%0)'"
# 'mask type size must be between 1-byte and 8-bytes'
HA5CB60FF0FBF: '掩码类型大小必须在1字节到8字节之间'
# "math errno enabled by '%0' after it was implicitly disabled by '%1', this may limit the utilization of the vector library"
HE93B3822306D: "'%0'启用的数学errno在被'%1'隐式禁用后可能限制向量库的使用效率"
# 'mathematical notation character <U+%0> in an identifier is a Clang extension'
H0378BC9B5A74: '标识符中的数学符号<U+%0>是Clang扩展'
# 'matrix %select{row|column}0 index is not an integer'
H46FD8A206DB4: '矩阵%select{行|列}0索引不是整数类型'
# 'matrix %select{row|column}0 index is outside the allowed range [0, %1)'
H847B8076D2C2: '矩阵%select{行|列}0索引超出允许范围[0, %1)'
# 'matrix row and column subscripts cannot be separated by any expression'
H5ED6E19FD5C5: '矩阵的行和列下标不能被任何表达式分隔'
# 'matrix types extension is disabled. Pass -fenable-matrix to enable it'
H4F1847B4A9E6: '矩阵类型扩展处于禁用状态。请使用-fenable-matrix启用该功能'
# 'maxclusterrank requires sm_90 or higher, CUDA arch provided: %0, ignoring %1 attribute'
H49A2942ECE44: 'maxclusterrank需要sm_90或更高架构，当前CUDA架构为%0，将忽略%1属性'
# "meaningless '%0' on asm outside function"
H7C9CC9A0FF49: "在函数外部的asm语句中使用'%0'没有意义"
# 'member %0 cannot have template arguments'
H7530E8235E69: '成员%0不能带有模板参数'
# 'member %0 declared here'
H523D63E160D3: '此处声明了成员%0'
# 'member %0 first declared here'
H53F314C373D4: '成员%0首次声明于此'
# 'member %0 found in multiple base classes of different types'
HE96F2F88498F: '成员%0在不同类型的多个基类中找到'
# 'member %0 has the same name as its class'
HBDCB2F361AEB: '成员%0与其所属类具有相同的名称'
# 'member %0 of %1 is not a template; did you mean %select{|simply }2%3?'
H88F478FC5C17: '%1的成员%0不是模板；是否应改为%select{|直接}2%3？'
# 'member %0 used before its declaration'
H21EA4914C844: '在声明之前使用了成员%0'
# 'member access into incomplete type %0'
H3F51F529F796: '尝试访问不完整类型%0的成员'
# 'member declaration does not match because it %select{is|is not}0 const qualified'
HB51C7FC5370B: '成员声明不匹配，因为其%select{是|不是}0 const限定符'
# 'member declaration nearly matches'
HA07B45D5B59A: '成员声明几乎匹配'
# 'member found by ambiguous name lookup'
H1816E255A34E: '通过模糊名称查找找到的成员'
# 'member function %0 is not needed and will not be emitted'
HC39E7B7627B2: '成员函数%0未被使用，将不会被生成'
# 'member function specialization matches %0'
HCDF99A0E6C9D: '成员函数特化与%0匹配'
# 'member initializer %0 does not name a non-static data member or base class'
H35E3E12D1C39: '成员初始化器%0未命名非静态数据成员或基类'
# 'member is declared here'
H08E5DDE7EA19: '成员在此处声明'
# "member is not a candidate because range type %0 has no '%select{end|begin}1' member"
HE822EBF784D6: '成员不是候选，因为范围类型%0没有‘%select{end|begin}1’成员'
# 'member not initialized by constructor'
H26EC51B7C7A4: '成员未由构造函数初始化'
# 'member of anonymous %select{struct|union}0 redeclares %1'
H9C0924E1182A: '匿名%select{struct|union}0的成员重新声明了%1'
# 'member pointer has incomplete base type %0'
H9CA90CC9D193: '成员指针具有不完全基类型%0'
# 'member pointer refers into non-class type %0'
H1383FFD5BAA2: '成员指针指向非类类型%0'
# 'member pointer representation requires a complete class type for %0 to perform this expression'
HA14D1B995CD2: '成员指针的表示需要%0为完整类类型才能执行此表达式'
# 'member reference base type %0 is not a structure or union'
HDDC7E94D7C4D: '成员引用的基类型%0不是结构体或联合体'
# "member reference type %0 is %select{a|not a}1 pointer; did you mean to use '%select{->|.}1'?"
HCE4396C30D63: '成员引用类型%0是%select{一个|不是}1指针；是否应使用‘%select{->|.}1’？'
# 'member reference type %0 is not a pointer'
H1067A041C0C1: '成员引用类型 %0 不是指针'
# 'member template declared %0 here'
H81FEA7456BEB: '在此处声明的成员模板 %0'
# 'member type %0 found by ambiguous name lookup'
H1BDBA1C8E5BA: '通过模糊名称查找找到的成员类型 %0'
# 'member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20'
HFDD47D4DEC61: '使用非成员枚举项的成员使用声明与 C++20 之前的 C++ 标准不兼容'
# "member using declaration naming non-class '%0' enumerator is incompatible with C++ standards before C++20"
H3AC79AC99394: "命名非类类型 '%0' 枚举项的成员使用声明与 C++20 之前的 C++ 标准不兼容"
# "memory order clause '%0' is specified here"
HEB7229373BDB: "此处指定了内存顺序子句 '%0'"
# 'messaging a Class with a method that is possibly direct'
H3E9374E93BAC: '通过可能为直接方法的类方法进行消息传递'
# 'messaging super with a direct method'
H76B5A067ADF0: '通过直接方法向 super 发送消息'
# 'messaging unqualified id'
H25CF081972C3: '未限定标识符的消息传递'
# 'messaging unqualified id with a method that is possibly direct'
H52C4ECCB3445: '通过可能为直接方法的未限定标识符进行消息传递'
# 'method %0 declared here'
H0A29C282008D: '在此处声明的方法 %0'
# 'method %0 in protocol %1 not implemented'
H3B6F9A4CA03E: '协议 %1 中的方法 %0 未实现'
# 'method %0 is used for the forward class'
H9C1FB20B5554: '方法 %0 被用于前向类声明'
# 'method %0 that returns %1 declared here'
H81FA72B87C9D: '在此处声明返回 %1 的方法 %0'
# 'method definition for %0 not found'
H2A6463515852: '未找到 %0 方法的实现定义'
# 'method for accessing %select{dictionary|array}1 element must have Objective-C object return type instead of %0'
H2A6E5DD7828B: '访问 %select{字典|数组}1 元素的访问方法必须返回 Objective-C 对象类型而非 %0'
# "method has no return type specified; defaults to 'id'"
HD11D99B1C083: '方法未指定返回类型；默认返回类型为 `id`'
# 'method implementation does not match its declaration'
H2D5D386F5AFB: '方法实现与声明不匹配'
# 'method index parameter type %0 is not integral type'
H630B60C086B7: '方法索引参数类型 %0 不是整数类型'
# 'method is expected to return an instance of its class type %diff{$, but is declared to return $|, but is declared to return different type}0,1'
H4EBF90DD6088: '方法预期返回其类类型 %diff{$ 的实例，但声明返回类型为 $|，但声明返回不同类型}0,1'
# 'method key parameter type %0 is not object type'
H93D8788321DF: '方法键参数类型%0不是对象类型'
# 'method marked as designated initializer of the class here'
H6D873EC57BBB: '此处标记为类的指定初始化器的方法'
# "method name referenced in property setter attribute must end with ':'"
H48FC25BCA089: '在属性设置器属性中引用的方法名称必须以":"结尾'
# 'method object parameter type %0 is not object type'
H7C5EC09F4D4E: '方法对象参数类型%0不是对象类型'
# 'method override for the designated initializer of the superclass %objcinstance0 not found'
H353D09FC8C8A: '未找到超类%objcinstance0的指定初始化器方法覆盖'
# 'method parameter of type %0 with no explicit ownership'
H012CAADA6E5A: '类型%0且没有显式所有权的方法参数'
# 'method parameter type %diff{$ does not match super class method parameter type $|does not match super class method parameter type}0,1'
H52F29D4B5323: '与超类方法参数类型%diff{$ does not match super class method parameter type $|does not match super class method parameter type}0,1不匹配'
# 'method possibly missing a [super %0] call'
HF2DE0E720AA4: '方法可能缺少对[super %0]的调用'
# 'method returns unexpected type %0 (should be an object type)'
HDA228B7E04A3: '方法返回意外类型%0（应为对象类型）'
# "method type specifier must start with '-' or '+'"
H60683402DB43: '方法类型说明符必须以"-"或"+"开头'
# "method was declared as %select{an 'alloc'|a 'copy'|an 'init'|a 'new'}0 method, but its implementation doesn't match because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1"
H0332DF98668A: '该方法被声明为%select{一个"alloc"|一个"copy"|一个"init"|一个"new"}0方法，但其实现不匹配，因为%select{其结果类型不是对象指针|其结果类型与其接收器类型无关}1'
# 'methods that %select{override superclass methods|implement protocol requirements}0 cannot be direct'
H10E1F7CDD559: '%select{覆盖超类方法|实现协议要求}0的方法不能是直接的'
# "micromips is not supported for target CPU '%0'"
H17AAF1CF7567: '目标CPU "%0"不支持micromips'
# 'minimum vscale must be an unsigned integer greater than 0'
H97D216C9F9DC: '最小vscale必须是大于0的无符号整数'
# 'minus(-) operator for reductions is deprecated; use + or user defined reduction instead'
HB503599C3686: '归约操作的减法(-)运算符已弃用；请改用+或用户定义的归约'
# 'misaligned atomic operation may incur significant performance penalty; the expected alignment (%0 bytes) exceeds the actual alignment (%1 bytes)'
HB642C05FEFCE: '对齐错误的原子操作可能导致显著的性能损失；预期对齐(%0字节)超过实际对齐(%1字节)'
# "misleading indentation; statement is not part of the previous '%select{if|else|for|while}0'"
H2D720E07A9B5: '误导性的缩进；该语句不属于前面的"%select{if|else|for|while}0"'
# "mismatch between architecture and environment in target triple '%0'; did you mean '%1'?"
HFB1C45E0F3D8: '目标三元组"%0"中的架构和环境不匹配；您是指"%1"吗？'
# 'mismatch in number of block parameters and local size arguments passed'
H297CC009BE30: '传递的块参数数量与本地大小参数数量不匹配'
# 'misplaced %0; expected %0 here'
H6EEF8ABBCBBD: '"%0"位置错误；此处应使用%0'
# 'misplaced attributes; expected attributes here'
H71DF23AD8094: '位置不当的属性；此处应放置属性'
# 'missing %1 after %0'
H71A0939C10D8: '在%0之后缺少%1'
# "missing '(' after '#pragma %0' - ignoring"
H9BCF4D2D832C: "在#pragma %0后缺少'(' - 忽略"
# "missing '(' following __VA_OPT__"
HFEF64C94E397: "__VA_OPT__后缺少'('"
# "missing ')' after '#pragma %0' - ignoring"
HD628B31A25D9: "在#pragma %0后缺少')' - 忽略"
# "missing ')' in macro parameter list"
HBA1269832ABB: "宏参数列表中缺少')'"
# "missing '*' in type bound %0 for type parameter %1"
H0FC1C4510683: "在类型参数%1的类型边界%0中缺少'*'"
# "missing ',' after %0"
H36D833E1BE2F: "在%0之后缺少','"
# "missing ',' between base or member initializers"
HC0E2DA10BD59: "基类或成员初始化器之间的初始化器缺少','"
# "missing ',' between enumerators"
H3BCFAD409136: "枚举项之间缺少','"
# "missing ':' after %0 - ignoring"
H6D49C0F56471: "在%0之后缺少':' - 忽略"
# "missing ':' after %0 modifier"
H1C42316D6361: "在%0修饰符之后缺少':'"
# "missing ':' in %0"
HB39748BAFE7C: "在%0中缺少':'"
# "missing ':' or ')' after %0 - ignoring"
HA24B4C500D05: "在%0之后缺少':'或')' - 忽略"
# "missing '@end'"
H91CC5F3C7087: '缺少@end'
# "missing '[' at start of message send expression"
H352486DC1A63: "消息发送表达式开头缺少'['"
# "missing 'export module' declaration in module interface unit"
H43BE56C41167: "在模块接口单元中缺少'export module'声明"
# "missing 'export' specifier in module declaration while building module interface"
H73E9D7F0EE4B: "构建模块接口时，在模块声明中缺少'export'指定符"
# "missing 'get=' or 'put='"
H5BBBF3CA84C4: "缺少'get='或'put='"
# "missing 'module' declaration at end of global module fragment introduced here"
HECF75AD1494B: "在此处引入的全局模块片段结尾缺少'module'声明"
# "missing 'template' keyword prior to dependent template name %0"
H6110BBE085CA: "缺少依赖模板名称%0之前的'template'关键字"
# "missing 'typename' prior to dependent type name %0"
H1584997CE5DB: "缺少依赖类型名称%0之前的'typename'"
# "missing 'typename' prior to dependent type name %0; implicit 'typename' is a C++20 extension"
H15976F1154C9: "缺少依赖类型名称%0之前的'typename'；隐式'typename'是C++20扩展"
# "missing 'typename' prior to dependent type template name %0"
HB65342C255DD: "缺少依赖类型模板名称%0之前的'typename'"
# "missing '}' at end of definition of %q0"
HAF73F9C8E8E7: "在%q0定义末尾缺少'}'"
# 'missing actual type specifier for pipe'
H369BCA42F29A: '管道缺少实际类型说明符'
# "missing argument to '#pragma %0'%select{|; expected %2}1"
H85D43DEA45AB: "缺少'#pragma %0'的参数%select{|; 预期%2}1"
# "missing argument to '%0'"
H52AC6CD34BC9: "缺少'%0'的参数"
# "missing argument to debug command '%0'"
H68E5FEB79890: "调试命令'%0'缺少参数"
# "missing argument; expected %select{an integer value|'enable'%select{|, 'full'}1%select{|, 'assume_safety'}2 or 'disable'}0"
H6DC6E5CF70F4: "缺少参数；预期%select{一个整数值|'enable'%select{|, 'full'}1%select{|, 'assume_safety'}2或'disable'}0"
# 'missing context for method declaration'
HDB791FF5D00C: '方法声明缺少上下文'
# 'missing context for property implementation declaration'
HB2B46E5EAE97: '属性实现声明缺少上下文'
# 'missing custom discrimination'
H8E91DD601C8B: '缺少自定义判别式'
# 'missing debug command'
HC4112B242494: '缺少调试命令'
# 'missing default argument on parameter'
H8EC917CC5F93: '参数缺少默认参数'
# 'missing default argument on parameter %0'
H8F4C6F0521D4: '参数%0缺少默认参数'
# 'missing field %0 initializer'
HBCFF05CA88FD: '缺少字段%0初始化器'
# 'missing map type'
H4AA13FCA7666: '缺少映射类型'
# 'missing map type modifier'
H60251948404E: '缺少映射类型修饰符'
# 'missing numthreads attribute for %0 shader entry'
HFADE160C1BC1: "'%0'着色器入口缺少numthreads属性"
# 'missing object format flag'
HD57D82290D05: '缺少对象格式标志'
# "missing or invalid line number following '@' in expected %0"
H296CBDA95848: "在预期的%0中，'@'后面的行号缺失或无效"
# 'missing parentheses around the size of parameter pack %0'
HA558CBB9F294: '参数包%0的大小周围缺少括号'
# 'missing plugin argument for plugin %0 in %1'
H8600AE8C89F9: '在%1中，插件%0缺少插件参数'
# 'missing plugin name in %0'
H4A2F8D6C22D3: '在%0中缺少插件名称'
# "missing reduction operator, expected '+', '*', 'max', 'min', '&', '|', '^', '&&', or '||', follwed by a ':'"
H9DF20C9098D2: "缺少规约运算符，预期为 '+', '*', 'max', 'min', '&', '|', '^', '&&' 或 '||'，后跟 ':'"
# 'missing return type for function %0; did you mean the constructor name %1?'
H0096A8359309: '函数%0缺少返回类型；您是否指的是构造函数名称%1？'
# "missing sanitizer ignorelist: '%0'"
HE7971DD1E969: "缺少 sanitizer 忽略列表：'%0'"
# 'missing sentinel in %select{function call|method dispatch|block call}0'
H10D39CEB9167: '在%select{函数调用|方法分派|块调用}0中缺少哨兵值'
# 'missing state for %0'
HCF224168FF82: '%0缺少状态'
# "missing submodule '%0'"
H4FF2783EAA28: "缺少子模块 '%0'"
# 'missing symbol graph output directory, defaulting to working directory'
H1ACFD82E27C5: '缺少符号图输出目录，将默认使用当前工作目录'
# 'missing terminating %select{\'|\'"\'}0 character'
HC91AE5B6C664: '缺少终止字符%select{‘|’"’}0'
# "missing terminating ')' character"
H110B9B84BD50: "缺少终止的 ')' 字符"
# 'missing type bound %0 for type parameter %1 in %select{@interface|@class}2'
HCB937BA83DD0: '在%select{@interface|@class}2中的类型参数%1缺少类型边界%0'
# 'mixed CUDA and HIP compilation is not supported'
HDE7D3706C5B5: '混合 CUDA 和 HIP 编译不受支持'
# "mixing 'target_clones' specifier mechanisms is permitted for GCC compatibility; use a comma separated sequence of string literals, or a string literal containing a comma-separated list of versions"
H65625B3622E8: "为了兼容 GCC，允许混合使用 'target_clones' 规格说明机制；请使用逗号分隔的字符串字面量序列，或包含版本逗号分隔列表的字符串字面量"
# 'mixing declarations and code is a C99 extension'
H509E36ADC1D7: '混合声明和代码是 C99 的扩展'
# 'mixing declarations and code is incompatible with standards before C99'
HD580E194E35D: '混合声明和代码与 C99 之前的版本标准不兼容'
# 'mixture of designated and non-designated initializers in the same initializer list is a C99 extension'
H29C32AE72D18: '在同一个初始化程序列表中混合使用指定和未指定的初始化器是 C99 的扩展'
# 'mode %0 is not supported for enumeration types'
H9D1986A84BDA: '模式%0不支持枚举类型'
# 'mode attribute only supported for integer and floating-point types'
H759A20BD1268: 'mode属性仅支持整型和浮点类型'
# 'modification of object of const-qualified type %0 is not allowed in a constant expression'
H403821CE466D: '对const限定类型%0的对象进行修改在常量表达式中不允许'
# "modifier '%0' cannot be used along with modifier '%1'"
HDE467CEB2037: "修饰符'%0'不能与修饰符'%1'一起使用"
# 'modifying constructor parameter %0 that shadows a field of %1'
H1430708B59D6: '修改构造函数参数%0，该参数覆盖了%1的字段'
# "module %0 does not depend on a module exporting '%1'"
H85DEF90A3AE0: '模块%0不依赖于导出"%1"的模块'
# "module %0 does not directly depend on a module exporting '%1', which is part of indirectly-used module %2"
H9D50309367F5: '模块%0不直接依赖于导出"%1"的模块，而该模块属于间接使用的模块%2'
# "module '%0' %select{in|imported by}4 AST file '%1' found in a different module map file (%2) than when the importing AST file was built (%3)"
H7F407C161851: "模块'%0' %select{在|被导入的}4AST文件'%1'发现于不同的模块映射文件(%2)，而导入AST文件构建时使用的是(%3)"
# "module '%0' %select{is incompatible with|requires}1 feature '%2'"
H4440A0170E90: "模块'%0' %select{与...不兼容|需要}1特性'%2'"
# "module '%0' %select{uses|does not use}1 additional module map '%2'%select{| not}1 used when the module was built"
HAC53C3FABCDA: "模块'%0' %select{使用|未使用}1附加模块映射'%2'%select{|未}1在模块构建时使用"
# "module '%0' already re-exported as '%1'"
H6556B7A46703: "模块'%0'已作为'%1'重新导出"
# "module '%0' conflicts with already-imported module '%1': %2"
HED958876B86C: "模块'%0'与已导入的模块'%1'冲突：%2"
# "module '%0' in AST file '%1' %select{(imported by AST file '%2') |}4is not defined in any loaded module map file; maybe you need to load '%3'?"
H951252F32734: "AST文件'%1'中的模块'%0' %select{(被AST文件'%2'导入)|}4未在任何已加载的模块映射文件中定义；是否需要加载'%3'？"
# "module '%0' is defined in both '%1' and '%2'"
H9937FAC6E395: "模块'%0'在'%1'和'%2'中均有定义"
# "module '%0' is needed but has not been provided, and implicit use of module files is disabled"
H8C7DAF453831: "需要模块'%0'但未提供，并且模块文件的隐式使用已禁用"
# "module '%0' not found"
H55DF0ED78DC5: "未找到模块'%0'"
# "module '%0' was built in directory '%1' but now resides in directory '%2'"
H38AD29640B23: "模块'%0'是在目录'%1'构建的，但现在位于目录'%2'"
# "module compilation requires '-fmodules'"
H6A96D77D9F41: "模块编译需要'-fmodules'选项"
# 'module declaration can only appear at the top level'
HB03E6C215813: '模块声明只能出现在顶层'
# 'module declaration must occur at the start of the translation unit'
HA7783A63FE0B: '模块声明必须出现在翻译单元的开头'
# 'module defined here'
HDB50FF2BF5A8: '模块在此处定义'
# 'module file %0 cannot be loaded due to a configuration mismatch with the current compilation'
H469015AF9879: '模块文件 %0 由于与当前编译的配置不匹配而无法加载'
# "module file '%0' is missing its top-level submodule"
HFA537775278A: "模块文件 '%0' 缺少其顶层子模块"
# "module file '%0' was validated as a system module and is now being imported as a non-system module; any difference in diagnostic options will be ignored"
H13B637DDA3AA: "模块文件 '%0' 已被验证为系统模块，现在将作为非系统模块导入；任何诊断选项的差异将被忽略"
# "module header file '%0' not found"
HDA48886085ED: "模块头文件 '%0' 未找到"
# 'module imported here'
HA3A8055B303E: '模块在此处导入'
# "module interface compilation requires '-std=c++20'"
HA34462B55274: "模块接口编译需要 '-std=c++20'"
# "module loaded from '%0'"
H07E2BBCF1C1E: "模块加载自 '%0'"
# "module map file '%0' not found"
HD693305F9871: "模块映射文件 '%0' 未找到"
# "module name '%0' specified on command line does not match name of module"
H0F48D36629AC: "命令行上指定的模块名称 '%0' 与当前模块名称不匹配"
# 'module partition implementations cannot be exported'
HFE1B8CB7B1E9: '模块分区实现不能被导出'
# 'module partition imports must be within a module purview'
H99C430D138F5: '模块分区导入必须位于模块作用域内'
# 'module partitions are only supported for C++20 onwards'
HB98F31FF7B9A: '模块分区仅支持 C++20 及更高版本'
# 'module%select{| partition}0 imports cannot be in the %select{global|private}1 module fragment'
HE6F2588D0369: '模块%select{|分区}0 导入不能位于 %select{全局|私有}1 模块片段中'
# "more '%%' conversions than data arguments"
H9766AC9D490A: "存在多于数据参数的 '%%' 转换"
# "more than one 'device_type' clause is specified"
H018E0AE39152: "指定了多个 'device_type' 子句"
# "more than one for-loop in a loop associated with OpenACC '%0' construct with a '%1' clause"
H30D49A113B6A: "与带有 '%1' 子句的 OpenACC '%0' 构造关联的循环中存在多个 for 循环"
# 'more than one framework/dynamic library found'
H611E8232270A: '找到多个框架/动态库'
# "more than one input constraint matches the same output '%0'"
H4D494A49ED15: "多个输入约束匹配相同的输出 '%0'"
# 'moving a local object in a return statement prevents copy elision'
H928AEBBA3589: '在返回语句中移动局部对象会阻止拷贝省略'
# 'moving a temporary object prevents copy elision'
H7FCDBDAE9C59: '移动临时对象会阻止复制省略'
# 'ms_struct may not produce Microsoft-compatible layouts for classes with base classes or virtual functions'
H0D36DB1654BA: 'ms_struct 可能无法为具有基类或虚函数的类生成与 Microsoft 兼容的布局'
# "ms_struct may not produce Microsoft-compatible layouts with fundamental data types with sizes that aren't a power of two"
H9013C05CB59B: 'ms_struct 可能无法为基本数据类型（其大小不是2的幂次）生成与 Microsoft 兼容的布局'
# 'multi-character character constant'
H8914BC0B6E30: '多字符字符常量'
# 'multi-dimensional arrays of WebAssembly references are not allowed'
HDC4921C402A6: '不允许使用 WebAssembly 引用的多维数组'
# 'multi-line // comment'
HC0A7D2EE8599: '多行 // 注释'
# 'multilib configuration error: %0'
H51BCFF1832A0: '多目标配置错误：%0'
# "multiple %0 architectures are detected: %1; only the first one is used for '%2'"
HF49114F051BF: "检测到多个 %0 架构： %1；仅使用第一个架构用于 '%2'"
# "multiple %select{'step size'|'linear modifier'}0 found in linear clause"
H6C58F45C9F56: "在线性子句中发现了多个 %select{'步长大小'|'线性修饰符'}0"
# "multiple 'callback' attributes specified"
H9EF4CEF4A9C0: "指定了多个 'callback' 属性"
# "multiple 'cpu_specific' functions cannot specify the same CPU: %0"
H3B8B7713681E: "指定相同 CPU 的多个 'cpu_specific' 函数不允许： %0"
# "multiple 'lifetime_capture' attributes specified"
H42096CECC49E: "指定了多个 'lifetime_capture' 属性"
# "multiple 'routine' directives with 'bind' clauses are not permitted to refer to the same function"
HDA1D710FAA21: "'bind' 子句的多个 'routine' 指令不允许指向同一函数"
# 'multiple access qualifiers'
HA0304D566382: '多个访问限定符'
# 'multiple address spaces specified for type'
H4075C38BB93B: '为类型指定了多个地址空间'
# 'multiple array elements associated with the same variable are not allowed in map clauses of the same construct'
H289BE95E22C4: '同一构造中的 map 子句不允许将同一变量关联到多个数组元素'
# 'multiple conversions from expression type %0 to an integral type'
H80B8D963ECA1: '表达式类型 %0 到整型的多个转换'
# 'multiple conversions from switch condition type %0 to an integral or enumeration type'
H23301D5B9A53: 'switch 条件类型 %0 到整型或枚举类型的多个转换'
# 'multiple declarations of method %0 found and ignored'
HA50D97FB9EC5: '找到并忽略方法 %0 的多个声明'
# 'multiple default labels in one switch'
H1F979F2765D2: '一个 switch 中有多个默认标签'
# 'multiple definitions are found for the same key in index '
HBED55B0B868B: '索引中为同一个键发现了多个定义'
# 'multiple ellipses in pack capture'
H2EAABC9D1825: '参数包捕获中包含多个省略号'
# 'multiple garbage collection attributes specified for type'
H8DF299790474: '为类型指定了多个垃圾回收属性'
# 'multiple identical address spaces specified for type'
H2A39AD934787: '为类型指定了多个相同的地址空间'
# 'multiple initializations given for base %0'
H6C502C93AC06: '为基类 %0 提供了多次初始化'
# 'multiple initializations given for non-static member %0'
HF2A12907FBDA: '为非静态成员 %0 提供了多次初始化'
# "multiple inputs are not valid for header units (first extra '%0')"
H85058EEFACAE: "存在多个无效的头单元输入（第一个额外输入 '%0')"
# 'multiple methods named %0 found'
H170992E437FC: '找到多个名为 %0 的方法'
# 'multiple methods named %0 found with mismatched result, parameter type or attributes'
HB7ACC94E443E: '找到多个名为 %0 的方法，其返回类型、参数类型或属性不匹配'
# 'multiple overloads of %0 instantiate to the same signature %1'
H3B92DD0A02C5: '重载的 %0 实例化为相同的签名 %1'
# 'multiple packs in structured binding declaration'
HFE5E55E2957C: '结构化绑定声明中包含多个参数包'
# 'multiple return statements in constexpr function is a C++14 extension'
H4582B1A35055: 'constexpr 函数中包含多个 return 语句是 C++14 扩展'
# 'multiple return statements in constexpr function is incompatible with C++ standards before C++14'
H4061EC95BBA4: 'constexpr 函数中包含多个 return 语句与 C++14 之前的版本标准不兼容'
# "multiple suitable %0 functions for %1; no 'operator delete' function will be invoked if initialization throws an exception"
HB304821CF54E: "为 %1 存在多个合适的 %0 函数；若初始化时抛出异常则不会调用 'operator delete' 函数"
# 'multiple suitable %0 functions in %1'
H04588097A2D5: '在 %1 中存在多个合适的 %0 函数'
# 'multiple unsequenced modifications to %0'
HBE9DFDF729B3: '对 %0 进行了多次无序列化的修改'
# 'multiple vtable pointer authentication policies on %0'
H64E76C32EB13: '%0 上指定了多个 vtable 指针认证策略'
# 'multiversioned function declaration has a different %select{calling convention|return type|constexpr specification|inline specification|linkage|language linkage}0'
H037AEBCE675B: '多版本函数声明的 %select{调用约定|返回类型|constexpr 标识|内联标识|链接性|语言链接性}0 不一致'
# 'multiversioned function must have a prototype'
HC2FE50BE244F: '多版本函数必须具有原型声明'
# 'multiversioned function redeclarations require identical target attributes'
H21088B0A235D: '多版本函数的重新声明需要具有相同的 target 属性'
# 'multiversioning attributes cannot be combined'
HB5E9464B0FCA: '多版本化属性不能组合使用'
# "must be declared with 'noexcept'"
H987DB13AD301: "必须用'noexcept'声明"
# 'must explicitly describe intended ownership of an object array parameter'
H94C16C029EFB: '必须明确描述对象数组参数的预期所有权'
# 'must explicitly qualify name of member function when taking its address'
H10EC7DC2756E: '在获取成员函数地址时必须显式限定其名称'
# "must handle potential future platforms with '*'"
H52CBF98EE88A: '必须处理未来平台中可能的"*"'
# 'must name member using the type of the current context %0'
H0A063C055ADE: '必须使用当前上下文%0的类型命名该成员'
# "must pass in an explicit %0 gpu architecture to '%1'"
H748BF240D8AC: "必须向'%1'显式传递%0 GPU架构"
# "must provide a symbol graph output directory using '--symbol-graph-dir=<directory>'"
H7FEC01DD8141: "必须使用'--symbol-graph-dir=<目录>'指定符号图输出目录"
# 'must qualify identifier to find this declaration in dependent base class'
HB8E730405435: '必须限定标识符才能在依赖基类中查找此声明'
# "must specify '-fmodule-name=%0' to enter %select{|submodule of }1this module%select{ (current module is %3)|}2"
HF0DE733FAF70: "必须指定'-fmodule-name=%0'以进入%select{|该模块的子模块}1此模块%select{（当前模块为%3）|}2"
# 'must specify system root with -isysroot when building a relocatable PCH file'
H530DD8BE4BB8: '构建可重定位的PCH文件时必须使用-isysroot指定系统根目录'
# "must use '%1' tag to refer to type %0%select{| in this scope}2"
H25B19F90B2A8: "必须使用'%1'标签引用类型%0%select{|在此作用域内}2"
# 'name defined in alias declaration must be an identifier'
HF20E175DA10B: '别名声明中定义的名称必须是标识符'
# 'name defined in concept definition must be an identifier'
H9F376A6B25D8: '概念定义中定义的名称必须是标识符'
# 'named bit-field %0 has zero width'
HB27FCD740169: '命名的位段%0宽度为零'
# 'named variadic macros are a GNU extension'
H4A2738C3ADE2: '命名的可变参数宏是GNU扩展'
# 'namespace %0 defined here'
H6C2973533802: '命名空间%0在此处定义'
# 'namespace alias cannot be inline'
H69290D9B2469: '命名空间别名不能是内联的'
# 'namespace alias must be a single identifier'
HA11E2A62D886: '命名空间别名必须是一个标识符'
# "namespace can only apply to 'push' or 'pop' directives"
H6F30E709453F: '命名空间只能应用于"push"或"pop"指令'
# 'namespaces can only be defined in global or namespace scope'
HDB4E6C24AE7F: '命名空间只能在全局或命名空间作用域中定义'
# "negated attribute subject matcher sub-rule '%0' contradicts sub-rule '%1'"
H92B926B255DE: "否定的属性主题匹配子规则 '%0' 与子规则 '%1' 矛盾"
# 'negative shift count %0'
HC6E4102E7BA3: '负的移位次数 %0'
# "nested OpenMP context selector contains duplicated trait '%0' in selector '%1' and set '%2' with different score"
HC583359DCCE0: '嵌套的OpenMP上下文选择器在选择器 "%1" 和集合 "%2" 中包含重复的特征 "%0"，且评分不同'
# 'nested designators are a C99 extension'
H97E72072881F: '嵌套的设计说明符是C99扩展'
# 'nested name specifier %0 for declaration does not refer into a class, class template or class template partial specialization'
H326DE285E8C5: '声明的嵌套名称说明符 %0 不指向类、类模板或类模板的部分特化'
# 'nested name specifier for a declaration cannot depend on a template parameter'
H87A0C3C18BC3: '声明的嵌套名称说明符不能依赖于模板参数'
# "nested namespace definition cannot be 'inline'"
HB262A63F161A: '嵌套的命名空间定义不能是"inline"'
# 'nested namespace definition is a C++17 extension; define each namespace separately'
HEFB4B9AD8E01: '嵌套的命名空间定义是C++17扩展；请分别定义每个命名空间'
# 'nested namespace definition is incompatible with C++ standards before C++17'
H0E35039F1D67: '嵌套的命名空间定义与C++17之前的C++标准不兼容'
# 'nested parentheses not permitted in %0'
H34953581058C: '在%0中不允许嵌套的括号'
# 'nested redefinition of %0'
H0AC10F45C385: '%0的嵌套重新定义'
# 'nested teams construct here'
HF6BEE2475F61: '此处的嵌套teams构造'
# 'nested user conditions in OpenMP context selector not supported (yet)'
H4C0B107BB3D4: 'OpenMP上下文选择器中的嵌套用户条件尚未被支持'
# 'new expression for type %0 contains multiple constructor arguments'
H0D34CDEC5737: '类型%0的new表达式包含多个构造函数参数'
# 'new expression for type %0 has incompatible constructor argument of type %1'
H8E7FF8B53FFB: '类型%0的new表达式具有类型%1的不兼容构造函数参数'
# 'new expression for type %0 requires a constructor argument'
H55FA18FEEE0E: '类型%0的new表达式需要构造函数参数'
# 'next %select{instance variable declaration|synthesized instance variable}0 is here'
H6502100189C0: '下一个%select{实例变量声明|合成的实例变量}0在此处'
# 'next field declaration is here'
H589A37214DA3: '下一个字段声明在此处'
# 'no %select{getter|setter}0 defined for property %1'
HDA010EA6C052: '属性%1未定义%select{getter|setter}0'
# 'no %select{struct|interface|union|class|enum}0 named %1 in %2'
HCA856DA687CE: '在%2中没有名为%1的%select{struct|interface|union|class|enum}0'
# "no 'assign', 'retain', or 'copy' attribute is specified - 'assign' is assumed"
H5D9A45CF4470: "未指定'assign'、'retain'或'copy'属性，默认使用'assign'"
# 'no @interface declaration found in class messaging of %0'
H39108401F4F8: '在%0的类消息中未找到@interface声明'
# "no MCU device specified, but '-mhwmult' is set to 'auto', assuming no hardware multiply; use '-mmcu' to specify an MSP430 device, or '-mhwmult' to set the hardware multiply type explicitly"
HF3E9B95BB7DD: "未指定MCU设备，但'-mhwmult'设置为'auto'，假设没有硬件乘法；使用'-mmcu'指定MSP430设备，或使用'-mhwmult'显式设置硬件乘法类型"
# "no analyzer checkers or packages are associated with '%0'"
H8B728EEF35B9: "没有与'%0'关联的分析检查器或包"
# 'no avr-libc installation can be found on the system, cannot link standard libraries'
H5206EA6489A5: '系统中未找到avr-libc安装，无法链接标准库'
# 'no candidate function template was found for dependent %select{member|friend}0 function template specialization'
HC620314BA8FA: '未找到与相关%select{member|friend}0函数模板特化对应的候选函数模板'
# "no case matching constant switch condition '%0'"
HBFE1788B232F: "没有与常量switch条件'%0'匹配的case"
# "no closing ']' for '%%[' in scanf format string"
H5E8D81CB9C26: "scanf格式字符串中的'%%['缺少闭合的']'"
# 'no corresponding base class here'
HBBF529A4447F: '此处没有对应的基类'
# 'no corresponding enumerator here'
HCF6777617E14: '此处没有对应的枚举项'
# 'no corresponding field here'
H8BC5689EEC5A: '此处没有对应的字段'
# 'no corresponding friend here'
H0544B78403CC: '此处没有对应的friend'
# 'no corresponding superclass here'
HE11938993661: '此处没有对应的超类'
# "no declaration found for exported symbol '%0' in dynamic library"
H247D438751B2: "在动态库中未找到导出符号'%0'的声明"
# "no declaration was found for exported symbol '%0' in dynamic library"
H01E907352618: "在动态库中未找到导出符号'%0'的声明"
# "no expected directives found: consider use of '%0-no-diagnostics'"
H60C61DB5DCD2: "未找到预期的指令：考虑使用'%0-no-diagnostics'"
# 'no function template matches function template specialization %0'
H783C344DF4FC: '没有函数模板与函数模板特化%0匹配'
# 'no getter method %1 for %select{increment|decrement}0 of property'
H27A03BEFDE9D: '属性的%select{increment|decrement}0操作没有对应的getter方法%1'
# 'no getter method for read from property'
HC653B7766A2E: '读取属性时没有对应的getter方法'
# "no handler registered for module format '%0'"
H54F9399D659E: "未注册处理模块格式 '%0' 的处理器"
# 'no input files'
HFFB86B2450DC: '没有输入文件'
# 'no install name specified: add -install_name <path>'
H183DF472D6DF: '未指定安装名：添加 -install_name <路径>'
# 'no known %select{instance|class}1 method for selector %0'
H41C44394DC27: '未找到选择器 %0 的已知 %select{实例|类}1 方法'
# "no known method %select{%objcinstance1|%objcclass1}0; cast the message send to the method's return type"
HD141497E30B9: '未找到已知方法 %select{%objcinstance1|%objcclass1}0；请将消息发送转换为目标方法返回类型'
# "no library '%0' found in the default clang lib directory or in LIBRARY_PATH; use '--libomptarget-%1-bc-path' to specify %1 bitcode library"
H56082C491F7D: "在默认clang库目录或LIBRARY_PATH中未找到库 '%0'；使用'--libomptarget-%1-bc-path'指定%1位码库"
# 'no macro named %0'
HDBF2015FF73B: '没有名为 %0 的宏'
# 'no matching %0 function for non-allocating placement new expression; include <new>'
H7020E0B0AF12: '非分配式placement new表达式没有匹配的 %0 函数；包含 <new>'
# "no matching '#pragma clang module begin' for this '#pragma clang module end'"
HCC39D351076F: "没有与此 '#pragma clang module end' 对应的 '#pragma clang module begin'"
# "no matching '#pragma clang module end' for this '#pragma clang module begin'"
H688037E203CF: "没有与此 '#pragma clang module begin' 对应的 '#pragma clang module end'"
# "no matching '#pragma clang module endbuild' for this '#pragma clang module build'"
H4D6A2C63F3F1: "没有与此 '#pragma clang module build' 对应的 '#pragma clang module endbuild'"
# 'no matching constructor for initialization of %0'
H60A16B350ED3: '初始化 %0 时没有匹配的构造函数'
# 'no matching conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2'
HB6FD5E96FCBB: '无法将 %1 转换为 %2 的 %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 转换'
# 'no matching function for call to %0'
HF7D6FEC7B803: '调用 %0 时没有匹配的函数'
# 'no matching function for call to object of type %0'
H4AB0B7C8D656: '调用类型 %0 的对象时没有匹配的函数'
# "no matching literal operator for call to %0%select{| with argument of type %2| with arguments of types %2 and %3}1%select{| or 'const char *'}4%select{|, and no matching literal operator template}5"
H1F7F02224823: "调用 %0%select{| 的参数类型为 %2| 的参数类型为 %2 和 %3}1%select{| 或 'const char *'}4%select{|，且没有匹配的字面量操作符模板}5 字面量操作符"
# 'no matching member function for call to %0'
HACEA313A920D: '调用 %0 时没有匹配的成员函数'
# "no matching target found for target variant '%0'"
H2CC48DEFF159: "未找到与目标变体 '%0' 对应的匹配目标"
# 'no member %0 in %1; it has not yet been instantiated'
H6800794A683C: '%1 中没有成员 %0；尚未实例化该成员'
# 'no member named %0 in %1'
H85214E062B3A: '%1 中没有名为 %0 的成员'
# 'no member named %0 in %1; did you mean %select{|simply }2%3?'
H5B97925635DE: '在%1中没有名为%0的成员；您是否是指%select{|仅仅 }2%3？'
# "no member named %0 in %1; did you mean to use '->' instead of '.'?"
HBE0974E3EE78: "在%1中没有名为%0的成员；是否应该使用'->'而不是'.'？"
# 'no method with selector %0 is implemented in this translation unit'
H0CDD4F98E18F: '在此翻译单元中未实现选择器%0对应的方法'
# 'no module map available for module %0'
HF688B8490C1B: '模块%0没有可用的模块映射'
# 'no module name provided; specify one with -fmodule-name='
H99A7BF8D2824: '未提供模块名称；请使用-fmodule-name=指定'
# "no module named '%0' %select{found|in '%2'}1, parent module must be defined before the submodule"
H86A38EF918F2: "未找到名为'%0'的模块 %select{找到|在'%2'中}1；父模块必须在子模块之前定义"
# "no module named '%0' declared in module map file '%1'"
HABF2F4633281: "模块映射文件'%1'中未声明名为'%0'的模块"
# "no module named '%0' in '%1'"
H658500ACD8C1: "在'%1'中没有名为'%0'的模块"
# "no module named '%0' visible from '%1'"
HA7094B5AEB21: "在'%1'中不可见名为'%0'的模块"
# "no more 'if' clause is allowed"
H8F7A1C6703AA: "不允许再有'if'子句"
# "no more than one option '--config' is allowed"
H3089388E4475: "选项'--config'最多允许指定一次"
# 'no multilib found matching flags: %0'
HCDE4340CFBD3: '未找到匹配标志%0的multilib'
# 'no namespace named %0 in %1; did you mean %select{|simply }2%3?'
HF6FEAE5E55D9: '在%1中没有名为%0的命名空间；您是否是指%select{|仅仅 }2%3？'
# 'no namespace named %0; did you mean %1?'
H81CE4465B841: '没有名为%0的命名空间；您是否是指%1？'
# 'no newline at end of file'
HC3F31DC1712E: '文件末尾没有换行符'
# 'no output file specified'
HA94EBB9ACB5A: '未指定输出文件'
# 'no previous extern declaration for non-static variable %0'
H8B284B72F880: '非静态变量%0没有之前的extern声明'
# 'no previous prototype for function %0'
H03B77D9B5049: '函数%0没有之前的原型声明'
# 'no profile data available for file "%0"'
H59152796471E: '文件"%0"没有可用的性能分析数据'
# 'no return statement in %select{constexpr|consteval}0 function'
H6CABFAB2482E: '在%select{constexpr|consteval}0函数中没有return语句'
# "no submodule named %0 in module '%1'"
H2B7BA310F788: "模块'%1'中没有名为%0的子模块"
# "no submodule named %0 in module '%1'; did you mean '%2'?"
H7D6A5E92FB55: "模块'%1'中没有名为%0的子模块；是否是指'%2'？"
# "no submodule named %0 in module '%1'; using top level '%2'"
H5C502E1660AA: "模块'%1'中没有名为%0的子模块；使用顶层的'%2'"
# "no such %select{public|private|project}1 header file: '%0'"
H6EFAEBB81765: "没有这样的%select{公开|私有|项目}1头文件：'%0'"
# "no such excluded %select{public|private}0 header file: '%1'"
HED06FD077272: "没有这样的排除%select{公开|私有}0头文件：'%1'"
# "no such file or directory: '%0'"
HE170FBCF53FC: "没有这样的文件或目录：'%0'"
# "no such file or directory: '%0'; did you mean '%1'?"
HE112F2418E57: "没有这样的文件或目录：'%0'；是否是指'%1'？"
# "no such include directory: '%0'"
H7E37FF613F8F: "没有这样的包含目录：'%0'"
# "no such sysroot directory: '%0'"
H7EBC246FEEA8: "没有这样的sysroot目录：'%0'"
# 'no suitable member %0 in %1'
H3750344F18EF: '%1中没有合适的成员%0'
# "no suitable precompiled header file found in directory '%0'"
HC9D05A0684EB: "目录'%0'中未找到预编译头文件"
# 'no target microcontroller specified, please pass -mmcu=<mcu name>'
H861E68DCEBF9: '未指定目标微控制器，请通过-mmcu=<mcu名称>传递参数'
# 'no template named %0'
HFC0C70B06D89: '没有名为%0的模板'
# 'no template named %0 in %1'
H16DB7E6BC24D: '%1中没有名为%0的模板'
# 'no template named %0 in %1; did you mean %select{|simply }2%3?'
HCDFE5581F7D6: '%1中没有名为%0的模板；是否是指%select{|简单}2%3？'
# 'no template named %0; did you mean %1?'
H32AFF6E21FDC: '没有名为%0的模板；是否是指%1？'
# 'no type named %0 in %1'
H6E87E8CAFF42: '%1中没有名为%0的类型'
# 'no type named %0 in %1; did you mean %select{|simply }2%3?'
H014C7B262D03: '%1中没有名为%0的类型；是否是指%select{|简单}2%3？'
# "no type named 'type' in %0; 'enable_if' cannot be used to disable this declaration"
H03B3775679FC: "%0中没有名为'type'的类型；'enable_if'无法用于禁用此声明"
# 'no type or protocol named %0'
HFF0D89AB2752: '没有名为%0的类型或协议'
# "no valid clauses specified in OpenACC 'declare' directive"
H136795D57206: "在OpenACC 'declare' 指令中未指定有效的子句"
# 'no variable template matches specialization; did you mean to use %0 as function template instead?'
H702E78FBEC31: '没有与特化匹配的变量模板；是否应将%0用作函数模板？'
# 'no variable template matches%select{| partial}0 specialization'
H0903C7695A91: '没有与%select{| 部分}0 特化匹配的变量模板'
# 'no viable candidate for explicit instantiation of %0'
HAEBC7520AFB0: '显式实例化%0时没有可用的候选项'
# 'no viable constructor %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1'
HC9B75808C9E9: '在类型%1的%select{复制变量|复制参数|初始化模板参数|返回对象|初始化语句表达式结果|抛出对象|复制成员子对象|复制数组元素|分配对象|复制临时对象|初始化基类子对象|初始化向量元素|捕获值}0时，没有可用的构造函数'
# 'no viable constructor %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1; C++98 requires a copy constructor when binding a reference to a temporary'
HBD2DEF3D3EA1: '在类型%1的%select{复制变量|复制参数|初始化模板参数|返回对象|初始化语句表达式结果|抛出对象|复制成员子对象|复制数组元素|分配对象|复制临时对象|初始化基类子对象|初始化向量元素|捕获值}0时，没有可用的构造函数；C++98在绑定临时对象到引用时需要复制构造函数'
# 'no viable constructor or deduction guide for deduction of template arguments of %0'
HECA595B57B5C: '为%0的模板参数推导没有可用的构造函数或推导指引'
# 'no viable conversion%diff{ from $ to incomplete type $|}0,1'
H0DDC152C267D: '无法进行%diff{到不完整类型的转换|}0,1有效转换'
# 'no viable conversion%select{%diff{ from $ to $|}1,2|%diff{ from returned value of type $ to function return type $|}1,2}0'
H742AD0829398: '无法进行%select{%diff{从$到$|}1,2|%diff{从类型$的返回值到函数返回类型$|}1,2}0有效转换'
# 'no viable destructor found for class %0'
HE8AA8B1D9E66: '未找到类%0的可用析构函数'
# "no viable overloaded '%0'"
H85F4D23A3BAD: "没有可用的重载'%0'"
# 'no viable overloaded operator[] for type %0'
H2EF71DBEE631: '类型%0没有可用的重载operator[]'
# 'no visible @interface for %0 declares the selector %1'
HF35FE2A8D9B7: '@interface %0未声明选择器%1'
# 'noexcept expressions are incompatible with C++98'
H770DCD42AD88: 'noexcept表达式与C++98不兼容'
# 'noexcept specifications are incompatible with C++98'
HCDFCAD5EB464: 'noexcept说明与C++98不兼容'
# 'non-ASM statement in naked function is not supported'
H13FAFC759C77: '带有非ASM语句的裸函数不被支持'
# 'non-class friend type %0 is a C++11 extension'
HD60A5C8C49AC: '非类友元类型%0是C++11扩展'
# 'non-class friend type %0 is incompatible with C++98'
H4D0DB388513A: '非类友元类型%0与C++98不兼容'
# 'non-const static data member must be initialized out of line'
HFA5187DD3DCB: '非const静态数据成员必须在类外初始化'
# 'non-constant static local variable in inline function may be different in different files'
HDAC621E8867A: '内联函数中的非const静态局部变量在不同文件中可能不同'
# 'non-constant-expression cannot be narrowed from type %0 to %1 in initializer list'
H48217DABAA7D: '非常量表达式不能在初始化列表中将类型%0缩小为%1'
# 'non-constant-expression cannot be narrowed from type %0 to %1 in initializer list in C++11'
H996365ACA997: '非常量表达式不能在C++11的初始化列表中将类型%0缩小为%1'
# 'non-consteval function %0 cannot override a consteval function'
H3BE45C7BF2C1: '非consteval函数%0不能覆盖consteval函数'
# 'non-constexpr comparison function declared here'
H6CDFA8CCBBD8: '在此处声明的非constexpr比较函数'
# 'non-constexpr comparison function would be used to compare %select{|member %1|base class %1}0'
HFFB83E06B051: '非constexpr比较函数将用于比较%select{|成员%1|基类%1}0'
# 'non-deducible template parameter %0'
HD419F387C770: '非推导的模板参数%0'
# 'non-default #pragma pack value changes the alignment of struct or union members in the included file'
H2C52662649BE: '非默认的#pragma pack值会改变包含文件中结构体或联合体成员的对齐方式'
# "non-default visibility cannot be applied to 'dllimport' declaration"
H2A9EC7D43705: "'dllimport'声明无法应用非默认可见性"
# 'non-defining declaration of enumeration with a fixed underlying type is only permitted as a standalone declaration%select{|; missing list of enumerators?}0'
H4D151B6B2BF9: '具有固定基础类型的枚举的非定义声明仅允许作为独立声明%select{|; 缺少枚举列表？}0'
# 'non-deleted function %0 cannot override a deleted function'
H2F21A881D5B2: '非删除函数%0不能覆盖已删除的函数'
# 'non-extern declaration of %0 follows extern declaration'
H7E386503A2B6: '%0的非extern声明跟在extern声明之后'
# 'non-friend class member %0 cannot have a qualified name'
H01BBFAF999D6: '非友元类成员%0不能有合格名称'
# 'non-inline external definitions are not permitted in C++ header units'
H0E67412E5EDC: '不允许在C++头单元中使用非内联外部定义'
# 'non-inline namespace cannot be reopened as inline'
H43CE8E47A824: '非内联命名空间不能作为内联重新打开'
# 'non-literal type %0 cannot be used in a constant expression'
HFCBBB3F7D771: '非字面类型%0不能用于常量表达式'
# 'non-local lambda expression cannot have a capture-default'
H2B075ACEF012: '非局部lambda表达式不能有捕获默认值'
# 'non-local variable with sizeless type %0'
H92600D86A0C5: '具有无大小类型%0的非局部变量'
# 'non-namespace scope %0 cannot have a literal operator member'
H266845A5FE4C: '非命名空间作用域%0不能有字面运算符成员'
# 'non-object type %0 is not assignable'
H8FB33F67F675: '非对象类型%0不可赋值'
# "non-pointer argument to '__builtin_assume_aligned' is not allowed"
HD960D71E3301: "传递给'__builtin_assume_aligned'的非指针参数不允许"
# 'non-pointer operand type %0 incompatible with %select{NULL|nullptr}1'
H90B6AFB986DF: '非指针操作数类型%0与%select{NULL|nullptr}1不兼容'
# "non-portable path to file '%0'; specified path differs in case from file name on disk"
H43FE55A52897: "文件'%0'的路径不可移植；指定的路径与磁盘上的文件名大小写不同"
# 'non-predefined allocator must have traits specified'
HFFB74BA64E52: '非预定义分配器必须指定其特性'
# 'non-static data member %0 cannot be declared as a template'
HEE38B2049618: '非静态数据成员%0不能声明为模板'
# 'non-static data member cannot be constexpr%select{; did you intend to make it %select{const|static}0?|}1'
H19D13A6885F4: '非静态数据成员不能声明为constexpr%select{；是否打算将其声明为%select{const|static}0？|}1'
# 'non-static data member defined out-of-line'
HC4D58BAF82DF: '非静态数据成员在外部定义'
# 'non-static declaration of %0 follows static declaration'
H25169BF9CE09: '%0的非静态声明跟在静态声明之后'
# 'non-static member %0 found in multiple base-class subobjects of type %1:%2'
H1D1EE8E2CCD9: '在类型%1的多个基类子对象中找到非静态成员%0：%2'
# 'non-template declaration found by name lookup'
HF380F2D95EAA: '名称查找找到非模板声明'
# 'non-template friend declaration with a requires clause must be a definition'
H95DF301285CD: '带有requires子句的非模板友元声明必须是一个定义'
# 'non-template literal operator must have one or two parameters'
HAB8D25BD0598: '非模板字面量运算符必须有一个或两个参数'
# 'non-templated declaration is here'
H5E1276462F94: '非模板声明在此处'
# 'non-templated function cannot have a requires clause'
H82190871139C: '非模板函数不能带有requires子句'
# 'non-thread-local declaration of %0 follows thread-local declaration'
H015D893F1487: '%0的非线程局部声明跟在线程局部声明之后'
# 'non-trivial destruction of lifetime-extended temporary with type %0 used in the result of a constant expression is not yet supported'
HD2339C077B90: '在常量表达式的结果中使用类型%0的生命周期扩展临时对象的非平凡析构尚未被支持'
# 'non-trivial destruction of type %0 in a constant expression is not supported'
HE2CD4D9E53E2: '类型%0在常量表达式中的非平凡析构不被支持'
# 'non-trivially copyable type %0 cannot be used in a boxed expression'
HB2216F42639D: '非平凡可复制的类型%0不能用于装箱表达式'
# 'non-type declaration found by destructor name lookup'
HB02DCE8A7FF1: '析构函数名称查找找到非类型声明'
# "non-type template argument '%0' is invalid"
H2399CD2B5610: "非类型模板实参'%0'无效"
# 'non-type template argument containing a dereference operation is a Microsoft extension'
HD4EF29A775AB: '包含解引用操作的非类型模板实参是微软扩展'
# 'non-type template argument does not refer to an object or function'
HE77C0A012513: '非类型模板实参不指向对象或函数'
# 'non-type template argument does not refer to any declaration'
HB25807F91411: '非类型模板实参未引用任何声明'
# 'non-type template argument for template parameter of pointer type %0 must have its address taken'
H8D4CDD97C49D: '指向类型 %0 的模板参数的非类型模板实参必须取其地址'
# 'non-type template argument is not a pointer to member constant'
HDC21F0C558EB: '非类型模板实参不是指向成员常量的指针'
# 'non-type template argument of reference type %0 is not an object'
H50574CDA0DAD: '引用类型 %0 的非类型模板实参不是对象'
# 'non-type template argument of type %0 cannot be converted to a value of type %1'
HDF1742D8033F: '类型 %0 的非类型模板实参无法转换为类型 %1 的值'
# 'non-type template argument of type %0 is not a constant expression'
H075FB8D7A63A: '类型 %0 的非类型模板实参不是常量表达式'
# 'non-type template argument of type %0 is not an integral constant expression'
HE2EA0C6B3858: '类型 %0 的非类型模板实参不是整型常量表达式'
# 'non-type template argument of type %0 must have an integral or enumeration type'
H06D35F5E0195: '类型 %0 的非类型模板实参必须具有整型或枚举类型'
# 'non-type template argument referring to %select{function|object}0 %1 with internal linkage is a C++11 extension'
HEFF3308ED7FE: '指向具有内部链接性的 %select{函数|对象}0 %1 的非类型模板实参是 C++11 扩展'
# 'non-type template argument referring to %select{function|object}0 %1 with internal linkage is incompatible with C++98'
H2F0100862103: '指向具有内部链接性的 %select{函数|对象}0 %1 的非类型模板实参与 C++98 不兼容'
# 'non-type template argument refers here'
HA953EF53E7DD: '非类型模板实参在此处引用'
# 'non-type template argument refers to %select{function|object}0 %1 that does not have linkage'
H600BCDFEE43D: '非类型模板实参引用未具有链接性的 %select{函数|对象}0 %1'
# 'non-type template argument refers to %select{function|object}0 here'
H9ED37B3451CC: '非类型模板实参在此处引用 %select{函数|对象}0'
# 'non-type template argument refers to non-static data member %0'
H2465AB2AA5B5: '非类型模板实参引用非静态数据成员 %0'
# 'non-type template argument refers to non-static member function %0'
H6A037F433017: '非类型模板实参引用非静态成员函数 %0'
# "non-type template argument refers to subobject '%0'"
HD30CEA1C7504: "非类型模板实参引用子对象 '%0'"
# 'non-type template argument refers to thread-local object'
H1DFBA6B66CEF: '非类型模板实参引用线程局部对象'
# 'non-type template argument specializes a template parameter with dependent type %0'
H77D31AA373EF: '非类型模板实参特化了类型为 %0 的依赖类型模板参数'
# "non-type template argument value '%0' truncated to '%1' for template parameter of type %2"
H5466021B086C: "类型为 %2 的模板参数的非类型模板实参值 '%0' 被截断为 '%1'"
# "non-type template argument with value '%0' converted to '%1' for unsigned template parameter of type %2"
H4635C03C8C36: "值为 '%0' 的非类型模板实参转换为类型 %2 的无符号模板参数的类型 '%1'"
# 'non-type template parameter %0 with type %1 has incompatible initializer of type %2'
H36B37E5D284B: '类型为 %1 的非类型模板参数 %0 具有类型 %2 的不兼容初始化器'
# 'non-type template parameter declared with incompatible types in different translation units (%0 vs. %1)'
H349C88186DB6: '在不同翻译单元中声明的非类型模板参数具有不兼容的类型（%0 对 %1）'
# 'non-type template parameter has incomplete type %0'
H67B9597CFD9A: '非类型模板参数具有不完全类型 %0'
# 'non-type template parameter has non-literal type %0'
H271C87C2E376: '非类型模板参数具有非字面量类型 %0'
# 'non-type template parameter has rvalue reference type %0'
H8258CBB4119D: '类型为 %0 的右值引用类型的非类型模板参数'
# 'non-type template parameter of reference type %diff{$ cannot bind to template argument of type $|cannot bind to template of incompatible argument type}0,1'
H4F089D7DCBD1: '引用类型非类型模板参数 %diff{$ 无法绑定到类型为 $|无法绑定到不兼容参数类型的模板}0,1'
# 'non-type template parameter of type %0 is incompatible with C++ standards before C++20'
H76F7D38734C2: '类型为 %0 的非类型模板参数与 C++20 之前的 C++ 标准不兼容'
# 'non-type template parameter of variably modified type %0'
HDB7696E83E21: '类型为 %0 的变长类型非类型模板参数'
# 'non-type template parameters declared with %0 are incompatible with C++ standards before C++17'
H4034BC5F4762: '使用 %0 声明的非类型模板参数与 C++17 之前的 C++ 标准不兼容'
# 'non-usual %0 declared here'
H9B44D0E82E0B: '非常规 %0 在此处声明'
# "non-variable declaration in 'for' loop"
HE2801E92B8D8: "'for' 循环中的非变量声明"
# "non-variable declaration in 'for' loop is a C23 extension"
H861D242B28D2: "'for' 循环中的非变量声明是 C23 扩展"
# "non-variable declaration in 'for' loop is incompatible with C standards before C23"
H1A5C6F3C6A58: "'for' 循环中的非变量声明与 C23 之前的 C 标准不兼容"
# "non-virtual member function marked '%0' hides virtual member %select{function|functions}1"
H6156F12DC3F9: "标记为 '%0' 的非虚成员函数隐藏了虚成员 %select{函数|函数}1"
# 'non-void %select{constexpr|consteval}1 function %0 should return a value'
HCF55E17BA989: '非 void %select{constexpr|consteval}1 函数 %0 应返回一个值'
# 'non-void %select{function|block|lambda|coroutine}0 does not return a value%select{| in all control paths}1'
H75EE618D1AA4: '非 void %select{函数|块|lambda|协程}0 未返回一个值%select{|在所有控制路径中}1'
# 'non-void %select{function|method}1 %0 should return a value'
HEE95067001EB: '非 void %select{函数|方法}1 %0 应返回一个值'
# 'non-void block should return a value'
H66594B013217: '非 void 块应返回一个值'
# "nonnull %select{function call|parameter}0 '%1' will evaluate to 'true' on first encounter"
H925BCFBBE426: "非空 %select{函数调用|参数}0 '%1' 在首次遇到时将被评估为 'true'"
# 'not a Doxygen trailing comment'
HB02E938B9DEC: '不是Doxygen尾部注释'
# "not currently inside '#pragma clang arc_cf_code_audited'"
HD79C4D940185: "不在'#pragma clang arc_cf_code_audited'指令范围内"
# "not currently inside '#pragma clang assume_nonnull'"
HF77D5E6601B3: "不在'#pragma clang assume_nonnull'指令范围内"
# "not currently inside '#pragma unsafe_buffer_usage'"
H658512A345D7: "不在'#pragma unsafe_buffer_usage'指令范围内"
# 'not enough variable arguments in %0 declaration to fit a sentinel'
H9930B56495BC: '%0声明中的可变参数数量不足以容纳哨兵'
# 'not packing field %0 as it is non-POD for the purposes of layout'
H7FBA81FDAA18: '由于布局目的，字段%0不是POD类型，因此不会被压缩'
# 'not-yet-instantiated member is declared here'
HACFD1F41F676: '尚未实例化的成员在此处声明'
# 'null character ignored'
H6B4B3A47C8AC: '空字符被忽略'
# 'null character(s) preserved in %select{char|string}0 literal'
H062C86F6116B: '在%select{字符|字符串}0字面量中保留空字符'
# 'null non-type template argument must be cast to template parameter type %0'
HDDA635486EF3: '空的非类型模板参数必须转换为模板参数类型%0'
# 'null non-type template argument of type %0 does not match template parameter of type %1'
HCF293B48A07C: '类型%0的空非类型模板参数与类型%1的模板参数不匹配'
# 'null passed to a callee that requires a non-null argument'
H5F7D096FCE08: '将空值传递给需要非空参数的调用方'
# 'null returned from %select{function|method}0 that requires a non-null return value'
HEA9F26CD4560: '从需要非空返回值的%select{函数|方法}0返回空值'
# 'nullability keyword %0 cannot be applied to multi-level pointer type %1'
H9F63F0EFF7CC: '空值限定符%0不能应用于多级指针类型%1'
# 'nullability specifier %0 cannot be applied to non-pointer type %1'
HA1F5D87BE3DF: '空值限定符%0不能应用于非指针类型%1'
# 'nullability specifier %0 cannot be applied to non-pointer type %1; did you mean to apply the specifier to the %select{pointer|block pointer|member pointer|function pointer|member function pointer}2?'
H3E269F064E84: '空值限定符%0不能应用于非指针类型%1；是否应将限定符应用于%select{指针|块指针|成员指针|函数指针|成员函数指针}2？'
# 'nullability specifier %0 conflicts with existing specifier %1'
H4421DC48369F: '空值限定符%0与现有限定符%1冲突'
# 'number of elements must be either one or match the size of the vector'
H2A474F4275FA: '元素数量必须为1或与向量的大小匹配'
# 'numeric literal with user-defined suffix cannot be used here'
H6D6640DAD12D: '此处不能使用带有用户自定义后缀的数值字面量'
# "nvcc does not allow '__%0__' to appear after the parameter list in lambdas"
H052A23E5C9DE: "nvcc不允许在lambda的参数列表后出现'__%0__'"
# 'objc_precise_lifetime is not meaningful for %select{__unsafe_unretained|__autoreleasing}0 objects'
H3B4A7538E1D6: 'objc精准生命周期对%select{__unsafe_unretained|__autoreleasing}0对象没有意义'
# 'objc_precise_lifetime only applies to retainable types; type here is %0'
HCB888D9DBEF6: 'objc精准生命周期仅适用于可保留类型；此处类型为%0'
# 'objc_root_class attribute may only be specified on a root class declaration'
H8B7E866F5F47: 'objc_root_class属性只能在根类声明中指定'
# 'object backing %select{|the pointer }0%1 will be destroyed at the end of the full-expression'
H4CCEF5B24A9C: '支撑%select{|指针 }0%1的对象将在完整表达式结束时被销毁'
# 'object backing the pointer %0 will be destroyed at the end of the full-expression'
H4314D747B320: '支撑指针%0的对象将在完整表达式结束时被销毁'
# 'object backing the pointer will be destroyed at the end of the full-expression'
HCBDFA4406EFB: '支撑指针的对象将在完整表达式结束时被销毁'
# 'object expression of non-scalar type %0 cannot be used in a pseudo-destructor expression'
H8E297F831414: '非标量类型%0的对象表达式不能用于伪析构表达式'
# "object format flags cannot be used with '%0' conversion specifier"
HAF558B2410E4: "对象格式标志不能与'%0'转换说明符一起使用"
# 'object of type %0 cannot be %select{constructed|copied|moved|assigned|assigned|destroyed}1 because its %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 is implicitly deleted'
H828A944AA309: '类型%0的对象无法%select{构造|拷贝|移动|赋值|赋值|销毁}1，因为其%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}1已被隐式删除'
# 'object of type %0 cannot be compared because its %1 is implicitly deleted'
H4465935A9154: '类型%0的对象无法进行比较，因为其%1已被隐式删除'
# 'object of type %0 cannot be placed in read-only memory'
HD27A532EA3C9: '类型%0的对象无法放置在只读内存中'
# 'object of type %0 is not compatible with %select{array element type|dictionary key type|dictionary value type}1 %2'
HBDF524B06F4F: '类型%0的对象与%select{数组元素类型|字典键类型|字典值类型}1 %2不兼容'
# "object whose reference is captured by '%0' will be destroyed at the end of the full-expression"
H1329A74CEAA1: "被'%0'捕获引用的对象将在完整表达式结束时被销毁"
# 'object whose reference is captured will be destroyed at the end of the full-expression'
H04404B93E557: '被捕获引用的对象将在完整表达式结束时被销毁'
# 'octal integer literals are a C2y extension'
HCB95FC190C42: '八进制整数字面量是C2y扩展'
# 'octal integer literals are a Clang extension'
H0A7A0AD8FA23: '八进制整数字面量是Clang扩展'
# 'octal integer literals are incompatible with standards before C2y'
HFF58B98B1092: '八进制整数字面量与C2y之前的语言标准不兼容'
# "octal literals without a '0o' prefix are deprecated"
H297C91C7799F: "未带'0o'前缀的八进制字面量已被弃用"
# 'offset of on non-POD type %0'
H3798D618C09F: '非POD类型%0的结构体成员偏移量'
# 'offset of on non-standard-layout type %0'
H1C1DF95C948D: '非标准布局类型%0的结构体成员偏移量'
# 'offsetof of incomplete type %0'
H01B4054FE86A: 'offsetof的参数%0是不完整类型'
# 'offsetof requires array type, %0 invalid'
H72E546984F9B: 'offsetof需要数组类型，%0无效'
# 'offsetof requires struct, union, or class type, %0 invalid'
H1EED7971DB36: 'offsetof需要结构体、联合或类类型，%0无效'
# "old syntax '%0' on '%1' clause was deprecated, use new syntax '%2'"
H62AFC50986BB: "'%1'子句中的旧语法'%0'已弃用，请改用新语法'%2'"
# 'omit the namespace to add attributes to the most-recently pushed attribute group'
H33451023019A: '省略命名空间以将属性添加到最近添加的属性组'
# 'omitting the parameter name in a function definition is a C23 extension'
H239CD59B1E97: '在函数定义中省略参数名是C23扩展'
# 'on M-profile architectures %0 attribute is not supported on targets missing %1; specify an appropriate -march= or -mcpu='
HF63DAE65A9BA: '在M架构上，%0属性在缺少%1的目标上不受支持；请指定适当的-march=或-mcpu='
# "one of 'for', 'parallel', 'sections' or 'taskgroup' is expected"
HA318D6E65846: "期望其中一个：'for', 'parallel', 'sections' 或 'taskgroup'"
# 'one possibility'
HF5AE3D1F7A2D: '一种可能'
# "only %select{'omp_priv' or 'omp_orig'|'omp_in' or 'omp_out'}0 variables are allowed in %select{initializer|combiner}0 expression"
HBFBFE733ACC9: "在%select{initializer|combiner}0表达式中，仅允许%select{'omp_priv'或'omp_orig'|'omp_in'或'omp_out'}0变量"
# "only '*' can be exported from an inferred submodule"
HB1E7869E1AA8: "只能从推导的子模块导出'*'"
# "only 'device_type(any)' clause is allowed with indirect clause"
H60FE040D9778: "间接子句仅允许使用'device_type(any)'子句"
# "only 'unavailable' and 'deprecated' are supported for Swift availability"
H711C14834055: "Swift可用性仅支持'unavailable'和'deprecated'"
# 'only a single match extension allowed per OpenMP context selector'
H54ED4E173E0C: '每个OpenMP上下文选择器仅允许一个匹配扩展'
# 'only constructors take base initializers'
HDB605C258726: '只有构造函数可以使用基类初始化器'
# 'only enumeration types have underlying types'
H35007289C6D1: '仅枚举类型具有底层类型'
# 'only function and template parameters can be parameter packs'
HE058E90890AE: '仅函数和模板参数可以是参数包'
# 'only functions can have deleted definitions'
H0BDC0C1C20D8: '只有函数可以具有已删除的定义'
# "only loop iteration variables are allowed in 'lastprivate' clause in 'omp %0' directives"
H93109DDAC062: "在'omp %0'指令的'lastprivate'子句中仅允许循环迭代变量"
# "only loop iteration variables are allowed in 'linear' clause in distribute directives"
HB4FBF6AB0B0A: "在distribute指令的'linear'子句中仅允许循环迭代变量"
# 'only one %0 clause can appear on a requires directive in a single translation unit'
H67EC4B23D848: '在单个翻译单元中，requires子句只能出现一个%0子句'
# 'only one element declaration is allowed'
HB7E0C8F27CB5: '只能声明一个元素'
# "only one expression allowed in '%0' clause"
H200100A1AF70: "在'%0'子句中只能有一个表达式"
# 'only one offload target is supported'
H36578B307452: '仅支持一个卸载目标'
# "only one parameter on 'main' declaration"
H09469DD0E50E: "'main'声明只能有一个参数"
# 'only special member functions %select{|and comparison operators }0may be defaulted'
H7676F4E831FD: '只能默认特殊成员函数%select{|和比较运算符}0'
# 'only submodules and framework modules may be inferred with wildcard syntax'
HB41F304027AC: '只能通过通配符语法推断子模块和框架模块'
# 'only the first dimension of an allocated array may have dynamic size'
HCC4AF93D4D25: '分配的数组只能在第一个维度具有动态大小'
# 'only top-level modules can be re-exported as public'
H35599F0992E5: '仅顶级模块可以作为公共模块重新导出'
# "only variable %0 is allowed in map clauses of this 'omp declare mapper' directive"
HCD77D6699FCF: "在此'omp declare mapper'指令的map子句中，仅允许变量%0"
# "only variables can be arguments to '#pragma unused'"
H454069F49B2C: "'#pragma unused'的参数只能是变量"
# "only virtual member functions can be marked '%0'"
H88BCFFA5846F: '只能标记虚拟成员函数为"%0"'
# 'only zero-length WebAssembly tables are currently supported'
H834ECF2F9D5B: '当前仅支持零长度的WebAssembly表'
# "operand argument to %select{overflow builtin|checked integer operation}0 must be an integer type %select{|other than plain 'char', 'bool', bit-precise, or an enumeration }0(%1 invalid)"
H232C02FD2560: '%select{溢出内置函数|带检查的整数运算}0的运算数参数必须为整数类型%select{|，而非普通"char"、"bool"、精确位宽或枚举类型}0（%1无效）'
# 'operand of ? changes signedness: %0 to %1'
H034F94202BD7: '问号运算符的运算数改变了符号：%0到%1'
# 'operand of type %0 cannot be cast to a pointer type'
H39550A20AC28: '类型%0的运算数不能转换为指针类型'
# 'operand of type %0 where arithmetic or pointer type is required'
H73F559724DF8: '需要算术类型或指针类型的位置却使用了类型%0的运算数'
# 'operands to conditional of types%diff{ $ and $|}0,1 are incompatible in ARC mode'
HA7936DDDD636: '在ARC模式下，条件运算符的运算数类型%diff{ $和$ |}0,1不兼容'
# "operator '%0' has lower precedence than '%1'; '%1' will be evaluated first"
H7655BF3550EE: '运算符"%0"的优先级低于"%1"；"%1"将先被计算'
# "operator '?:' has lower precedence than '%0'; '%0' will be evaluated first"
HFCE2B46187B8: '运算符"?: "的优先级低于"%0"；"%0"将先被计算'
# 'operators in fold expression must be the same'
H1479CC2CDE54: '折叠表达式中的运算符必须相同'
# "optimization flag '%0' is not supported"
HED6E92EF31B3: "优化标志 '%0' 不受支持"
# "optimization flag '%0' is not supported for target '%1'"
H7BA15DDB49BE: "优化标志 '%0' 不适用于目标 '%1'"
# "optimization level '%0' is not supported; using '%1%2' instead"
H6D18AF90D4BB: "优化级别 '%0' 不受支持；将使用 '%1%2' 代替"
# "option '%0' cannot be specified on this target"
H1BE1A4C28B5B: "选项 '%0' 不能在此目标上指定"
# "option '%0' cannot be specified with '%1'"
H70F63315B132: "选项 '%0' 不能与 '%1' 一起指定"
# "option '%0' cannot be specified with '%1' for the %2 sub-architecture"
HBBDD552F5F1A: "选项 '%0' 不能与 '%1' 一起指定用于 %2 子架构"
# "option '%0' cannot be specified without '%1'"
H583C3C9DA6E7: "选项 '%0' 必须与 '%1' 一起指定"
# "option '%0' requires input to be LLVM bitcode"
HA5B4E61775E4: "选项 '%0' 需要输入为LLVM位码"
# "option '%0' was ignored by the %1 toolchain, using '-fPIC'"
H22B2E1051C0B: "选项 '%0' 被 %1 工具链忽略，使用 '-fPIC'"
# "option '-MG' requires '-M' or '-MM'"
HCCC4BA63CA80: "选项 '-MG' 需要与 '-M' 或 '-MM' 一起使用"
# "option '-ffine-grained-bitfield-accesses' cannot be enabled together with a sanitizer; flag ignored"
H4FD110105D82: "选项 '-ffine-grained-bitfield-accesses' 不能与 sanitizer 一起启用；标志被忽略"
# "option '-fmodule-output' cannot be used with multiple arch options"
H67AC45523A0C: "选项 '-fmodule-output' 不能与多个架构选项一起使用"
# "option '-fmodules-validate-once-per-build-session' requires '-fbuild-session-timestamp=<seconds since Epoch>' or '-fbuild-session-file=<file>'"
H5685B0FE4474: "选项 '-fmodules-validate-once-per-build-session' 需要 '-fbuild-session-timestamp=<自纪元秒数>' 或 '-fbuild-session-file=<文件>'"
# "option 'ffp-eval-method' cannot be used with option %select{'fapprox-func'|'mreassociate'|'freciprocal'}0"
H1D986A148023: "选项 'ffp-eval-method' 不能与选项 %select{'fapprox-func'|'mreassociate'|'freciprocal'}0 一起使用"
# 'options %0 and %1 are set to different values'
H15DAE6B37541: '选项 %0 和 %1 被设置为不同的值'
# 'or because setter is declared here, but no getter method %0 is found'
H9306685E39B6: '或因为设置器在此处声明，但未找到对应的获取方法 %0'
# "or insert whitespace before ':' to use %0 as parameter name and have an empty entry in the selector"
H09DF98AB0B6F: "或在 ':' 前插入空格，以将 %0 用作参数名称并在选择器中留空"
# 'ordered compare requires two args of floating point type%diff{ ($ and $)|}0,1'
HC6DBD7D802C7: '有序比较需要两个浮点类型的参数%diff{ ($ 和 $)|}0,1'
# 'ordered comparison between pointer and integer (%0 and %1)'
HCE8E7EA44A15: '指针与整数之间的有序比较（%0 和 %1）'
# 'ordered comparison between pointer and zero (%0 and %1)'
H08DE668CB79E: '指针和零之间的有序比较（%0 和 %1）'
# 'ordered comparison between pointer and zero (%0 and %1) is an extension'
HEFA21113E58A: '指针和零之间的有序比较（%0 和 %1）是一个扩展'
# 'ordered comparison of function pointers (%0 and %1)'
H6623D571A716: '函数指针之间的有序比较（%0 和 %1）'
# 'original arguments in round-trip: %0'
H88D576AD9392: '往返过程中的原始参数： %0'
# 'original arguments parse failed, then succeeded in round-trip'
H4354C394D0BE: '原始参数解析失败，但在往返过程中成功'
# 'original storage of expression in data environment is shared but data environment do not fully contain mapped expression storage'
H8588EE9D0D77: '数据环境中的表达式原始存储是共享的，但数据环境并未完全包含映射的表达式存储'
# "orphaned 'omp %0' directives are prohibited; perhaps you forget to enclose the directive into a %select{|||target |teams|for, simd, for simd, parallel for, or parallel for simd }1region?"
H09B89CE1DDFB: "未被包围的 'omp %0' 指令是禁止的；可能您忘记将指令包含在 %select{|||target |teams|for, simd, for simd, parallel for, 或 parallel for simd }1 区域中？"
# "os '%0' is not supported: '%1'"
HD285B7E47AB6: "操作系统 '%0' 不支持：'%1'"
# "os_log() '%%n' format specifier is not allowed"
HA308C5A1A678: "os_log() 不允许使用 '%%n' 格式说明符"
# 'os_log() argument %0 is too big (%1 bytes, max %2)'
H93B7553E2DE5: 'os_log() 参数 %0 过大（%1 字节，最大 %2）'
# 'os_log() format argument is not a string constant'
H6ABC3AD79FAA: 'os_log() 格式参数不是字符串常量'
# 'other definition of %0'
HFB23FE3FA4F8: '%0 的其他定义'
# 'out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1'
HC3CEC6EF88DD: '%0 的外部 %select{声明|定义}2 与 %1 中的任何声明不匹配'
# 'out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1; did you mean %3?'
H6724D4146D60: '%0 的外部 %select{声明|定义}2 与 %1 中的任何声明不匹配；您是指 %3 吗？'
# 'out-of-line constructor for %0 cannot have template arguments'
H33FE02CBF6A6: '%0 的外部构造函数不能有模板参数'
# 'out-of-line declaration of a member must be a definition'
HBCC796880D79: '成员的外部声明必须是一个定义'
# 'out-of-line definition of %0 from class %1 without definition'
H3397C2717560: '来自类 %1 的 %0 的外部定义没有定义'
# 'out-of-line definition of constexpr static data member is redundant in C++17 and is deprecated'
HF4242355CFAD: 'C++17 中外部 constexpr 静态数据成员的定义是多余的，并且已弃用'
# 'overflow converting case value to switch condition type (%0 to %1)'
HF36747707003: '将 case 值转换为 switch 条件类型时溢出（%0 到 %1）'
# 'overflow in expression; result is %0 with type %1'
H5FE3FC44898D: '表达式溢出；结果是 %0，类型为 %1'
# 'overlapping comparisons always evaluate to %select{false|true}0'
H9631A49EAD2B: '重叠比较始终评估为%select{false|true}0'
# "overload resolution selected deleted operator '%0'%select{|: %2}1"
HB844E51E83EA: "重载决议选择了已删除的运算符 '%0'%select{|: %2}1"
# 'overloaded %0 cannot be a static member function'
HE25D37D77FD9: '重载的%0不能是静态成员函数'
# 'overloaded %0 cannot be variadic'
H49C83B8BBB4E: '重载的%0不能是可变参数的'
# 'overloaded %0 cannot have %select{no|a defaulted|more than one}1 parameter before C++23'
H1FC62986EC90: '在C++23之前，重载的%0不能拥有%select{无|一个默认的|超过一个}1参数'
# 'overloaded %0 must be a %select{unary|binary|unary or binary}2 operator (has %1 parameter%s1)'
HA142B5DEA04D: '重载 %0 必须是 %select{一元|二元|一元或二元}2 运算符（具有 %1 参数%s1）'
# 'overloaded %0 must be a non-static member function'
H359B48F5CEFF: '重载的%0必须是非静态成员函数'
# 'overloaded %0 must have at least one parameter of class or enumeration type'
H329B9199B7C8: '重载的%0必须至少有一个参数是类或枚举类型'
# 'overloaded %0 with %select{no|a defaulted|more than one}1 parameter is a C++23 extension'
H9DE4D96FF9C0: '带有%select{无|一个默认的|超过一个}1参数的重载%0是C++23的扩展'
# 'overloaded operator %select{>>|<<}0 has higher precedence than comparison operator'
H3D68DF30B083: '重载的%select{>>|<<}0运算符的优先级高于比较运算符'
# 'overridden method is here'
H33E209C67E48: '被覆盖的方法在此处'
# 'overridden method returns an instance of its class type'
HA983C03A495A: '被覆盖的方法返回其类类型的实例'
# 'overridden virtual function is here'
HFA2BCE5F4E2A: '被覆盖的虚函数在此处'
# "overriding '%0' option with '%1'"
H0BEA2CFA1C71: "用'%1'覆盖'%0'选项"
# 'overriding currently unsupported rounding mode on this target'
HE764C7911186: '覆盖当前目标上不支持的舍入模式'
# 'overriding currently unsupported use of floating point exceptions on this target'
H4E019EDC5E1E: '覆盖当前目标上不支持的浮点异常使用'
# 'overriding method has mismatched ns_consumed attribute on its parameter'
H94209C3B1D29: '覆盖的方法与其参数的ns_consumed属性不匹配'
# 'overriding method has mismatched ns_returns_%select{not_retained|retained}0 attributes'
HFA26D6769DAD: '覆盖的方法与其ns_returns_%select{not_retained|retained}0属性不匹配'
# 'overriding the module target triple with %0'
H7A3B62788722: '用%0覆盖模块的目标三元组'
# 'overriding virtual function must specify the same code segment as its overridden function'
HD38E3F8D7591: '覆盖的虚函数必须指定与被覆盖函数相同的代码段'
# 'pack declaration outside of template'
HDF7BB0B67932: '包声明位于模板外部'
# 'pack expansion contains parameter pack %0 that has a different length (%1 vs. %select{|at least }2%3) from outer parameter packs'
H41600DB01010: '包展开包含参数包%0，其长度与外部参数包不同（%1 与 %select{|至少 }2%3）'
# 'pack expansion contains parameter pack %0 that has a different length (at least %1 vs. %2) from outer parameter packs'
H477211AA8361: '包展开包含参数包%0，其长度与外部参数包不同（至少%1 与 %2）'
# 'pack expansion contains parameter packs %0 and %1 that have different lengths (%2 vs. %select{|at least }3%4)'
H4F8FA8F98117: '包展开包含参数包%0和%1，其长度不同（%2 与 %select{|至少 }3%4）'
# 'pack expansion does not contain any unexpanded parameter packs'
H8BAD94174D96: '包展开中不包含任何未展开的参数包'
# 'pack expansion for initialization of member %0'
HBD2872B50273: '成员%0的初始化所用的包展开'
# 'pack expansion of using declaration is a C++17 extension'
H1BE8FC7C5774: 'using声明的包展开是C++17扩展'
# 'pack expansion used as argument for non-pack parameter of %select{alias template|concept}0'
HBF85ED181091: '%select{别名模板|概念}0 的非包参数使用了包扩展参数'
# 'pack expansion using declaration is incompatible with C++ standards before C++17'
HFDB9F5A38038: '使用using声明的包展开与C++17之前的C++标准不兼容'
# 'pack fold expression is a C++17 extension'
H7820808CC9E4: '包折叠表达式是C++17扩展'
# 'pack fold expression is incompatible with C++ standards before C++17'
H2F52B697F3BE: '包折叠表达式与C++17之前的C++标准不兼容'
# 'pack indexing is a C++2c extension'
H1086B8F449EB: '包索引是C++2c扩展'
# 'pack indexing is incompatible with C++ standards before C++2c'
H9DAE09EBBEA1: '包索引与C++2c之前的C++标准不兼容'
# 'packed attribute is unnecessary for %0'
H08493DD022D1: '对于%0，packed属性是不必要的'
# "packoffset at 'y' not match alignment %0 required by %1"
H1D68367EC4D7: "在'y'处的packoffset与%1要求的%0对齐不匹配"
# 'packoffset cannot cross register boundary'
HA00AFB61162C: 'packoffset不能跨越寄存器边界'
# 'packoffset overlap between %0, %1'
H8FBBA6B5715E: '%0和%1之间的packoffset重叠'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align %4'
HB4806E10E325: '用%2 %select{字节|位}3%s2填充%select{结构体|接口|类}0 %1以对齐%4'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align anonymous bit-field'
HE333A36DBC3C: '用%2 %select{字节|位}3%s2填充%select{结构体|接口|类}0 %1以对齐匿名位域'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align anonymous field'
H1B5890218438: '用%2 %select{字节|位}3%s2填充%select{结构体|接口|类}0 %1以对齐匿名成员'
# 'padding size of %0 with %1 %select{byte|bit}2%s1 to alignment boundary'
H5BCCA44B6E5B: '用%1 %select{字节|位}2%s1填充%0到对齐边界所需的大小'
# 'parameter %0 must have a complete type to use function %1 with the %2 calling convention'
H35B9EA765265: '参数%0必须具有完整的类型才能使用具有%2调用约定的函数%1'
# 'parameter %0 set but not used'
HB6BB1AF1B37E: '参数%0被设置但未使用'
# "parameter %0 was not declared, defaults to 'int'; ISO C99 and later do not support implicit int"
H41790618129F: "未声明参数%0，默认为'int'；ISO C99及后续版本不支持隐式int类型"
# "parameter '%0' is already documented"
HF9B7DF355428: '参数“%0”已被文档说明'
# "parameter '%0' not found in the function declaration"
HD7CC3BBE6634: '参数“%0”未在函数声明中找到'
# "parameter '%0' not in expected state when the function returns: expected '%1', observed '%2'"
H6EE5C60DD591: '参数“%0”在函数返回时未处于预期状态：预期“%1”，实际观察到“%2”'
# "parameter cannot be named '%select{global|unknown}0' while using 'lifetime_capture_by(%select{global|unknown}0)'"
H56545E5909EB: "在使用'lifetime_capture_by(%select{global|unknown}0)'时，参数不能命名为'%select{global|unknown}0'"
# 'parameter declarator cannot be qualified'
HEB6B080E8792: '参数声明符不能被限定'
# 'parameter kind mismatch; parameter is %select{not a|a}0 parameter pack'
H53E71EC45244: '参数类型不匹配；参数%select{不是|是}0参数包'
# 'parameter may not be qualified with an address space'
HFB13BD25F7E6: '参数不能使用地址空间进行限定'
# 'parameter name cannot have template arguments'
H4AE4E444760E: '参数名称不能带有模板实参'
# 'parameter named %0 is missing'
HE41EE5512047: '命名为%0的参数缺失'
# "parameter of %0 attribute must be 'id' when used on a typedef"
H95DFECC378EF: "当在typedef上使用%0属性时，其参数必须为'id'"
# 'parameter of %0 attribute must be a single name of an Objective-C %select{class|protocol}1'
H6E3911EE67CF: '%0属性的参数必须是Objective-C %select{类|协议}1的单一名字'
# 'parameter of %0 cannot have a default argument'
H9997206462BD: '%0的参数不能有默认参数值'
# "parameter of literal operator must have type 'unsigned long long', 'long double', 'char', 'wchar_t', 'char16_t', 'char32_t', or 'const char *'"
H18EF0BD0BEB6: "字面量运算符的参数类型必须为'unsigned long long'、'long double'、'char'、'wchar_t'、'char16_t'、'char32_t'或'const char *'"
# 'parameter of overloaded %0 cannot have a default argument'
H31033CF29CE2: '重载的%0参数不能有默认参数值'
# "parameter of overloaded post-%select{increment|decrement}1 operator must have type 'int' (not %0)"
H42A579D6B7B0: "重载的后置%select{递增|递减}1运算符的参数类型必须为'int'（而非%0）"
# 'parameter of overridden method is annotated with __attribute__((noescape))'
H1DC2A8B6BA41: '被覆盖的方法的参数被标记为__attribute__((noescape))'
# 'parameter of overriding method should be annotated with __attribute__((noescape))'
HD9E0E2EF69AC: '覆盖方法的参数应使用__attribute__((noescape))进行注解'
# "parameter of the 'collapse' clause"
H978C7D7597CF: "'collapse'子句的参数"
# 'parameter of type %0 is declared here'
HB0D7D36BAAD5: '类型为%0的参数在此处声明'
# 'parameter pack %0 declared here'
HF649CEA110D0: '参数包%0在此处声明'
# 'parameter pack cannot have a default argument'
H220429408CBD: '参数包不能有默认参数'
# 'parameter references not allowed in naked functions'
HE9A90AF8CF8F: '在naked函数中不允许使用参数引用'
# "parameterized class %0 already conforms to the protocols listed; did you forget a '*'?"
H0F239CE68A40: '参数化类%0已经符合列出的协议；是否漏掉了"*"?'
# 'parameters for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must have the same type%diff{ (found $ vs $)|}1,2'
H34C46A5FC53A: '默认的%select{<ERROR>|相等|三向|相等|关系}0比较运算符的参数必须具有相同的类型%diff{(发现$和$不同)|}1,2'
# "parent region for 'omp %select{cancellation point|cancel}0' construct cannot be nowait"
H10627ACFF3E1: "'omp %select{取消点|取消}0'结构的父区域不能是nowait"
# "parent region for 'omp %select{cancellation point|cancel}0' construct cannot be ordered"
H2F8AAD55F0CC: "'omp %select{取消点|取消}0'结构的父区域不能是ordered"
# "parent umbrella does not match: '%0' (provided) vs '%1' (found)"
H38C90C7CC02F: "父umbrella不匹配：提供的'%0'与发现的'%1'"
# "parent umbrella missing from %0: '%1'"
HCD77F7184E7F: "父umbrella在%0中缺失：'%1'"
# 'parentheses are required around macro argument containing braced initializer list'
H41A73FF55953: '包含花括号初始化列表的宏参数周围需要括号'
# 'parentheses are required around this expression in a requires clause'
H8DF4B4E0E5BD: '在requires子句中，此表达式周围需要括号'
# "parentheses must be omitted if %0 attribute's argument list is empty"
H90F4FD29334C: '如果%0属性的参数列表为空，则必须省略括号'
# 'parentheses were disambiguated as a function declaration'
H329AE7B68E6C: '括号被解析为函数声明'
# 'parentheses were disambiguated as redundant parentheses around declaration of variable named %0'
H911B6F6318F6: '括号被解析为变量%0声明周围的冗余括号'
# 'parenthesize the second argument to silence'
HB3431A17CC77: '将第二个参数用括号括起来以消除歧义'
# 'parenthesized initialization of a member array is a GNU extension'
HD07F8AE496CA: '成员数组的括号初始化是GNU扩展'
# 'partial ordering for explicit instantiation of %0 is ambiguous'
HE38D1382AB5B: '显式实例化%0的部分排序存在歧义'
# 'partial specialization cannot be declared as a friend'
HA147DDFF5AB9: '偏特化不能声明为友元'
# 'partial specialization matches %0'
HA30AC1C7D740: '偏特化与%0匹配'
# 'partial specialization of %0 does not use any of its template parameters'
H84CBC790F3FB: '%0的偏特化未使用其任何模板参数'
# 'pass -fsafe-buffer-usage-suggestions to receive code hardening suggestions'
HB623B7D5D4C9: '使用 -fsafe-buffer-usage-suggestions 选项以接收代码强化建议'
# 'passing %0-byte aligned argument to %1-byte aligned parameter %2%select{| of %4}3 may result in an unaligned pointer access'
H8E7373BFAB19: '传递%0字节对齐的参数给%1字节对齐的参数%2%select{| of %4}3可能导致未对齐指针访问'
# 'passing %select{address of|reference to}0 local temporary object to musttail function'
H185CAE78405D: '将局部临时对象的%select{地址|引用}0传递给musttail函数'
# "passing %select{an object that undergoes default argument promotion|an object of reference type|a parameter declared with the 'register' keyword}0 to 'va_start' has undefined behavior"
H71043E0BAFE6: "将%select{经过默认参数提升的对象|引用类型对象|用'register'关键字声明的参数}0传递给'va_start'会导致未定义行为"
# "passing '%0' format string where '%1' format string is expected"
HB0DCC631BCB0: "在期望'%1'格式字符串的位置传递了'%0'格式字符串"
# "passing a type argument as the first operand to '_Generic' is a C2y extension"
H9B0C1A1B2AAD: '将类型参数作为_Generic的第一个操作数传递是C2y扩展'
# "passing a type argument as the first operand to '_Generic' is incompatible with C standards before C2y"
H0B03D58A8538: '将类型参数作为_Generic的第一个操作数传递与C2y之前的C标准不兼容'
# 'passing address of %select{non-local|non-scalar}0 object to __autoreleasing parameter for write-back'
H8F97A19F11B3: '将%select{非局部|非标量}0对象的地址传递给__autoreleasing参数用于写回'
# 'passing argument to parameter %0 here'
H30E4C5FD05FE: '此处传递参数给参数%0'
# 'passing argument to parameter here'
HC7C3DD07B432: '此处传递参数给参数'
# 'passing arguments to %select{a function|%1}0 without a prototype is deprecated in all versions of C and is not supported in C23'
H192BBFFB4918: '向%select{函数|%1}0传递参数而不使用原型在所有C版本中已弃用，并且C23不支持'
# 'passing byval argument %0 with potentially incompatible alignment here'
H730F797EFCA9: '此处传递的byval参数%0具有可能不兼容的对齐方式'
# "passing no argument for the '...' parameter of a variadic macro is a C++20 extension"
H6D5DB0C5BBB6: "为可变参数宏的'...'参数不传递参数是C++20扩展"
# "passing no argument for the '...' parameter of a variadic macro is a C23 extension"
H0F0C361742D6: "为可变参数宏的'...'参数不传递参数是C23扩展"
# "passing no argument for the '...' parameter of a variadic macro is incompatible with C standards before C23"
HCA1A72FB669A: "为可变参数宏的'...'参数不传递参数与C23之前的C标准不兼容"
# "passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20"
H2B8F35860B3B: "为可变参数宏的'...'参数不传递参数与C++20之前的C++标准不兼容"
# 'passing non-generic address space pointer to %0 may cause dynamic conversion affecting performance'
HAEF068C749A4: '将地址空间非通用指针传递给%0可能导致影响性能的动态转换'
# "passing object of class type %0 through variadic %select{function|block|method|constructor}1%select{|; did you mean to call '%3'?}2"
H39C1EFFB876B: "通过可变%select{函数|块|方法|构造函数}1传递类类型%0的对象%select{|; 你是否想调用'%3'?}2"
# 'passing object of trivial but non-POD type %0 through variadic %select{function|block|method|constructor}1 is incompatible with C++98'
HD5D2FE67C0FC: '通过可变%select{函数|块|方法|构造函数}1传递平凡但非POD类型%0的对象与C++98不兼容'
# "passing only one argument to 'va_start' is incompatible with C standards before C23"
H0DFF95F6ABB1: "在C23之前的C标准中，向'va_start'仅传递一个参数是不兼容的"
# "passing pointer %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H9E268E19A549: "传递指针%1需要持有%0 %select{'%2'|'独占的%2'}3"
# "passing pointer to variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H0E1F82092409: "传递变量%1的指针需要持有%0 %select{'%2'|'独占的%2'}3"
# "passing the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HFB2B4F9A02B6: "通过引用传递%1所指的值需要持有%0 %select{'%2'|'独占的%2'}3"
# 'passing union across security boundary via %select{parameter %1|return value}0 may leak information'
HA1E50C08E561: '通过%select{参数%1|返回值}0传递联合体跨安全边界可能会泄露信息'
# "passing variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HB011E968C37B: "通过引用传递变量%1需要持有%0 %select{'%2'|'独占的%2'}3"
# "pasting formed '%0', an invalid preprocessing token"
H17B929BA26C6: "连接形成无效预处理标记'%0'"
# "pasting two '/' tokens into a '//' comment is a Microsoft extension"
HBFF0AAF786C4: "将两个'/'标记连接成'//'注释是微软扩展"
# 'performSelector may cause a leak because its selector is unknown'
H653C9447EE92: 'performSelector可能因选择器未知而导致内存泄漏'
# 'performSelector names a selector which retains the object'
HF51E4C8347B0: 'performSelector命名的会选择器会保留对象'
# 'performing pointer arithmetic on a null pointer has undefined behavior%select{| if the offset is nonzero}0'
HA288389E9F6A: '对空指针进行指针运算具有未定义行为%select{|如果偏移量非零}0'
# 'performing pointer subtraction with a null pointer %select{has|may have}0 undefined behavior'
HB725A707608F: '使用空指针%select{具有|可能具有}0未定义行为的指针减法'
# 'permutation index must be at least 1 and at most %0'
H0297CCE3F38F: '排列索引必须至少为1且至多%0'
# 'pipes packet types cannot be of reference type'
H354A6AC50D78: '管道数据包类型不能是引用类型'
# "place '...' %select{immediately before declared identifier|here}0 to declare a function parameter pack"
HD82CBB258C12: "在%select{声明的标识符前直接|此处}0放置'...'以声明函数参数包"
# 'place parentheses around comparison expression to evaluate it first'
H1021BF49A48F: '在比较表达式周围添加括号以优先计算它'
# 'place parentheses around the %0 expression to evaluate it first'
HD79F2195D659: "在'%0'表达式周围添加括号以优先计算它"
# "place parentheses around the '%0' expression to silence this warning"
H7195F835EC30: "在'%0'表达式周围添加括号以消除此警告"
# "place parentheses around the '?:' expression to evaluate it first"
H9605DB1A560A: "在'?:'表达式周围添加括号以先进行求值"
# 'place parentheses around the assignment to silence this warning'
HE705E4D071BD: '在赋值周围添加括号以消除此警告'
# 'place parentheses around the string literal to silence warning'
H876899527936: '在字符串字面量周围添加括号以消除警告'
# 'placeholder declared here'
H7E34AEC856E5: '占位符在此处声明'
# 'placeholder variables are a C++2c extension'
H4C0235C28642: '占位符变量是C++2c的扩展'
# 'placeholder variables are incompatible with C++ standards before C++2c'
H6BE10CEEDF1B: '占位符变量与C++2c之前的C++标准不兼容'
# 'placement new would change type of storage from %0 to %1'
H83FB1C107237: 'placement new会将存储类型从%0更改为%1'
# "plain '_Complex' requires a type specifier; assuming '_Complex double'"
HBC4E2F0D8FF6: "普通的'_Complex'需要类型说明符；假设为'_Complex double'"
# "platform does not match: '%0' (provided) vs '%1' (found)"
H5C64A2FB6312: "平台不匹配：提供的'%0'与检测到的'%1'"
# "please rebuild precompiled header '%0'"
HFBA0A20CA8AF: "请重新构建预编译头'%0'"
# 'pointer %0 declared here'
H22E4F3576FCE: '指针%0在此处声明'
# "pointer arguments to kernel functions must reside in '__global', '__constant' or '__local' address space"
HEE966568F6BF: "内核函数的指针参数必须位于'__global'、'__constant'或'__local'地址空间中"
# 'pointer cannot be cast to type %0'
H0546695B4A22: '指针不能转换为类型%0'
# 'pointer cannot be mapped along with a section derived from itself'
HAF06E92DEBA3: '指针不能与其派生的部分同时映射'
# 'pointer comparisons before C11 need to be between two complete or two incomplete types; %0 is %select{|in}2complete and %1 is %select{|in}3complete'
H4DB22EDB67C8: 'C11之前的指针比较需要在两种完整类型或两种不完整类型之间；%0是%select{|in}2complete，%1是%select{|in}3complete'
# "pointer to function type %0 may not be 'restrict' qualified"
H909D3E85FCFF: "指向函数类型%0的指针可能不能被'restrict'限定"
# 'pointer to type %0 is invalid in OpenCL'
HEF9B07C9C640: '类型%0的指针在OpenCL中无效'
# 'pointer type mismatch%diff{ ($ and $)|}0,1'
H8EAA8DFC686A: '指针类型不匹配%diff{ ($和$)|}0,1'
# 'pointer-to-member function type %0 can only be called on an %select{rvalue|lvalue}1'
H08EA28E0562A: '成员函数类型%0只能在%select{右值|左值}1上调用'
# 'pointer/integer type mismatch in conditional expression%diff{ ($ and $)|}0,1'
HC15C6EF198BF: '条件表达式中的指针/整数类型不匹配%diff{ ($和$)|}0,1'
# 'poisoning existing macro'
HDD8F2D4A6FAB: '毒化现有宏'
# 'position arguments in format strings start counting at 1 (not 0)'
HC64922328C30: '格式字符串中的位置参数从1（而非0）开始计数'
# "position-independent code requires '-mabicalls'"
H69FA922C5B49: "位置无关代码需要选项 '-mabicalls'"
# 'positional arguments are not supported by ISO C'
HE496161E3DDA: 'ISO C 不支持位置参数'
# 'possible misuse of comma operator here'
H0A8E98669706: '此处可能错误使用了逗号运算符'
# 'possible target for call'
H16BA315A6C23: '可能的调用目标'
# 'possible target of %select{indirect|asm}0 goto statement'
H03DE80F51E17: '%select{间接|asm}0 goto 语句的可能目标'
# 'postfix attributes are not allowed on Objective-C directives'
HA57AC12B1C85: '后缀属性不允许用于 Objective-C 指令'
# "postfix attributes are not allowed on Objective-C directives, place them in front of '%select{@interface|@protocol}0'"
H83C11CD38B50: "后缀属性不允许用于 Objective-C 指令，应将其置于 '%select{@interface|@protocol}0' 之前"
# 'potential performance regression from use of __builtin_expect(): annotation was correct on %0 of profiled executions'
HD6474E353C24: '使用 __builtin_expect() 可能导致性能倒退：在 %0 个已分析执行中，注解是正确的'
# 'pragma %0 requires a parenthesized string'
H25DF715FB71D: 'pragma %0 需要带括号的字符串'
# 'pragma %select{message|warning|error}0 requires parenthesized string'
H58AE415DBC7A: 'pragma %select{message|warning|error}0 需要带括号的字符串'
# 'pragma STDC FENV_ROUND is not supported'
HF7A928CE98B4: '不支持 pragma STDC FENV_ROUND'
# 'pragma comment requires parenthesized identifier and optional string'
HD6BA08D64805: 'pragma comment 需要带括号的标识符和可选字符串'
# 'pragma detect_mismatch is malformed; it requires two comma-separated string literals'
H82A7E617FBD6: 'pragma detect_mismatch 格式错误；需要两个用逗号分隔的字符串字面量'
# "pragma diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'"
HD2286608AABA: "pragma diagnostic 期望的参数是 'error'、'warning'、'ignored'、'fatal'、'push' 或 'pop'"
# 'pragma diagnostic expected option name (e.g. "-Wundef")'
HF5C6654FAE5F: 'pragma diagnostic 期望选项名称（例如 "-Wundef"）'
# 'pragma diagnostic pop could not pop, no matching push'
H6F8E683545E5: 'pragma diagnostic pop 无法弹出，因为没有对应的 push'
# "pragma float_control is malformed; use 'float_control({push|pop})' or 'float_control({precise|except}, {on|off} [,push])'"
HDD83603CAD05: "pragma float_control 格式错误；请使用 'float_control({push|pop})' 或 'float_control({precise|except}, {on|off} [,push])'"
# "pragma include_alias expected '%0'"
H01DD8237CC21: "pragma include_alias 期望的是 '%0'"
# 'pragma include_alias expected include filename'
H08BDBEAABFC9: 'pragma include_alias 期望包含的文件名'
# "pragma pop_macro could not pop '%0', no matching push_macro"
HF67398D54EBA: "无法弹出 '%0'，因为没有匹配的 push_macro 指令"
# "preceding '...' declares a function parameter pack"
HB271FF2CAE5F: "前面的 '...' 声明了一个函数参数包"
# "precompiled header '%0' was ignored because '%1' is not first '-include'"
H47051C658E08: "预编译头 '%0' 被忽略，因为 '%1' 不是第一个 '-include'"
# "precompiled header '%0' was ignored because it is not a clang PCH file"
HC110D52BBD02: "预编译头 '%0' 被忽略，因为它不是 Clang PCH 文件"
# "precompiled header directory '%0' was ignored because it contains no clang PCH files"
H3E91139CDF42: "预编译头目录 '%0' 被忽略，因为它不包含任何 Clang PCH 文件"
# 'predefined allocator cannot have traits specified'
H8666F51519BE: '预定义分配器不能指定特性'
# 'predefined identifier is only valid inside function'
HF82196FF10EA: '预定义标识符仅在函数内部有效'
# "predefined trait '%0' used here"
H55566D31A8B9: "此处使用了预定义特性 '%0'"
# 'predetermined as a firstprivate in a task construct here'
H405D7D760401: '在此任务构造中被预设为 firstprivate'
# 'prefer_list item must be a string literal or constant integral expression'
HCAFE9C287B6C: 'prefer_list 项必须是字符串字面量或常量整型表达式'
# 'prefix attribute must be followed by an interface, protocol, or implementation'
H129BA69DE7F2: '前缀属性必须后跟接口、协议或实现'
# 'prefix with the address-of operator to silence this warning'
H51278B3A983C: '使用地址取值运算符前缀以消除此警告'
# 'previous %select{template type|non-type template|template template}0 parameter%select{| pack}1 declared here'
HEDFC0D57E1AE: '之前的 %select{模板类型|非类型模板|模板模板}0 参数%select{| 包}1 在此处声明'
# 'previous %select{unmarked |}0overload of function is here'
HAE3E66A916BE: '之前的 %select{未标记 |}0 函数重载在此处'
# "previous '#pragma pack' directive that modifies alignment is here"
H39F3F82E0571: "修改对齐的前一个 '#pragma pack' 指令在此处"
# "previous '%0' directive used here"
HE7A8B08DD5DE: "前一个 '%0' 指令在此处使用"
# "previous 'critical' region starts here"
H3FBC82C6CFEF: "前一个 'critical' 区域从此处开始"
# 'previous allocator is specified here'
H065261987D15: '前一个分配器在此处指定'
# 'previous attribute is here'
H6E32F6609895: '前一个属性在此处'
# 'previous binding pack specified here'
H720F62C2E50B: '之前在这里指定的绑定包'
# 'previous call is here%select{; set to nil to indicate it cannot be called afterwards|}0'
HE8A56E8F5AF3: '之前的调用在这里%select{; 设置为nil以指示之后无法调用|}0'
# 'previous case defined here'
H67B17B33B89D: '之前在这里定义的case'
# 'previous clause is here'
HE9FAFB90DAE5: '之前在这里的子句'
# 'previous clause with directive name modifier specified here'
H59743B40EF38: '之前在这里指定的带有指令名称修饰符的子句'
# "previous command '%select{\\|@}0%1' (an alias of '\\%2') here"
HE969B475A653: '之前的命令“%select{\\|@}0%1”（别名“\\%2”的别名）在这里'
# "previous command '%select{\\|@}0%1' here"
H5B43AF8F451D: '之前的命令“%select{\\|@}0%1”在这里'
# 'previous declaration is here'
H9CAB5B6B1715: '之前的声明在这里'
# 'previous declaration of class template partial specialization %0 is here'
H8EF5BDE072C8: '类模板的部分特化%0的之前声明在这里'
# 'previous declaration of variable template partial specialization is here'
H5A936ED6E7F5: '变量模板的部分特化的之前声明在这里'
# 'previous default generic association is here'
H5A119A508D2B: '之前的默认通用关联在这里'
# 'previous default template argument defined here'
H828BBDD8C7F9: '之前在这里定义的默认模板参数'
# 'previous default template argument defined in module %0'
H2F92B57F5F02: '之前在模块%0中定义的默认模板参数'
# 'previous definition is here'
H0AC845A11A85: '之前的定义在这里'
# 'previous documentation'
H8053B03861AE: '之前的文档说明'
# 'previous equal key is here'
H916F7D758598: '之前在这里的等效键'
# 'previous explicit instantiation is here'
HCA86CACA9800: '之前的显式实例化在这里'
# 'previous expression is here'
H72EA4DC42083: '之前的表达式在这里'
# 'previous implicit declaration is here'
H2F8B22E01C4A: '之前的隐式声明在这里'
# 'previous inheritance model specified here'
HDD10F14D9687: '之前在这里指定的继承模型'
# 'previous initialization %select{|with side effects }0is here%select{| (side effects will not occur at run time)}0'
HFE059F4FA2A1: '之前的初始化%select{|带有副作用 }0在这里%select{|（副作用在运行时不会发生）}0'
# 'previous initialization for field %0 is here'
HEF0E98EA391B: '字段%0的先前初始化在这里'
# 'previous module declaration is here'
HD052ACC784A7: '之前的模块声明在这里'
# 'previous non-type template parameter with type %0 is here'
H5A88D83E2220: '类型为%0的先前非类型模板参数在这里'
# 'previous reference is here'
HEFAE6804D795: '之前的引用在这里'
# 'previous return statement is here'
H147041BC8FB0: '之前的返回语句在这里'
# 'previous statement is here'
H94AB14DFE365: '之前的语句在这里'
# 'previous template %select{declaration|template parameter}0 is here'
H94CA97347769: '之前的模板%select{声明|模板参数}0在这里'
# 'previous template specialization is here'
H0FDA24AE451B: '之前的模板特化在这里'
# 'previous use is here'
H39A31F8B143F: '之前的使用在这里'
# 'previous uuid specified here'
H8206D7044433: '之前指定的UUID在这里'
# "previously declared '%0' here"
H4ECE9D2CF70E: "之前在这里声明的'%0'"
# "previously declared '%1' here"
H6BFF38DE7EEF: "之前在这里声明的'%1'"
# 'previously declared as %0 here'
HEA5BCF07D9E2: '之前在这里被声明为%0'
# 'previously defined as an alias for %0'
HC8CE8DE52E3E: '之前被定义为%0的别名'
# 'previously defined here'
H0787B53F4571: '之前在这里定义'
# 'previously marked as task_reduction with different reduction operation'
HFE3CA309C947: '之前被标记为task_reduction但使用了不同的约简操作'
# 'previously referenced here'
H8ADE478F0E44: '之前在这里被引用'
# 'primary property declaration is implicitly strong while redeclaration in class extension is weak'
H331A66416F47: '主属性声明隐式为strong，而类扩展中的重新声明为weak'
# "private API notes file for module '%0' should be named '%0_private.apinotes', not '%1'"
HB68113D2F79A: "模块'%0'的私有API注释文件应命名为'%0_private.apinotes'，而非'%1'"
# 'private field %0 is not used'
H3584A3B50C2A: '私有字段 %0 未被使用'
# 'private module fragment begins here'
H3A617A73B3A6: '私有模块片段从这里开始'
# 'private module fragment declaration with no preceding module declaration'
H1202B7565A2E: '没有前置模块声明的私有模块片段声明'
# 'private module fragment in module implementation unit'
H48CE0D8A14BD: '模块实现单元中的私有模块片段'
# 'private module fragment redefined'
H1427CFAECC58: '私有模块片段被重新定义'
# "private submodule '%0' in private module map, expected top-level module"
HCB6CC643EA83: "私有模块映射中的私有子模块 '%0'，期望顶层模块"
# 'probability argument to __builtin_expect_with_probability is outside the range [0.0, 1.0]'
HFB32BCF3AB99: '传递给 __builtin_expect_with_probability 的概率参数超出 [0.0, 1.0] 范围'
# 'probability argument to __builtin_expect_with_probability must be constant floating-point expression'
H828E266CB5B1: '传递给 __builtin_expect_with_probability 的概率参数必须是常量浮点数表达式'
# 'profile data may be incomplete: of %0 function%s0, %1 %plural{1:has|:have}1 no data'
H8ACA9571B75F: '性能数据可能不完整：在 %0 个函数%s0 中，%1 %plural{1:没有|:没有}1 数据'
# 'profile data may be out of date: of %0 function%s0, %1 %plural{1:has|:have}1 mismatched data that will be ignored'
HBED3698588C8: '性能数据可能已过时：%0 个函数%s0 中有 %1 %plural{1:存在|:存在}1 不匹配的数据将被忽略'
# 'propagating dll attribute to %select{already instantiated|explicitly specialized}0 base class template without dll attribute is not supported'
H6A4E6175A865: '将dll属性传播到没有dll属性的基类模板%select{已实例化|显式特化}0不受支持'
# 'property %0 attempting to use instance variable %1 declared in super class %2'
HDDED40707D8D: '属性 %0 正在尝试使用在超类 %2 中声明的实例变量 %1'
# 'property %0 cannot be found in forward class object %1'
H503270AA1975: '在前向类对象 %1 中找不到属性 %0'
# 'property %0 declared with incompatible types in different translation units (%1 vs. %2)'
H2F559B93D7CB: '属性 %0 在不同的翻译单元中声明的类型不兼容（%1 与 %2）'
# 'property %0 found on object of type %1; did you mean to access it with the "." operator?'
H0A371D1A94C3: '在类型 %1 的对象上找到属性 %0；是否应使用“.”运算符访问它？'
# 'property %0 has a variably modified type'
H81C9932A69B3: '属性 %0 具有可变修改的类型'
# "property %0 is a class property; did you mean to access it with class '%1'?"
HFC5FD97AFD4C: '属性 %0 是类属性；是否应使用类 "%1" 访问它？'
# 'property %0 is already implemented'
H4ECC248CA95F: '属性 %0 已被实现'
# 'property %0 is declared %select{deprecated|unavailable|partial}1 here'
HC2D276377832: '属性 %0 在此处被声明为%select{已弃用|不可用|部分}1'
# 'property %0 is implemented with %select{@synthesize|@dynamic}1 here'
H43FFE47B4C6F: '属性 %0 在此处使用%select{@synthesize|@dynamic}1实现'
# 'property %0 is implemented with %select{@synthesize|@dynamic}1 in one translation but %select{@dynamic|@synthesize}1 in another translation unit'
H7C85E91BA02D: '属性 %0 在一个翻译单元中使用 %select{@synthesize|@dynamic}1 实现，但在另一个翻译单元中使用 %select{@dynamic|@synthesize}1'
# 'property %0 is synthesized to different ivars in different translation units (%1 vs. %2)'
HE49921A78EC2: '属性 %0 在不同的翻译单元中合成到不同的实例变量（%1 与 %2）'
# 'property %0 not found on object of type %1'
H2822C5946CF1: '类型 %1 的对象中未找到属性 %0'
# 'property %0 not found on object of type %1; did you mean %2?'
HBDBDE3E27B96: '类型 %1 的对象中未找到属性 %0；您是否是指 %2？'
# 'property %0 not found on object of type %1; did you mean to access instance variable %2?'
H8C5C6406F710: '类型 %1 的对象中未找到属性 %0；是否应访问实例变量 %2？'
# 'property %0 not found on object of type %1; did you mean to access property %2?'
H9C85D93EEE02: '类型 %1 的对象中未找到属性 %0；是否应访问属性 %2？'
# 'property %0 refers to an incomplete Objective-C class %1 (with no @interface available)'
H5BDCDB941EFA: '属性 %0 引用了一个不完整的 Objective-C 类 %1（没有可用的 @interface）'
# 'property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category'
HD9354003F0AB: '属性 %0 需要定义方法 %1 — 使用 @dynamic 或在此类别中提供方法实现'
# 'property %0 requires method %1 to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation'
HD343415F7FA6: '属性 %0 需要定义方法 %1 — 使用 @synthesize、@dynamic 或在此类实现中提供方法实现'
# "property %select{of type %1|with attribute '%1'|without attribute '%1'|with getter %1|with setter %1}0 was selected for synthesis"
HAD70544BC938: "选择了 %select{类型 %1 的属性|带有属性 '%1' 的属性|没有属性 '%1' 的属性|带有 getter %1 的属性|带有 setter %1 的属性}0 进行合成"
# 'property access is using %0 method which is deprecated'
HC446F861F2EE: '属性访问使用已弃用的 %0 方法'
# 'property access is using %0 method which is unavailable'
H61B587B99038: '属性访问使用不可用的 %0 方法'
# 'property access result unused - getters should not be used for side effects'
H1D3B4CAFB27A: '属性访问结果未使用 — 获取器不应用于副作用'
# 'property attribute in class extension does not match the primary class'
H928CE0C5C480: '类扩展中的属性属性与主类不匹配'
# "property attributes '%0' and '%1' are mutually exclusive"
H4A7BE0C59F5F: "属性属性 '%0' 和 '%1' 是互斥的"
# 'property cannot have array or function type %0'
HE68B6C09E364: '属性不能具有数组或函数类型 %0'
# 'property declaration cannot have a default member initializer'
H5272D8E5D57E: '属性声明不能有默认成员初始化器'
# "property declaration specifies '%0' accessor twice"
H0E68E4E4BA05: "属性声明指定了 '%0' 访问器两次"
# 'property declared as returning non-retained objects; getter returning retained objects'
H53034807D818: '该属性声明为返回非保留对象；获取器返回保留对象'
# 'property declared here'
H69D70856EBD1: '属性在此处声明'
# 'property declared in category %0 cannot be implemented in class implementation'
H04FE1B1065E1: '在类别%0中声明的属性不能在类实现中实现'
# 'property does not specify a getter or a putter'
HD0F5818FB6C8: '属性未指定getter或setter'
# "property follows Cocoa naming convention for returning 'owned' objects"
HEBB6CB98CE86: "属性遵循返回'拥有'对象的Cocoa命名约定"
# 'property has a previous declaration'
H28BB0E9D9F7A: '属性已有之前的声明'
# 'property implementation in a category with no category declaration'
HF42022DEA14A: '在无类别声明的类别中实现属性'
# 'property implementation must be in a class or category implementation'
HD59CD2B75162: '属性实现必须在类或类别实现中'
# 'property implementation must have its declaration in interface %0 or one of its extensions'
HFCF842D4EB86: '属性实现必须在其接口%0或其扩展之一中声明'
# 'property implementation must have its declaration in the category %0'
H761B0BB38838: '属性实现必须在其类别%0中声明'
# 'property is assumed atomic by default'
H2882A0CD4FD8: '属性默认假设为原子性'
# 'property is assumed atomic when auto-synthesizing the property'
HC5E58A6AB217: '在自动合成属性时，默认假设属性为原子性'
# 'property is synthesized to ivar %0 here'
H7E91E310D399: '属性在此处被合成到实例变量%0'
# 'property name cannot be a bit-field'
H8E1C0549C2E5: '属性名称不能是位字段'
# 'property requires fields to be named'
H9C4AAD2700BB: '属性需要命名字段'
# 'property should be changed to be readwrite'
H32DF2D479322: '属性应改为readwrite'
# 'property synthesized here'
H0BB379E6C96C: '属性在此处被合成'
# 'property type %0 is incompatible with type %1 inherited from %2'
HDE3695134102: '属性类型%0与从%2继承的类型%1不兼容'
# "property with '%0' attribute must be of object type"
H44EF18C35C26: '具有"%0"属性的属性必须是对象类型'
# 'protected %select{constructor|destructor}0 can only be used to %select{construct|destroy}0 a base class subobject'
H8490EFD629C0: '受保护的%select{构造函数|析构函数}0只能用于%select{构造|销毁}0基类子对象'
# 'protocol %0 has no definition'
H3F201B2D647A: '协议%0没有定义'
# 'protocol has circular dependency'
HBFCB55FB9C5B: '协议存在循环依赖'
# "protocol has no object type specified; defaults to qualified 'id'"
H79AE64D3788F: "协议未指定对象类型；默认使用限定的 'id'"
# 'protocol is declared here'
H63C66770E070: '协议在此处声明'
# 'protocol method is expected to return an instance of the implementing class, but is declared to return %0'
HCECBCE2ED619: '协议方法预期返回实现类的实例，但声明返回 %0'
# 'protocol method is here'
H850DBE7D30DB: '协议方法在此处'
# 'protocol qualifiers must precede type arguments'
HE1585F9267E6: '协议限定符必须在类型参数之前'
# "provided host compiler IR file '%0' is required to generate code for OpenMP target regions but cannot be found"
H4ECB10C5BABB: "提供的主机编译器IR文件 '%0' 用于生成OpenMP目标区域代码，但未找到"
# 'pseudo-destructor call is not permitted in constant expressions until C++20'
HFC660C022DFD: '在C++20之前不允许在常量表达式中使用伪析构函数调用'
# 'pseudo-destructor destroys object of type %0 with inconsistently-qualified type %1'
HFC3306882505: '伪析构函数以不一致限定的类型 %1 销毁类型 %0 的对象'
# 'pseudo-destructors on type void are a Microsoft extension'
H6C76EC18D3A0: 'void类型的伪析构函数是Microsoft扩展'
# "public framework header includes private framework header '%0'"
H7F0AEF01704E: "公共框架头文件包含私有框架头文件 '%0'"
# 'pure virtual function %q0 called'
H3187DE144A64: '调用了纯虚函数 %q0'
# 'put the semicolon on a separate line to silence this warning'
HD2A85AED0A2F: '将分号放在单独的一行以消除此警告'
# "putter for property must be specified as 'put', not 'set'"
H65FA70517FA4: "属性的设置器必须指定为 'put'，而不是 'set'"
# 'qualified call to %0::%1 is treated as a virtual call to %1 due to -fapple-kext'
HAEBB9D60FCD1: '由于 -fapple-kext，对 %0::%1 的限定调用被视为对 %1 的虚函数调用'
# 'qualified destructor name only found in lexical scope; omit the qualifier to find this type name by unqualified lookup'
H95040EDE1833: '限定的析构函数名称仅在词法作用域中找到；省略限定符以通过非限定查找查找该类型名称'
# 'qualified member access refers to a member in %0'
H69C8244E4885: '限定的成员访问引用 %0 中的成员'
# 'qualified module name can only be used to define modules at the top level'
HCDFABF1A81DD: '限定的模块名称只能用于在顶层定义模块'
# 'qualified name refers into a specialization of %select{function|variable}0 template %1'
H4C7D694E4A70: '限定的名称引用 %select{函数|变量}0模板%1 的特化'
# 'qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context'
H08AE31B94F15: '在此上下文中，对 %0 的限定引用是构造函数名称而非 %select{模板名称|类型}1'
# "qualifier 'const' is needed for variables in address space '%0'"
HADB69D493623: "地址空间 '%0' 中的变量需要 'const' 限定符"
# 'qualifier in explicit instantiation of %q0 requires a template-id (a typedef is not permitted)'
HB21409C3C5FB: '显式实例化%q0中的限定符需要模板标识符（不允许使用typedef）'
# 'qualifiers after comma in declarator list are ignored'
H09D49C9D12E0: '声明符列表中的逗号后限定符将被忽略'
# 'qualify call to silence this warning'
HDB3D8B807347: '使用限定调用以消除此警告'
# "range-based 'for' statement uses ':', not '='"
HC53E3757D97C: "基于范围的'for'语句使用':'而非'='"
# 'range-based for loop has empty body'
H2C4FFAA3CE47: '基于范围的for循环具有空主体'
# 'range-based for loop initialization statements are a C++20 extension'
H77FF5523C4B8: '基于范围的for循环初始化语句是C++20扩展'
# 'range-based for loop initialization statements are incompatible with C++ standards before C++20'
H529EE263FDB4: '基于范围的for循环初始化语句与C++20之前的C++标准不兼容'
# 'range-based for loop is a C++11 extension'
HE56D92957A6D: '基于范围的for循环是C++11扩展'
# 'range-based for loop is incompatible with C++98'
H2229A30F511E: '基于范围的for循环与C++98不兼容'
# 'range-based for loop requires type for loop variable'
H07E32C6E46BC: '基于范围的for循环需要为循环变量指定类型'
# 'raw string delimiter longer than 16 characters; use PREFIX( )PREFIX to delimit raw string'
H00B2DC6A7B32: '原始字符串分隔符超过16个字符；请使用PREFIX( )PREFIX限定原始字符串'
# 'raw string literals are incompatible with C++98'
H1C93D8A83CA2: '原始字符串文字与C++98不兼容'
# 'raw string missing terminating delimiter )%0"'
H7FD087037BE3: '缺少原始字符串的终止分隔符)%0"'
# "re-exported libraries do not match: '%0' (provided) vs '%1' (found)"
H6C320DEC171A: "重新导出的库不匹配：'%0'（提供）与'%1'（找到）"
# "re-exported library missing from %0: '%1'"
H552D4BA598A3: "'%1'未包含在%0的重新导出库中"
# 'read of incomplete type %0 is not allowed in a constant expression'
HCA641211FEEB: '不完全类型%0的读取操作不允许出现在常量表达式中'
# 'read of non-const variable %0 is not allowed in a constant expression'
HD99D6E4F37A4: '非常量变量%0的读取操作不允许出现在常量表达式中'
# 'read of non-constexpr variable %0 is not allowed in a constant expression'
HF3D92222C519: '非constexpr变量%0的读取操作不允许出现在常量表达式中'
# 'read of variable %0 of non-integral, non-enumeration type %1 is not allowed in a constant expression'
H33BFBE7CF01D: '非整型、非枚举类型%1的变量%0的读取操作不允许出现在常量表达式中'
# "readonly IBOutlet property %0 when auto-synthesized may not work correctly with 'nib' loader"
H582EA0DF024A: "自动合成时只读IBOutlet属性%0可能无法与'nib'加载器正确配合工作"
# 'received warning after diagnostic serialization teardown was underway: %0'
H60ECB032353D: '在诊断序列化拆卸过程中收到警告：%0'
# 'receiver %0 for class message is a forward declaration'
HAE87B957CEBD: '类消息的接收者%0是一个前向声明'
# 'receiver %0 is a forward class and corresponding @interface may not exist'
H2EFCADD231BF: '接收者%0是一个前向类，对应的@interface可能不存在'
# 'receiver expression is here'
H16AA23E5E187: '接收者表达式在此处'
# 'receiver is instance of class declared here'
H063C50E49E8E: '接收者是此处声明的类的实例'
# "receiver is treated with 'id' type for purpose of method lookup"
H23B037191711: "接收者在方法查找时被当作'id'类型处理"
# 'receiver type %0 for instance message is a forward declaration'
H4107B7B01A42: '实例消息的接收者类型%0是一个前向声明'
# "receiver type %0 is not 'id' or interface pointer, consider casting it to 'id'"
HC44380DEE815: "接收者类型%0不是'id'或接口指针，建议将其转换为'id'"
# 'receiver type %0 is not an Objective-C class'
HDF1E1AF5B7B2: '接收者类型%0不是Objective-C类'
# 'recursive evaluation of default argument'
H9D22EE24805A: '默认参数的递归求值'
# 'recursive template instantiation exceeded maximum depth of %0'
H9F7DB4D308D0: '递归模板实例化超过最大深度%0'
# "redeclaration cannot add 'loader_uninitialized' attribute"
H70EFB9FBF448: "重新声明不能添加'loader_uninitialized'属性"
# 'redeclaration has different alignment requirement (%1 vs %0)'
H2965974DE860: '重新声明的对齐要求不同（%1 vs %0）'
# "redeclaration of %0 must %select{not |}1have the 'overloadable' attribute"
H9C609286F3D1: "%0的重新声明必须%select{不具有|}1'overloadable'属性"
# 'redeclaration of %0 with a different type%diff{: $ vs $|}1,2'
HEB05B74B4F52: '%0的重新声明具有不同类型%diff{：$ vs $|}1,2'
# 'redeclaration of %q0 cannot add %q1 attribute'
H437273BF8230: '%q0的重新声明不能添加%q1属性'
# 'redeclaration of %q0 should not add %q1 attribute'
HBC3EEF68F79F: '%q0的重新声明不应添加%q1属性'
# "redeclaration of C++ built-in type 'bool'"
H4DE1B64751F8: "C++内置类型'bool'的重新声明"
# 'redeclaration of already-defined enum %0 is a GNU extension'
H3B72AE37DEEE: '已定义的枚举%0的重新声明是GNU扩展'
# 'redeclaration of deduction guide'
H6C137FDA5914: '推导指引的重新声明'
# 'redeclaration of method parameter %0'
H0D9F6CE9B2EA: '方法参数%0的重复声明'
# 'redeclaration of type parameter %0'
HC29DAC039CAB: '类型参数%0的重复声明'
# 'redeclaration of using declaration'
H96E43918A485: 'using声明的重复声明'
# 'redeclaration of using-enum declaration'
H7EA3B309B6C8: 'using-enum声明的重复声明'
# 'redeclaring non-static %0 as static is a Microsoft extension'
H853738CC6C0D: '将非静态%0作为静态重新声明是Microsoft扩展'
# 'redefining builtin macro'
H6021415EA4BB: '重定义内置宏'
# 'redefinition of %0'
HB70C986DD184: '%0的重新定义'
# 'redefinition of %0 as an alias for a different namespace'
H97345A757B2F: '将%0重新定义为不同命名空间的别名'
# 'redefinition of %0 as different kind of symbol'
H9380CBD04275: '将%0重新定义为不同类型符号'
# 'redefinition of %0 will not be visible outside of this function'
H6605A7137B7E: '%0的重新定义在函数外部不可见'
# 'redefinition of %0 with a different type%diff{: $ vs $|}1,2'
HB1C0A119B95E: '使用不同的类型%diff{: $ vs $|}1,2重新定义%0'
# 'redefinition of %select{typedef|type alias}0 for variably-modified type %1'
HB599B51A5F4D: '为可变修改类型%1重定义%select{typedef|类型别名}0'
# "redefinition of a 'extern inline' function %0 is not supported in %select{C99 mode|C++}1"
HF158368144B8: "在%select{C99模式|C++}1中不支持对%0的'extern inline'函数的重新定义"
# 'redefinition of concept %0 with different template parameters or requirements'
H4C4283523181: '使用不同的模板参数或要求重新定义概念%0'
# 'redefinition of default argument'
H6507C3F7227D: '默认参数的重新定义'
# 'redefinition of enumerator %0'
H1EE462BB5E46: '枚举项%0的重新定义'
# 'redefinition of forward class %0 of a typedef name of an object type is ignored'
H06040CF8C316: '将对象类型typedef名称的前向类%0重新定义被忽略'
# 'redefinition of inferred submodule'
H43BB40E423BF: '推断子模块的重新定义'
# 'redefinition of label %0'
HD4F4A928D72C: '标签%0的重新定义'
# 'redefinition of method parameter %0'
HE18AEF27C9A1: '方法参数%0的重新定义'
# "redefinition of module '%0'"
H6249FB58D003: "模块 '%0' 的重新定义"
# 'redefinition of parameter %0'
H88BE534E3F7A: '参数 %0 的重新定义'
# 'redefinition of typedef %0 is a C11 feature'
H8B88EC5F6F5C: 'typedef %0 的重新定义是 C11 特性'
# 'redefinition of user-defined mapper for type %0 with name %1'
HADE614C371DA: '类型 %0 具有名称 %1 的用户自定义映射器的重新定义'
# 'redefinition of user-defined reduction for type %0'
H4B307482E8CD: '类型 %0 的用户自定义规约的重新定义'
# "reduction type cannot be %select{qualified with 'const', 'volatile' or 'restrict'|a function|a reference|an array}0 type"
H2D2C74F27FDF: "规约类型不能是 %select{带有 'const'、'volatile' 或 'restrict' 限定符|函数|引用|数组}0 类型"
# 'reduction variables may not be accessed in an explicit task'
H233496630504: '显式任务中不能访问规约变量'
# "redundant #include of module '%0' appears within %1"
H3B45950DD3A3: "模块 '%0' 的冗余 #include 出现在 %1 内部"
# 'redundant %0 availability change; only the last specified change will be used'
HE2065BD86C26: '冗余的 %0 可用性更改；仅使用最后指定的更改'
# "redundant 'sycl_kernel_entry_point' attribute"
H89B952CF4093: "冗余的 'sycl_kernel_entry_point' 属性"
# "redundant attribute subject matcher sub-rule '%0'; '%1' already matches those declarations"
HE12FF717092C: "冗余的属性主题匹配子规则 '%0'；'%1' 已经匹配这些声明"
# 'redundant move in return statement'
HC34A9F2066D1: '返回语句中的冗余移动'
# 'redundant parentheses surrounding address non-type template argument are incompatible with C++98'
HFE070BE5634C: '地址非类型模板参数周围的冗余括号与 C++98 不兼容'
# 'redundant parentheses surrounding declarator'
H47E8307AF60E: '声明符周围的冗余括号'
# "ref-qualifier '%select{&&|&}0' is not allowed on a constructor"
H5FB2827C1F13: "引用限定符 '%select{&&|&}0' 不允许用于构造函数"
# "ref-qualifier '%select{&&|&}0' is not allowed on a destructor"
H0C7698A4B274: "引用限定符 '%select{&&|&}0' 不允许用于析构函数"
# "ref-qualifier '&&' is not allowed on a defaulted comparison operator"
HE95322EAF78E: "默认的比较运算符不允许使用右值引用限定符 '&&'"
# 'refactoring action cannot be initiated without a selection'
H24ED847BB22A: '在没有选择的情况下无法启动重构操作'
# 'reference %0 is not yet bound to a value when used here'
HF3E8D22129FD: '此处使用的引用 %0 尚未绑定到值'
# 'reference %0 is not yet bound to a value when used within its own initialization'
HB4996BB1A27E: '在自身初始化中使用时，引用 %0 尚未绑定到值'
# 'reference %diff{to %select{type|incomplete type}1 $ could not bind to an %select{rvalue|lvalue}2 of type $|could not bind to %select{rvalue|lvalue}2 of incompatible type}0,3'
HFAC2C332E9F4: '引用 %diff{到 %select{类型|不完整类型}1 $ 无法绑定到 %select{右值|左值}2 类型的 $|无法绑定到类型不兼容的 %select{右值|左值}2}0,3'
# 'reference binding of non-type template parameter %diff{of type $ to template argument of type $|to template argument}0,1 ignores qualifiers'
H093001BBE364: '非类型模板参数 %diff{类型 $ 到模板实参类型 $ 的引用绑定|到模板实参}0,1 忽略了限定符'
# 'reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0'
H136F139EE8E6: '在符合C++标准的代码中，无法将引用绑定到空指针的解引用结果；比较可能被假定始终求值为 %select{true|false}0'
# 'reference cannot be bound to dereferenced null pointer in well-defined C++ code; pointer may be assumed to always convert to true'
H5320A7915E7F: '在符合C++标准的代码中，无法将引用绑定到空指针的解引用结果；该指针可能被假定始终转换为 true'
# 'reference cannot be initialized with multiple values'
HE7DB5FCEC436: '引用无法用多个值初始化'
# 'reference cannot bind to bit-field in converted constant expression'
HF5063530D4A6: '引用无法绑定到已转换常量表达式中的位域'
# 'reference dynamic_cast failed: %select{static type %1 of operand is a non-public base class of dynamic type %2|dynamic type %2 of operand does not have a base class of type %3|%3 is an ambiguous base class of dynamic type %2 of operand|%3 is a non-public base class of dynamic type %2 of operand}0'
H4859449FAD67: '引用动态转换失败：%select{操作数的静态类型 %1 是动态类型 %2 的非公开基类|操作数的动态类型 %2 没有类型 %3 的基类|%3 是操作数动态类型 %2 的二义性基类|%3 是操作数动态类型 %2 的非公开基类}0'
# 'reference initialization of type %0 with initializer of type %1 is ambiguous'
HB988A3E86777: '类型 %0 的引用初始化与类型 %1 的初始化器存在歧义'
# 'reference initialized from initializer list is incompatible with C++98'
HCD4C182EF998: '用初始化列表初始化的引用与C++98不兼容'
# 'reference member of type %0 uninitialized'
HC2805DCE0AFC: '类型 %0 的引用成员未初始化'
# 'reference of type %0 cannot bind to a temporary object because of address space mismatch'
HF0C3B633C49A: '由于地址空间不匹配，类型 %0 的引用无法绑定到临时对象'
# 'reference qualifiers on functions are a C++11 extension'
H41B9EC19F32B: '函数上的引用限定符是C++11扩展'
# 'reference qualifiers on functions are incompatible with C++98'
HF044E58F9C25: '函数上的引用限定符与C++98不兼容'
# 'reference to %0 is ambiguous'
H97A6825DEB56: '对 %0 的引用存在歧义'
# 'reference to %select{__device__|__global__|__host__|__host__ __device__}0 %select{function|variable}1 %2 in %select{__device__|__global__|__host__|__host__ __device__}3 function'
H43094BC1789F: '在 %select{__device__|__global__|__host__|__host__ __device__}3 函数中引用 %select{__device__|__global__|__host__|__host__ __device__}0 %select{函数|变量}1 %2'
# 'reference to %select{__device__|__global__|__host__|__host__ __device__}0 function %1 in global initializer'
H76762B8F478F: '在全局初始化器中引用 %select{__device__|__global__|__host__|__host__ __device__}0 函数 %1'
# 'reference to %select{destructor|pseudo-destructor}0 must be called%select{|; did you mean to call it with no arguments?}1'
H3484C551C20A: '必须调用 %select{析构函数|伪析构函数}0%select{|；是否需要以无参数形式调用？}1'
# 'reference to %select{overloaded|multiversioned}1 function could not be resolved; did you mean to call it%select{| with no arguments}0?'
HA7DE06C12730: '无法解析对 %select{重载|多版本}1 函数的引用；是否需要%select{|以无参数形式}0调用它？'
# "reference to a %select{bit-field|vector element|global register variable}0 in asm %select{input|output}1 with a memory constraint '%2'"
HCCFE4F550EEB: "在asm %select{输入|输出}1 约束 '%2' 中引用 %select{位域|向量元素|全局寄存器变量}0"
# "reference to enumeration must use 'enum' not 'enum %select{struct|class}0'"
HDC33545DFD9E: "枚举引用必须使用 'enum' 而非 'enum %select{struct|class}0'"
# 'reference to local %select{variable|binding}1 %0 declared in enclosing %select{%3|block literal|lambda expression|context}2'
H9B72122A433C: '对局部 %select{变量|绑定项}1 %0 的引用，该变量在包含的 %select{%3|块字面量|lambda表达式|上下文}2 中声明'
# "reference to marker '%0' is ambiguous"
HD452BD6D3FB0: "对标记 '%0' 的引用存在歧义"
# 'reference to non-static member function must be called%select{|; did you mean to call it with no arguments?}0'
H472EE5EB17CD: '对非静态成员函数的引用必须调用%select{|; 是否应以无参数调用？}0'
# 'reference to type %0 cannot bind to an initializer list'
H9194F3CD2BD5: '类型 %0 的引用无法绑定到初始化列表'
# 'reference to type %0 requires an initializer'
HD97076E9024C: '类型 %0 的引用需要初始化'
# 'reference to unresolved using declaration'
H4256A6DE4B09: '未解析的 using 声明引用'
# 'referenced %0 is declared here'
HE1EBB7B8DBAD: '被引用的 %0 在此处声明'
# 'referenced member %0 is declared here'
H8DB9210452D3: '被引用的成员 %0 在此处声明'
# "referring to 'main' within an expression is a Clang extension"
H5EC3F4017EE7: "'main' 在表达式中被引用是 Clang 扩展特性"
# "region cannot be%select{| closely}0 nested inside '%1' region%select{|; perhaps you forget to enclose 'omp %3' directive into a parallel region?|; perhaps you forget to enclose 'omp %3' directive into a for or a parallel for region with 'ordered' clause?|; perhaps you forget to enclose 'omp %3' directive into a target region?|; perhaps you forget to enclose 'omp %3' directive into a teams region?|; perhaps you forget to enclose 'omp %3' directive into a for, simd, for simd, parallel for, or parallel for simd region?}2"
H9F4A9870BA07: "区域不能%select{|紧密}0 嵌套在 '%1' 区域内%select{|; 是否忘记将 'omp %3' 指令包含在并行区域中？|; 是否忘记将 'omp %3' 指令包含在带有 'ordered' 子句的 for 或并行 for 区域中？|; 是否忘记将 'omp %3' 指令包含在目标区域中？|; 是否忘记将 'omp %3' 指令包含在 teams 区域中？|; 是否忘记将 'omp %3' 指令包含在 for、simd、for simd、并行 for 或并行 for simd 区域中？}2"
# "register '%0' unsuitable for global register variables on this target"
HAC3AEFE8413B: "寄存器 '%0' 不适用于此目标的全局寄存器变量"
# 'register number should be an integer'
H932EE02D1B8E: '寄存器编号必须是整数'
# 'register space cannot be specified on global constants'
H7D24E3150A81: '全局常量不能指定寄存器空间'
# 'reimplementation of category %1 for class %0'
H30BD90819E63: '为类 %0 重新实现类别 %1'
# 'reimplementation of class %0'
HD4142B86FCD9: '重新实现类 %0'
# 'reinterpret_cast cannot resolve overloaded function %0 to type %1'
H60D5F589023C: 'reinterpret_cast 无法将重载函数 %0 转换为类型 %1'
# 'reinterpret_cast from %0 to %1 has undefined behavior'
H1A1328A6B1E4: '将 %0 转换为 %1 的 reinterpret_cast 具有未定义行为'
# 'reinterpret_cast of a %0 to %1 needs its address, which is not allowed'
H8633F993884D: '将 %0 转换为 %1 的 reinterpret_cast 需要其地址，但这是不允许的'
# "releasing %0 '%1' that was not held"
HD16686A7FEA7: "释放未持有的 %0 '%1'"
# "releasing %0 '%1' using %select{shared|exclusive}2 access, expected %select{shared|exclusive}3 access"
H2106963D41B0: "使用 %select{共享|独占}2 访问模式释放 %0 '%1'，预期应使用 %select{共享|独占}3 访问模式"
# 'remainder by zero in preprocessor expression'
HE098B5222CAD: '预处理表达式中的除零余数'
# 'remaining %0 candidate%s0 omitted; pass -fshow-overloads=all to show them'
HD0784BB8E50F: '剩余 %0 个候选%s0 被省略；添加 -fshow-overloads=all 参数可显示所有'
# "remove '_Noreturn'"
H4CD6C2426BE8: '移除 "_Noreturn"'
# "remove 'enum%select{| struct| class}0' to befriend an enum"
H9CF5F9198489: '移除 "enum%select{| struct| class}0" 以与枚举建立友元关系'
# "remove 'u8' prefix to avoid a change of behavior; Clang encodes unprefixed narrow string literals as UTF-8"
H40BFCE51D12C: '移除 "u8" 前缀以避免行为变化；Clang 将无前缀窄字符串字面量编码为 UTF-8'
# 'remove call to max function and unsigned zero argument'
H746EE2CAAC37: '移除对 max 函数的调用和无符号零参数'
# 'remove constant to silence this warning'
H8233E14B9765: '移除常量以消除此警告'
# 'remove extraneous parentheses around the comparison to silence this warning'
H7C576B6A85C7: '移除外层比较中的冗余括号以消除此警告'
# 'remove parentheses to declare a variable'
H29AB7F8F0D04: '移除括号以声明变量'
# 'remove parentheses to silence this warning'
HBB1C1AF59745: '移除括号以消除此警告'
# 'remove std::move call here'
H87B3A4171A2A: '移除此处的 std::move 调用'
# "remove the %select{'%1' if its condition|condition if it}0 is always %select{false|true}2"
HE5C66C3841AD: '移除 %select{"%1" 如果其条件|条件如果它}0 始终为 %select{false|true}2'
# "remove the call to '%0' since unsigned values cannot be negative"
H3BE7257796E7: '移除对 "%0" 的调用，因为无符号值无法为负'
# "rename '%0' to ensure it can be found by name"
H730151DC5720: '将 "%0" 重命名为确保可以通过名称找到'
# "repeated RISC-V 'interrupt' attribute"
HE9564BE7AF0F: '重复的 RISC-V "interrupt" 属性'
# "repeated RISC-V 'interrupt' attribute is here"
H2C65B1A1835B: '重复的 RISC-V "interrupt" 属性在此处'
# 'repeated evaluation of the same literal expression can produce different objects'
H816EF14DCA64: '同一字面量表达式的重复求值可能导致不同对象'
# "replace 'default' with 'delete'"
H6143A5F8A323: '将 "default" 替换为 "delete"'
# "replace expression with '%0' %select{|or use 'xor' instead of '^' }1to silence this warning"
H8BD6D24EAB4A: '将表达式替换为 "%0" %select{|或使用 "xor" 而不是 "^" }1以消除此警告'
# 'replace parentheses with an initializer to declare a variable'
H1CB1AEAC6164: '移除括号并使用初始化器以声明变量'
# "replacement function %0 cannot be declared 'inline'"
H8E774898376D: "替换函数%0不能声明为'inline'"
# "requested 'init_priority' %0 is reserved for internal use"
H2E025E570ED5: "请求的'init_priority' %0保留用于内部使用"
# 'requested alignment %0 is not a positive power of two'
H9C01C430B004: '请求的对齐值%0不是正的2的幂次方'
# 'requested alignment is dependent but declaration is not dependent'
H9D546DA38E42: '请求的对齐依赖于模板参数，但声明本身不依赖于模板参数'
# 'requested alignment is less than minimum alignment of %1 for type %0'
H9E0857E89F1F: '请求的对齐值小于类型%0的最小对齐值%1'
# 'requested alignment is not a power of 2'
HC6B6240D895B: '请求的对齐值不是2的幂次方'
# 'requested alignment must be %0 bytes or smaller'
H7B9D334BA24B: '请求的对齐值必须为%0字节或更小'
# 'requested alignment must be %0 bytes or smaller; maximum alignment assumed'
HCDB68D900AC4: '请求的对齐值必须为%0字节或更小；假设最大对齐'
# 'requested alignment must be %0 or greater'
H097A66E5C9B7: '请求的对齐值必须为%0或更大'
# 'requested alignment must be %0 or less for type %1; %2 is invalid'
H6B97FB634040: '类型%1的请求对齐值必须为%0或更小；%2无效'
# 'requested alignment must be %0 or smaller'
HEC3786C66ADB: '请求的对齐值必须为%0或更小'
# 'requested shift is a vector of type %0 but the first operand is not a vector (%1)'
H149741EFCCA5: '请求的移位是一个类型为%0的向量，但第一个操作数不是向量（%1）'
# 'required alignment of type %0 (%1 bytes) is larger than the supported alignment of C++ exception objects on this target (%2 bytes)'
HFFCA5AAB79EE: '类型%0的必需对齐值（%1字节）大于此目标支持的C++异常对象的最大对齐值（%2字节）'
# "required by %select{'require_constant_initialization' attribute|'constinit' specifier}0 here"
H669C2D015B6E: '由%select{require_constant_initialization属性|constinit说明符}0在此处要求'
# 'requires clause differs in template redeclaration'
H3C91EEDA34FA: '模板重新声明中的requires子句不同'
# "requires expression in requirement body; did you intend to place it in a nested requirement? (add another 'requires' before the expression)"
H818E1323CB5B: "在要求体中使用requires表达式；是否应将其置于嵌套要求中？（在表达式前添加另一个'requires'）"
# "reserved locator 'omp_all_memory' cannot be specified more than once"
HBB5542941955: "保留的定位符'omp_all_memory'不能指定多次"
# "reserved locator 'omp_all_memory' requires 'out' or 'inout' dependency types"
H98614BF4F5B5: "保留的定位符'omp_all_memory'需要依赖类型为'out'或'inout'"
# 'restrict requires a pointer or reference'
H044B0871CB3F: 'restrict需要指针或引用'
# 'restrict requires a pointer or reference (%0 is invalid)'
HB4AA3977DC42: 'restrict需要指针或引用（%0无效）'
# "result argument to %select{overflow builtin|checked integer operation}0 must be a pointer to a non-const integer type %select{|other than plain 'char', 'bool', bit-precise, or an enumeration }0(%1 invalid)"
HD81ECBB4661A: "传给%select{溢出内置函数|有符号整数运算}0的result参数必须是指向非const整数类型的指针%select{|而不是普通的'char'、'bool'、精确位数或枚举类型}0（%1无效）"
# "result of '%0' is %1; did you mean '%2' (%3)?"
H369683737B3D: "'%0'的结果是%1；是否是指'%2' (%3)？"
# "result of '%0' is %1; did you mean '%2'?"
H1B6516041439: "'%0'的结果是%1；是否是指'%2'？"
# "result of '%0' is %1; did you mean exponentiation?"
H6BDF285BA0FF: "'%0'的结果是%1；是否是指指数运算？"
# 'result of comparison %select{%3|%1}0 %2 %select{%1|%3}0 is always %4'
H3D76D2CD2831: '%select{%3|%1}0 %2 %select{%1|%3}0的比较结果始终为%4'
# 'result of comparison against %select{a string literal|@encode}0 is unspecified (use an explicit string comparison function instead)'
H42F5B6822163: '与%select{字符串字面量|@encode}0的比较结果未指定（请改用显式字符串比较函数）'
# 'result of comparison of %select{%3|char expression}0 %2 %select{char expression|%3}0 is always %4, since char is interpreted as unsigned'
H2652DE195D69: '比较%select{%3|字符表达式}0 %2 %select{字符表达式|%3}0的结果始终为%4，因为char被视为无符号类型'
# 'result of comparison of %select{%3|unsigned enum expression}0 %2 %select{unsigned enum expression|%3}0 is always %4'
H86DA5A0E3154: '比较%select{%3|无符号枚举表达式}0 %2 %select{无符号枚举表达式|%3}0的结果始终为%4'
# 'result of comparison of %select{%3|unsigned expression}0 %2 %select{unsigned expression|%3}0 is always %4'
HABA37A2C23DF: '比较%select{%3|无符号表达式}0 %2 %select{无符号表达式|%3}0的结果始终为%4'
# 'result of comparison of %select{%4|%1-bit %select{signed|unsigned}2 value}0 %3 %select{%1-bit %select{signed|unsigned}2 value|%4}0 is always %5'
H3E54DBA92461: '比较%select{%4|%1位%select{有符号|无符号}2类型值}0 %3 和 %select{%1位%select{有符号|无符号}2类型值|%4}0的结果始终为%5'
# 'result of comparison of %select{constant %0|true|false}1 with %select{expression of type %2|boolean expression}3 is always %4'
H0604EEA5685E: '将%select{常量%0|true|false}1与%select{类型%2的表达式|布尔表达式}3比较的结果始终为%4'
# "result of comparison of constant %0 with expression of type 'BOOL' is always %1, as the only well defined values for 'BOOL' are YES and NO"
H641A75823917: "与类型'BOOL'的表达式比较的常量%0结果始终为%1，因为'BOOL'的唯一定义值是YES和NO"
# "retain'ed block property does not copy the block - use copy attribute instead"
HD7F1D5C5B0F0: "'retain'的块属性不会复制该块 - 请改用copy属性"
# 'return in the catch of a function try block of a constructor is illegal'
HBC7FDA21A80E: '构造函数的函数try块catch子句中的return语句是非法的'
# "return state set for an unconsumable type '%0'"
H2753EF9C9B3B: "为不可消耗类型'%0'设置了返回状态"
# "return statement not allowed in coroutine; did you mean 'co_return'?"
HD15AAC2A320B: "协程中不允许使用return语句；是否应使用'co_return'？"
# "return type %0 of selected 'operator==' function for rewritten '%1' comparison is not 'bool'"
HC9853B2276CB: "为重写'%1'比较的选定'operator=='函数，其返回类型%0不是'bool'"
# 'return type cannot be qualified with address space'
H90249355EB7F: '返回类型不能用地址空间修饰'
# 'return type deduction is incompatible with C++ standards before C++14'
HB4A5F5EFADA6: '返回类型推导与C++14之前的C++标准不兼容'
# "return type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be 'bool', not %1"
H2EF639AB940D: "默认实现的%select{<ERROR>|相等|三向|相等|关系}0比较运算符的返回类型必须是'bool'而非%1"
# "return type of 'await_ready' is required to be contextually convertible to 'bool'"
H043CECD8EB91: "'await_ready'的返回类型必须能上下文转换为'bool'"
# "return type of 'await_suspend' is required to be 'void' or 'bool' (have %0)"
H64AB2C323A61: "'await_suspend'的返回类型必须是'void'或'bool'（当前为%0）"
# "return type of 'coroutine_handle<>::address should be 'void*' (have %0) in order to get capability with existing async C API"
HA713CB41D910: "'coroutine_handle<>::address'的返回类型应为'void*'（当前为%0），以便通过现有异步C API获取功能"
# "return type of 'main' is not 'int'"
HFBAC240E8034: "'main'的返回类型不是'int'"
# "return type of defaulted 'operator<=>' cannot be deduced because return type %2 of three-way comparison for %select{|member|base class}0 %1 is not a standard comparison category type"
H424FC8A53CC9: "默认的'operator<=>'的返回类型无法推导，因为%select{|member|base class}0 %1的三向比较返回类型%2不是标准比较类别类型"
# "return type of defaulted 'operator<=>' cannot be deduced because three-way comparison for %select{|member|base class}0 %1 has a deduced return type and is not yet defined"
H0105A22E2A8D: "默认的'operator<=>'的返回类型无法推导，因为%select{|member|base class}0 %1的三向比较具有推导出的返回类型且尚未定义"
# 'return type of out-of-line definition of %q0 differs from that in the declaration'
H469315680A98: '%q0的外部定义的返回类型与声明中的不同'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 has different qualifiers than %2)'
H00BA4129869D: '虚函数%0的返回类型与它覆盖的函数的返回类型不协变（%1的限定符与%2不同）'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is incomplete)'
HE8582E3BF357: '虚函数%0的返回类型与它覆盖的函数的返回类型不协变（%1是不完全类型）'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is not derived from %2)'
H5A21B37900C4: '虚函数%0的返回类型与它覆盖的函数的返回类型不协变（%1不是%2的派生类）'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (class type %1 does not have the same cv-qualification as or less cv-qualification than class type %2)'
H2AB9EE663373: '虚函数%0的返回类型与它覆盖的函数的返回类型不协变（类类型%1的cv限定符资格与类类型%2不同或更严格）'
# 'return type of virtual function %3 is not covariant with the return type of the function it overrides (ambiguous conversion from derived class %0 to base class %1:%2)'
H94F1AF985110: '虚函数%3的返回类型与它覆盖的函数的返回类型不协变（从派生类%0到基类%1的转换存在歧义：%2）'
# "return value not in expected state; expected '%0', observed '%1'"
H8EF54209E2EA: "返回值不在预期状态；预期'%0'，实际观察到'%1'"
# 'return value of %0 is a large (%1 bytes) pass-by-value object; pass it by reference instead ?'
HA1B074D05D38: '%0的返回值是一个较大的（%1字节）按值传递对象；建议改为引用传递？'
# 'returning %select{address of|reference to}0 local temporary object'
H0D9CD7C30605: '返回%select{地址的|引用的}0局部临时对象'
# 'returning address of label, which is local'
H7C6FDC7A79CE: '返回局部标签的地址，该标签是局部作用域内的'
# 'returning block that lives on the local stack'
HFB5C6DCAD180: '返回存活在局部栈上的代码块'
# "returning pointer %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H524B3D4E5221: "返回指针%1需要持有%0 %select{'%2'|'排他性%2'}3"
# "returning pointer to variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HC47B423E80E3: "返回变量%1的指针需要持有%0 %select{'%2'|'排他性%2'}3"
# 'returning reference to local temporary object'
H3C7B38DADD40: '返回局部临时对象的引用'
# "returning the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HDFB7294684C5: "通过引用来返回%1指向的值需要持有%0 %select{'%2'|'%2'独占}3"
# "returning variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
H5E5D0E85F387: "通过引用来返回变量%1需要持有%0 %select{'%2'|'%2'独占}3"
# "rewriter doesn't support user-specified control flow semantics for @try/@finally (code may not execute properly)"
H9C522D3EEF6D: '@try/@finally的用户指定控制流语义rewriter不支持（代码可能无法正确执行）'
# 'rewriting block literal declared in global scope is not implemented'
HC8DC37202696: '全局作用域中声明的块字面量重写未实现'
# 'rewriting sub-expression within a macro (may not be correct)'
H72B7281F7712: '宏内的子表达式重写（可能不准确）'
# 'right hand operand to %0 has non-pointer-to-member type %1'
H53A963FA3084: '%0的右操作数具有非成员指针类型%1'
# "right shifting a 'bool' implicitly converts it to 'int'"
HEDBEE20D2831: "隐式右移'bool'会将其转换为'int'"
# "runpath search paths do not match: '%0' (provided) vs '%1' (found)"
H2CB428691FF3: "运行路径搜索路径不匹配：'%0'（提供的）与'%1'（检测到的）"
# "runpath search paths missing from %0: '%1'"
H427437B03484: "%0中缺少运行路径搜索路径：'%1'"
# 'rvalue reference %diff{to type $ cannot bind to lvalue of type $|cannot bind to incompatible lvalue}0,1'
H5D62614FC181: '右值引用%diff{到类型$不能绑定到类型$的左值|无法绑定到不兼容的左值}0,1'
# 'rvalue reference type %0 is not allowed in exception specification'
H63B188C37A7C: '异常规范中不允许使用右值引用类型%0'
# 'rvalue references are a C++11 extension'
HE6F99D294F8D: '右值引用是C++11扩展'
# 'rvalue references are incompatible with C++98'
HBB045EE53C13: '右值引用与C++98不兼容'
# 'safe buffers debug: %0'
H6B8774B1FDA7: '安全缓冲区调试：%0'
# 'same map type modifier has been specified more than once'
HE40C50BE338F: '同一映射类型修饰符被多次指定'
# 'same motion modifier has been specified more than once'
H855EE2722E18: '同一移动修饰符被多次指定'
# 'same pointer dereferenced in multiple different ways in map clause expressions'
H176F03468FDB: '映射子句表达式中同一指针被以不同方式解引用'
# 'sampler initializer has invalid %0 bits'
H18D45D49E7B9: '采样器初始化器具有无效的%0位'
# 'sampler type cannot be used with the __local and __global address space qualifiers'
H2695DF30EE8D: '采样器类型不能与__local和__global地址空间限定符一起使用'
# 'sampler_t initialization requires 32-bit integer, not %0'
HB7C873D08ECC: 'sampler_t初始化需要32位整数，而非%0'
# 'sampler_t variable required - got %0'
H54F7785F9F3D: '需要sampler_t变量 - 实际得到%0'
# "satisfaction of constraint '%0' depends on itself"
H3716B39C40C1: "约束条件'%0'的满足情况依赖于自身"
# 'scalar initialized from empty initializer list is incompatible with C++98'
H4040E7512491: '标量变量由空初始化列表初始化与C++98不兼容'
# 'scalar initializer cannot be empty'
HD3067EEE76AC: '标量初始化器不能为空'
# 'scalar operand type has greater rank than the type of the vector element. (%0 and %1)'
H2C50DCFF8689: '标量操作数类型比向量元素类型的秩更高. (%0和%1)'
# 'scale argument must be 1, 2, 4, or 8'
H325DB8FF3A78: 'scale参数必须为1、2、4或8'
# 'scoped enumeration requires a name'
H38F857947248: '作用域枚举需要一个名称'
# 'scoped enumerations are a C++11 extension'
H880FA70730D4: '作用域枚举是C++11扩展'
# 'scoped enumerations are incompatible with C++98'
H8FFFE671E01D: '作用域枚举与C++98不兼容'
# 'score expressions in the OpenMP context selector need to be constant; %0 is not and will be ignored'
HBAE673BA4B11: 'OpenMP上下文选择器中的评分表达式需要是常量;%0不是常量且将被忽略'
# "search path used: '%0'"
H5005F53FE066: "使用的搜索路径为: '%0'"
# "second argument to 'va_arg' is of ARC ownership-qualified type %0"
H5B02CB112F2F: 'va_arg的第二个参数是ARC所有权限定类型%0'
# "second argument to 'va_arg' is of abstract type %0"
HB0CBA3C6712C: 'va_arg的第二个参数是抽象类型%0'
# "second argument to 'va_arg' is of array type %0; this va_arg has undefined behavior because arguments will never be compatible with array type"
H0271D72D02D0: 'va_arg的第二个参数是数组类型%0;此va_arg行为未定义，因为参数永远不会与数组类型兼容'
# "second argument to 'va_arg' is of incomplete type %0"
HBAB6DD203AC7: 'va_arg的第二个参数是不完全类型%0'
# "second argument to 'va_arg' is of non-POD type %0"
H6E23523199DB: 'va_arg的第二个参数是非POD类型%0'
# "second argument to 'va_arg' is of promotable type %0; this va_arg has undefined behavior because arguments will be promoted to %1"
HD77AAC429CAF: 'va_arg的第二个参数是可提升类型%0;此va_arg行为未定义，因为参数将被提升为%1类型'
# "second argument to 'va_start' is not the last non-variadic parameter"
H37CA82AB0144: '__builtin_alloca_with_align的第二个参数应以比特为单位'
# 'second argument to __builtin_alloca_with_align is supposed to be in bits'
HF3ADBC91450B: 'va_start的第二个参数不是最后一个非可变参数'
# 'second argument to __builtin_annotation must be a non-wide string constant'
HB28F8D41E677: '__builtin_annotation的第二个参数必须是非宽字符串常量'
# 'second argument to __builtin_call_with_static_chain must be of pointer type'
H9D3B291ADD1F: '__builtin_call_with_static_chain 的第二个参数必须是指针类型'
# 'section attribute is specified on redeclared variable'
H4BE9B9505588: 'section 属性被指定在重新声明的变量上'
# 'section length is evaluated to a negative value %0'
HDAA24A68E89D: 'section 长度计算为负值 %0'
# 'section length is unspecified and cannot be inferred because subscripted value is %select{not an array|an array of unknown bound}0'
HD324F8149A40: 'section 长度未指定且无法推断，因为下标值为 %select{非数组|未知长度的数组}0'
# 'section of pointer to function type %0'
HDFC73840E7DC: '指向函数类型 %0 的指针的 section'
# 'section of pointer to incomplete type %0'
HFA4996C0EBB1: '指向不完整类型 %0 的指针的 section'
# 'section stride is evaluated to a non-positive value %0'
H2C7B2A05B911: 'section 步长计算为非正数值 %0'
# 'see attribute on parameter here'
HDD0675B1BF06: '查看此处参数上的属性'
# "selected '%select{begin|end}0' %select{function|template }1%2 with iterator type %3"
H752B6650220E: "选择 '%select{begin|end}0' %select{函数|模板 }1%2，其迭代器类型为 %3"
# "selected 'operator<=>' for %select{|member|base class}0 %1 declared here"
H810A0D73AD55: "为 %select{|成员|基类}0 %1 声明的 'operator<=>' 被选中"
# 'selector element is not a valid lvalue'
H0BFE26B0616A: '选择器元素不是有效的左值'
# 'selector element of type %0 cannot be a constant lvalue expression'
H9F3EFE55FA69: '类型为 %0 的选择器元素不能是常量左值表达式'
# 'selector element type %0 is not a valid object'
HED5168FB3348: '选择器元素类型 %0 不是有效的对象'
# 'semantic annotations must be present for all parameters of an entry function or patch constant function'
H8F1EA44B7AC0: '入口函数或修补常量函数的所有参数都必须包含语义注解'
# 'semicolon before method body is ignored'
H600E31190711: '方法体前的分号被忽略'
# 'semicolon terminating header import declaration cannot be produced by a macro'
HD5CFDD7201E4: '由宏生成的导入声明终止分号无效'
# 'setter and getter must both be synthesized, or both be user defined, or the property must be nonatomic'
H13B288111B84: 'setter 和 getter 必须同时自动生成，或同时用户自定义，或者属性必须声明为 nonatomic'
# 'setter cannot be specified for a readonly property'
H0B75386E5DBF: '只读属性不能指定 setter'
# 'setting the floating point evaluation method to `source` on a target without SSE is not supported'
H3CBE26190DE7: '在不支持 SSE 的目标上，将浮点运算方法设置为 `source` 是不支持的'
# 'several methods with selector %0 of mismatched types are found for the @selector expression'
H992F0A773FBB: '为 @selector 表达式找到多个具有不匹配类型的选择器 %0'
# 'shift count %0 >= width of type %1 (%2 bit%s2)'
HF6F9C4B1183E: '位移计数 %0 >= 类型 %1 的宽度 (%2 bit%s2)'
# 'shift count >= width of type'
H64BC6739BC0B: '移位计数大于等于类型的位宽'
# 'shift count is negative'
H49401E14D24E: '移位计数是负数'
# 'shifting a negative signed value is undefined'
H08F0D0D67884: '对负的有符号值进行移位操作是未定义的'
# 'signed bit-field %0 needs an extra bit to represent the largest positive enumerators of %1'
HE118008121A9: '有符号位段 %0 需要额外一位来表示枚举类型 %1 的最大正枚举值'
# 'signed left shift discards bits'
HD469BF80AF3C: '有符号左移会丢弃高位'
# 'signed shift result (%0) requires %1 bits to represent, but %2 only has %3 bits'
HC5B9F5083ED5: '有符号移位结果（%0）需要 %1 位来表示，但类型 %2 只有 %3 位'
# "signed shift result (%0) sets the sign bit of the shift expression's type (%1) and becomes negative"
H95CD10E060D8: '有符号移位结果（%0）设置了移位表达式类型 %1 的符号位并变为负数'
# "signedness of format specifier '%0' is incompatible with '%1'"
H0E3D0B14B46F: "格式说明符 '%0' 的符号性与 '%1' 不兼容"
# 'signing a null pointer will yield a non-null pointer'
H25C3D501EB46: '将空指针进行符号转换会得到非空指针'
# 'silence by adding parentheses to mark code as explicitly dead'
H99754744B060: '通过添加括号将代码标记为显式无效来消除警告'
# 'similar constraint expression here'
HC25A9009F181: '此处存在类似的约束表达式'
# 'similar constraint expressions not considered equivalent; constraint expressions cannot be considered equivalent unless they originate from the same concept'
H671259A4BAC3: '类似的约束表达式不被视为等效；除非源自同一概念，否则约束表达式不被视为等效'
# "single declaration is expected after 'declare %select{simd|variant}0' directive"
H178440D95E1D: "'declare %select{simd|variant}0' 指令后应跟单一声明"
# 'single subscript expressions are not allowed for matrix values'
H6751A19F6DB9: '矩阵值不允许单一下标表达式'
# 'size argument in %0 call appears to be size of the source; expected the size of the destination'
HA69933A2CC96: '在 %0 调用中的 size 参数看起来是源的大小，应使用目标的大小'
# 'size argument in %0 call is a comparison'
HAC4E42C8E89B: '%0 调用中的 size 参数是一个比较表达式'
# "size argument in 'strncat' call appears to be size of the source"
HBE6DF8480F3A: "'strncat' 调用中的 size 参数看起来是源的大小"
# 'size must be %select{1, 2, or 4|1, 2, 4, 12 or 16}0'
H5666676F632D: '大小必须是 %select{1、2 或 4|1、2、4、12 或 16}'
# "size of '__builtin_bit_cast' source type %0 does not match destination type %1 (%2 vs %3 bytes)"
HE2800B62712B: "'__builtin_bit_cast' 的源类型 %0 的大小与目标类型 %1 不匹配（%2 字节 vs %3 字节）"
# "size of array element of type %0 (%1 bytes) isn't a multiple of its alignment (%2 bytes)"
H64B3D7C6AA54: '类型 %0 的数组元素的大小（%1 字节）不是其对齐值（%2 字节）的倍数'
# 'size of array has non-integer type %0'
HE09F852059B1: '数组的大小具有非整数类型 %0'
# "size of register '%0' does not match variable size"
HECA9BDA68860: "寄存器 '%0' 的大小与变量大小不匹配"
# 'sizeof on array function parameter will return size of %0 instead of %1'
HFA0A8C5A6400: '对数组函数参数使用 sizeof 将返回 %0 的大小而非 %1'
# 'sizeof on pointer operation will return size of %0 instead of %1'
H23C83EADD90C: '对指针操作使用 sizeof 将返回 %0 的大小而非 %1'
# "skipping '%0' because module declaration of '%1' lacks the 'framework' qualifier"
H07A078D1E04E: "跳过 '%0'，因为模块声明 '%1' 缺少 'framework' 限定符"
# 'skipping stray token'
HF5D19BFCA4A8: '跳过孤立的标记'
# 'source file is not valid UTF-8'
HDC95C446AFAD: '源文件不是有效的 UTF-8 编码'
# 'source manager location address space usage:'
H7D02F3625956: '源管理器位置地址空间使用情况：'
# 'specialization of member %q0 does not specialize an instantiated member'
H7EB7CDEAD3CD: '成员 %q0 的特化并未特化已实例化的成员'
# 'specified %0 type tag requires a null pointer'
HEFCCEFE3C17F: '指定的 %0 类型标签需要一个空指针'
# "specifying 'uuid' as an ATL attribute is deprecated; use __declspec instead"
H12B975086F19: "将 'uuid' 作为 ATL 属性指定已弃用；请改用 __declspec"
# 'specifying OpenMP directives with [[]] is an OpenMP 5.1 extension'
H4B0556017370: '使用 [[]] 指定 OpenMP 指令是 OpenMP 5.1 的扩展'
# 'specifying OpenMP directives with [[]] is incompatible with OpenMP standards before OpenMP 5.1'
H8022C700FE36: '使用 [[]] 指定 OpenMP 指令与 OpenMP 5.1 之前的版本标准不兼容'
# 'specifying an identifier within `#pragma pack` is not supported on this target'
H6F2B8F9FE9C4: '在 `#pragma pack` 内指定标识符在此目标上不受支持'
# "specifying both a name and alignment to 'pop' is undefined"
HC71C880E8806: "同时为 'pop' 指定名称和对齐方式是未定义的"
# "specifying character '%0' with a universal character name is incompatible with C standards before C23"
H9E4A97D8B259: "使用通用字符名指定字符 '%0' 与 C23 之前的 C 标准不兼容"
# "specifying character '%0' with a universal character name is incompatible with C++98"
H2678BC1F681E: "使用通用字符名指定字符 '%0' 与 C++98 不兼容"
# "specifying vector types with the 'mode' attribute is deprecated; use the 'vector_size' attribute instead"
H29212F917029: "使用 'mode' 属性指定向量类型已弃用；请改用 'vector_size' 属性"
# 'speculative load hardening does not protect functions with asm goto'
H95EDE5332D8C: '推测性加载强化无法保护带有 asm goto 的函数'
# "stack frame size (%0) exceeds limit (%1) in '%2'"
HCF0AF62F4A65: "栈帧大小（%0）超过限制（%1）在'%2'中"
# 'stack nearly exhausted; compilation time may suffer, and crashes due to stack overflow are likely'
HD310C1B31961: '栈几乎耗尽；编译时间可能受到影响，并且可能发生因栈溢出导致的崩溃'
# "standard library implementation of %0 is not supported; %select{member '%2' does not have expected form|member '%2' is missing|the type is not trivially copyable|the type does not have the expected form}1"
H8A51A30A514F: "%0的标准库实现不受支持；%select{成员'%2'没有预期的形式|成员'%2'缺失|该类型无法进行平凡复制|该类型的结构不符合预期}1"
# 'standard library not linked and so no interrupt vector table or compiler runtime routines will be linked'
H3B6E22A7AD97: '未链接标准库，因此不会链接中断向量表或编译器运行时例程'
# 'star modifier used outside of function prototype'
HA2B9806ED1A1: '在函数原型之外使用星号修饰符'
# "state of variable '%0' must match at the entry and exit of loop"
H7D285ABC5B72: "变量'%0'在循环入口和出口处的状态必须一致"
# "statement after '#pragma omp dispatch' must be a direct call to a target function or an assignment to one"
H172FE1A4272E: "在'#pragma omp dispatch'之后的语句必须是直接调用目标函数或将其赋值"
# "statement associated with OpenACC 'atomic%select{| %1}0' directive is invalid"
H42056AC9B64A: "与OpenACC 'atomic%select{| %1}0'指令关联的语句无效"
# "statement attribute %0 has higher precedence than function attribute '%select{always_inline|flatten|noinline}1'"
H0AF92FCED836: "语句属性%0的优先级高于函数属性'%select{always_inline|flatten|noinline}1'"
# 'statement expression not allowed at file scope'
HB4FE90B7D7C8: '文件作用域内不允许使用语句表达式'
# "statement in 'omp %0' directive must be enclosed into a section region"
H69791FF123D5: "在'omp %0'指令中的语句必须包含在section区域中"
# 'statement not allowed in %select{constexpr|consteval}1 %select{function|constructor}0'
HD56C75E5841E: '在%select{constexpr|consteval}1 %select{函数|构造函数}0中不允许使用该语句'
# 'statement requires expression of integer type (%0 invalid)'
H752828F0ECD0: '该语句需要整型表达式（%0无效）'
# 'statement requires expression of scalar type (%0 invalid)'
HFBBF3A578FA4: '该语句需要标量类型表达式（%0无效）'
# 'static %0 runtime is not supported on darwin'
H52FFB37B4DFA: '在Darwin系统上不支持static %0运行时'
# 'static %select{function|variable}0 %1 is used in an inline function with external linkage'
HBAA29A669BB7: '静态%select{函数|变量}0 %1被用于具有外部链接的内联函数中'
# 'static and non-static member functions with the same parameter types cannot be overloaded'
H455410FE204F: '具有相同参数类型的静态和非静态成员函数不能重载'
# 'static assertion expression is not an integral constant expression'
H4896ABC370E3: '静态断言表达式不是整型常量表达式'
# "static assertion failed due to requirement '%0'%select{: %2|}1"
H3D43CA56F16F: "静态断言失败，因为要求'%0'%select{：%2|}1"
# 'static assertion failed%select{: %1|}0'
H4F7EABF6B0DD: '静态断言失败%select{：%1|}0'
# 'static const volatile data member must be initialized out of line'
H407C919E04E8: '具有static const volatile类型的成员数据必须在外部初始化'
# 'static data member %0 already has an initializer'
H6ACB0F956377: '静态数据成员%0已经有一个初始化器'
# 'static data member %0 in union is a C++11 extension'
HA330F37BE63B: '联合中的静态数据成员%0是C++11扩展'
# 'static data member %0 in union is incompatible with C++98'
HEBF9EACD8366: '联合中的静态数据成员%0与C++98标准不兼容'
# 'static data member %0 not allowed in anonymous %select{struct|interface|union|class|enum}1'
HC964FFEFDD87: '不允许在匿名%select{struct|interface|union|class|enum}1中的静态数据成员%0'
# 'static data member %0 not allowed in local %select{struct|interface|union|class|enum}2 %1'
HA56CE2DF143E: '不允许在局部%select{struct|interface|union|class|enum}2 %1中的静态数据成员%0'
# 'static data member definition cannot specify a storage class'
HF3222609AACF: '静态数据成员的定义不能指定存储类别'
# 'static data member of type %0 must be initialized out of line'
H4598A36D5110: '类型为%0的静态数据成员必须在外部初始化'
# 'static declaration of %0 follows non-static declaration'
H2C721D0B8C3C: '%0的静态声明跟随了非静态声明'
# 'static lambdas are a C++23 extension'
H0728106ADDA2: '静态lambda表达式是C++23扩展'
# 'static lambdas are incompatible with C++ standards before C++23'
H81C85F6C724E: '静态lambda表达式与C++23之前的C++标准不兼容'
# 'static member %0 cannot be a bit-field'
HDFCBA261B7FE: '静态成员%0不能是位域'
# 'static members cannot be declared in an anonymous %select{struct|union}0'
HF2CC0A1A3C82: '不允许在匿名%select{struct|union}0中声明静态成员'
# 'static variable %0 is suspiciously used within its own initialization'
H1CCD7A0167D8: '静态变量%0在其自身初始化中被可疑地使用'
# 'static_cast between pointer-to-function and pointer-to-object is a Microsoft extension'
H747267A37B70: '在函数指针和对象指针之间使用static_cast是微软扩展'
# "std::coroutine_handle isn't a class template"
H20FD07579F32: 'std::coroutine_handle不是类模板'
# "std::coroutine_handle must have a member named '%0'"
HC01B7EC5D8D7: "std::coroutine_handle必须有一个名为'%0'的成员"
# "std::coroutine_traits isn't a class template"
H3D3F8F520E5F: 'std::coroutine_traits不是类模板'
# 'std::initializer_list must be a class template with a single type parameter'
H57E56532E11C: 'std::initializer_list必须是一个具有单个类型参数的类模板'
# 'std::nothrow must be a valid variable declaration'
H81985EEDEA6B: 'std::nothrow必须是一个有效的变量声明'
# 'std::nothrow was not found; include <new> before defining a coroutine which uses get_return_object_on_allocation_failure()'
H553185766FEB: '未找到std::nothrow；在定义使用get_return_object_on_allocation_failure()的协程之前，请包含<new>头文件'
# "step simple modifier is exclusive and cannot be use with 'val', 'uval' or 'ref' modifier"
H61FE9B0F27A0: "step简单修饰符是互斥的，不能与'val'、'uval'或'ref'修饰符一起使用"
# 'still within definition of %q0 here'
HE0627D20A1B5: '仍在%q0的定义范围内'
# 'storage class specified for a member declaration'
HE2F76CA3682F: '成员声明中指定了存储类'
# 'strftime format attribute requires 3rd parameter to be 0'
H48F53118805C: 'strftime格式属性要求第三个参数为0'
# 'stride must be greater or equal to the number of rows'
H8F8F20EB9F60: 'stride必须大于或等于行数'
# 'string is ill-formed as UTF-8 and will become a null %0 when boxed'
H978281414E51: '该字符串作为UTF-8格式不合法，打包后将成为空%0'
# "string literal after 'operator' cannot have an encoding prefix"
HE2D46EB90348: "'operator'之后的字符串字面量不能带有编码前缀"
# 'string literal after \'operator\' must be \'""\''
HB2C541BB7B81: "'operator'之后的字符串字面量必须是''"
# 'string literal of length %0 exceeds maximum length %1 that %select{C90|ISO C99|C++}2 compilers are required to support'
H446F1FE51F67: '长度为%0的字符串字面量超过了%select{C90|ISO C99|C++}2编译器必须支持的最大长度%1'
# 'string literal operator templates are a GNU extension'
HC7C4AAEBD81D: '字符串字面量操作符模板是GNU扩展'
# 'string literal with user-defined suffix cannot be used here'
H0A403620271A: '带有用户定义后缀的字符串字面量不能在此处使用'
# 'structured binding declaration in a condition is a C++2c extenstion'
HBC59A4270821: '条件中的结构化绑定声明是C++2c扩展'
# 'structured binding declaration in a condition is incompatible with C++ standards before C++2c'
HD456E18D0B36: '条件中的结构化绑定声明与C++2c之前的C++标准不兼容'
# 'structured binding packs are a C++2c extension '
H041F82FB15BE: '结构化绑定包是C++2c扩展'
# 'structured binding packs are incompatible with C++ standards before C++2c'
HD48DDFF6186B: '结构化绑定包与C++2c之前的C++标准不兼容'
# 'subexpression not valid in a constant expression'
H9779A11486AE: '子表达式在常量表达式中无效'
# 'submodule %0.%1 not declared in module map'
H1DA53EDBF661: '模块映射中未声明子模块%0.%1'
# "submodule of top-level module '%0' implicitly imported here"
HDAE6F5126C46: "顶级模块'%0'的子模块在此处被隐式导入"
# 'subobject %select{of type |}0%1 is not initialized'
HF2C7BC6C2C0D: '子对象%select{of type |}0%1未初始化'
# 'subobject declared here'
H554F161157BC: '子对象在此处声明'
# 'subscript of a pointer to void is a GNU extension'
H3CC7AA95FFD8: '对void类型的指针进行下标操作是GNU扩展'
# 'subscript of pointer to %select{incomplete|sizeless}0 type %1'
H1AFEC4E5E6B6: '对类型%select{不完整|零大小}0的%1的指针进行下标操作'
# 'subscript of pointer to function type %0'
H768DEE928692: '对函数类型%0的指针进行下标操作'
# 'subscript of svbool_t is not allowed'
H8F54745267C0: 'svbool_t的下标操作不被允许'
# 'subscript requires size of interface %0, which is not constant for this architecture and platform'
H10B94DBD4388: '接口%0的大小不是该架构和平台的常量，无法进行下标操作'
# 'subscripted value is not an array or pointer'
HFC1E308C6B30: '下标操作的值不是数组或指针'
# 'subscripted value is not an array, pointer, or vector'
H1F892D50B541: '下标操作的值不是数组、指针或向量'
# 'substitution failure due to access control is incompatible with C++98'
H09899E5F733A: '由于访问控制导致的替换失败与C++98不兼容'
# 'substitution into constraint expression resulted in a non-constant expression'
H0CC3DD33E92E: '约束表达式替换后得到非常量表达式'
# 'subtracted pointers are not elements of the same array'
HBF5BC0994673: '相减的指针不是同一数组的元素'
# 'subtraction of pointers to type %0 of zero size'
HAE88E507C99F: '对大小为零的类型%0的指针进行相减'
# 'subtraction of pointers to type %0 of zero size has undefined behavior'
H238100FAEBF4: '对大小为零的类型%0的指针进行相减具有未定义行为'
# 'suffix with parentheses to turn this into a function call'
HBA5C36C9B0F9: '使用带括号的后缀将其转换为函数调用'
# 'suggest braces around initialization of subobject'
H122DA545D844: '建议在子对象的初始化周围使用花括号'
# "support for '/Yc' and '/Yu' with different filenames not implemented yet; flags ignored"
HC924164CBDE2: "对不同文件名的'/Yc'和'/Yu'支持尚未实现；忽略该标志"
# "support for '/Yc' with more than one source file not implemented yet; flag ignored"
H7450874B7BA1: "对多个源文件的'/Yc'支持尚未实现；忽略该标志"
# 'support for HLSL language version %0 is incomplete, recommend using %1 instead'
H68BB4F93A02C: '对HLSL语言版本%0的支持不完整，建议改用%1'
# "support for linking stdlibs for microcontroller '%0' is not implemented"
H8995E8434A04: "对微控制器'%0'的stdlib链接支持尚未实现"
# "support for passing the data section address to the linker for microcontroller '%0' is not implemented"
H870D8231D796: "对微控制器'%0'向链接器传递数据段地址的支持尚未实现"
# 'surrounding namespace with visibility attribute ends here'
H4297D0DA8CEA: '带有可见性属性的外围命名空间在此结束'
# 'surrounding namespace with visibility attribute starts here'
HA543A7B12EEA: '带有可见性属性的外围命名空间在此开始'
# 'suspicious concatenation of string literals in an array initialization; did you mean to separate the elements with a comma?'
HE00F78FF32CA: '在数组初始化中可疑地连接字符串字面量；您是否想用逗号分隔元素？'
# 'switch condition has boolean value'
HA563E9019204: 'switch条件具有布尔值'
# 'switch condition has incomplete class type %0'
HD68BA6071310: 'switch条件具有不完整的类类型%0'
# 'switch condition type %0 requires explicit conversion to %1'
HF719378BC596: 'switch条件类型%0需要显式转换为%1'
# 'switch statement has empty body'
HD379C27E8554: 'switch语句具有空的主体'
# "symbol exported in dynamic library, but marked hidden in declaration '%0'"
H493627372D47: '在动态库中导出的符号在声明“%0”中标记为隐藏'
# 'synchronization scope argument to atomic operation is invalid'
HE1E237FB50C9: '原子操作的同步作用域参数无效'
# 'synthesized properties %0 and %1 both claim instance variable %2'
H9EA52B48540E: '合成属性%0和%1均声明实例变量%2'
# 'synthesized properties %0 and %1 both claim setter %2 - use of this setter will cause unexpected behavior'
HA9255CAB38EC: '合成属性%0和%1均声明setter%2 — 使用此setter会导致意外行为'
# 'synthesized property %0 must either be named the same as a compatible instance variable or must explicitly name an instance variable'
HC10D22B3B816: '合成属性%0必须与兼容的实例变量同名，或者必须显式指定实例变量'
# 'synthesized property with variable size type %0 requires an existing instance variable'
H594CC555D195: '类型%0的可变大小合成属性需要已有的实例变量'
# 'synthesized setter %0 for null_resettable property %1 does not handle nil'
H95960177BFF3: 'null_resettable属性%1的合成setter%0无法处理nil'
# 'synthesizing __weak instance variable of type %0, which does not support weak references'
H1E4EBACF7211: '合成类型%0的__weak实例变量，而该类型不支持弱引用'
# 'tail call required by %0 attribute here'
H9FB91CA4B73B: '此处%0属性要求尾调用'
# 'tail call requires that the return value, all parameters, and any temporaries created by the expression are trivially destructible'
HE303C40B04A3: '尾调用要求返回值、所有参数以及表达式创建的任何临时对象都可简单销毁'
# 'taking address of a capture is not allowed'
H35418F9DEF58: '不允许获取捕获变量的地址'
# 'taking address of function is not allowed'
H4A30B839C6AB: '不允许获取函数的地址'
# 'taking address of non-addressable standard library function'
H3ACD682CFC45: '不允许获取标准库中不可寻址函数的地址'
# 'taking address of non-addressable standard library function is incompatible with C++20'
H888C6C415192: '获取不可取址的标准库函数的地址与C++20不兼容'
# 'taking address of packed member %0 of class or structure %q1 may result in an unaligned pointer value'
HD700C27ED0FC: '获取类或结构体%q1的已压缩成员%0的地址可能导致未对齐的指针值'
# 'taking the absolute value of %select{pointer|function|array}0 type %1 is suspicious'
HDEB21F2512CF: '对%select{指针|函数|数组}0类型%1取绝对值存在可疑之处'
# 'taking the absolute value of unsigned type %0 has no effect'
H8F6DAEC8BECD: '对无符号类型%0取绝对值不会有影响'
# 'taking the address of a destructor'
H7B853F7C78AC: '获取析构函数的地址'
# 'taking the address of a temporary object of type %0'
HD39DC5626A0A: '获取类型%0的临时对象的地址'
# 'taking the max of %select{a value and unsigned zero|unsigned zero and a value}0 is always equal to the other value'
H75EF0725015B: '对%select{一个值和无符号零|无符号零和一个值}0取最大值始终等于另一个值'
# 'target %select{constructor|destructor}0 is declared here'
HD59E728E618B: '目标%select{构造函数|析构函数}0在这里声明'
# "target '%0' does not support exception handling; 'catch' block is ignored"
H06DD0F5375FE: "目标'%0'不支持异常处理；'catch'代码块将被忽略"
# "target '%0' does not support exception handling; 'throw' is assumed to be never reached"
H29FDCCFA5847: "目标'%0'不支持异常处理；'throw'将被认为不可达"
# "target '%0' is not a supported OpenMP host target"
H6B6204612E53: "目标'%0'不是支持的OpenMP主机目标"
# "target '%0' is unsupported by -fsanitize-kcfi-arity"
HCFEF0540C5A0: "目标'%0'不受-fsanitize-kcfi-arity支持"
# 'target construct with nested teams region contains statements outside of the teams construct'
HB05FDB001094: '目标构造中的嵌套团队区域包含位于团队构造外部的语句'
# "target does not support 'protected' visibility; using 'default'"
H9354CE031F68: "目标不支持'protected'可见性；使用'default'"
# 'target exception specification is not superset of source'
H14AD31786EFD: '目标异常规范不是源的超集'
# 'target function %select{is a member of different class%diff{ (expected $ but has $)|}1,2|has different number of parameters (expected %1 but has %2)|has type mismatch at %ordinal3 parameter%diff{ (expected $ but has $)|}1,2|has different return type%diff{ ($ expected but has $)|}1,2}0'
HFEFD6F95E799: '目标函数%select{属于不同的类%diff{（预期$但实际$）|}1,2|参数数量不同（预期%1但实际%2）|第%ordinal3个参数类型不匹配%diff{（预期$但实际$）|}1,2|返回类型不同%diff{（预期$但实际$）|}1,2}0'
# 'target function has calling convention %1 (expected %0)'
HE7D037C49FE5: '目标函数的调用约定为%1（预期%0）'
# 'target of using declaration'
HCB1C9C62D72D: 'using声明的目标'
# 'target of using declaration conflicts with declaration already in scope'
H5C1974A3FA23: 'using声明的目标与作用域内已有的声明冲突'
# 'target profile option (-T) is missing'
HD96117F3AEE8: '目标配置文件选项（-T）缺失'
# 'target-attribute based function overloads are not supported by NVCC and will be treated as a function redeclaration:new declaration is %select{__device__|__global__|__host__|__host__ __device__}0 function, old declaration is %select{__device__|__global__|__host__|__host__ __device__}1 function'
H48B3A7876AE7: '基于target-attribute的函数重载不被NVCC支持，将被视为函数重新声明：新声明是%select{__device__|__global__|__host__|__host__ __device__}0函数，旧声明是%select{__device__|__global__|__host__|__host__ __device__}1函数'
# 'template %0 has no definition and no %select{|viable }1deduction guides for deduction of template arguments'
H39A2D17F6485: '模板%0没有定义，也没有%select{|可行的 }1推导指南来推导模板参数'
# 'template argument / label address difference / what did you expect?'
H4022196FB5B0: '模板参数/标签地址差异/您期望的是什么？'
# 'template argument does not refer to a class or alias template, or template template parameter'
H10B27B45B43C: '模板参数不引用类或别名模板，或模板模板参数'
# 'template argument for non-type template parameter is treated as function type %0'
HF7C463216541: '非类型模板参数的模板参数被解释为函数类型%0'
# 'template argument for non-type template parameter must be an expression'
HA6F518CB9F6F: '非类型模板参数的模板参数必须是一个表达式'
# 'template argument for template template parameter must be a class template%select{| or type alias template}0'
H4605CB1853A3: '模板模板参数的模板参数必须是一个类模板%select{|或类型别名模板}0'
# 'template argument for template type parameter must be a type'
H9FFBB255FD4F: '模板类型参数的模板参数必须是一个类型'
# "template argument for template type parameter must be a type; did you forget 'typename'?"
H477EE50BCF4B: "模板类型参数的模板参数必须是一个类型；是否漏掉了'typename'？"
# "template argument for template type parameter must be a type; omitted 'typename' is a Microsoft extension"
H0CC2569F4810: "模板类型参数的模板参数必须是一个类型；省略'typename'是Microsoft扩展"
# 'template argument is the type of an unresolved overloaded function'
H1DDFBAF8CEBB: '模板参数是未解析的重载函数类型'
# 'template argument refers to function template %0, here'
H59E0A4B6EEC0: '模板参数引用函数模板%0，此处'
# 'template argument uses local type %0'
H8CFAA5F55F9C: '模板参数使用局部类型%0'
# 'template argument uses unnamed type'
H1A9FF29A8094: '模板参数使用未命名类型'
# 'template declaration from hidden source: %0'
H607A13711E91: '来自隐藏源的模板声明：%0'
# 'template is declared here'
H8B583108C6ED: '模板在此处声明'
# 'template name refers to non-type template %0'
HD8E4D2A7EC89: '模板名称引用非类型模板%0'
# 'template non-type parameter has a different type %0 in template %select{|template parameter }1redeclaration'
H29D49A380D2B: '模板%select{|模板参数 }1重新声明中，模板非类型参数具有不同类型%0'
# 'template non-type parameter has a different type %0 in template argument'
H83C8844C296B: '模板参数中的非类型参数具有不同类型%0'
# "template parameter '%0' is already documented"
H4188A9C61053: "模板参数'%0'已被文档记录"
# "template parameter '%0' not found in the template declaration"
H1A80B68DAC8D: "模板参数 '%0' 未在模板声明中找到"
# 'template parameter declared here'
HC6CFA91EE1C1: '模板参数在此处声明'
# 'template parameter default argument is inconsistent with previous definition'
H6440E4D1834B: '模板参数默认参数与之前的定义不一致'
# 'template parameter from hidden source: %0'
HE652270F3F6D: '来自隐藏源的模板参数：%0'
# 'template parameter has a different kind in template %select{|template parameter }0redeclaration'
HBF82CEEA37C8: '模板参数在模板%select{|模板参数 }0重新声明中的类型不同'
# 'template parameter has a different kind in template argument'
H8F8F50E907A1: '模板参数在模板实参中的类型不同'
# 'template parameter has different kinds in different translation units'
H8BA5D6787AFF: '模板参数在不同翻译单元中的类型不同'
# 'template parameter is declared here'
H6B3C8DC0FA6A: '模板参数在此处声明'
# 'template parameter is used in default argument declared here'
HF0F9ED98885D: '模板参数在此处声明的默认参数中使用'
# 'template parameter list also declared here'
H1F8E29374B19: '模板参数列表也在此处声明'
# "template parameter list for literal operator must be either 'char...' or 'typename T, T...'"
H409CCC2DB745: "字面量运算符的模板参数列表必须为 'char...' 或 'typename T, T...'"
# "template parameter list matching the non-templated nested type %0 should be empty ('template<>')"
HE4D93F6B6699: "与非模板嵌套类型%0匹配的模板参数列表应为空 ('template<>)'"
# 'template parameter lists have a different number of parameters (%0 vs %1)'
HB5785F1417CF: '模板参数列表的参数数量不同（%0 对比 %1）'
# 'template parameter missing a default argument'
H5BFE290A5AC0: '模板参数缺少默认参数'
# "template parameter of a function template with the 'sycl_kernel' attribute cannot be a non-type template parameter"
H7625BE567F07: "带有 'sycl_kernel' 属性的函数模板的模板参数不能是非类型模板参数"
# 'template parameter pack cannot have a default argument'
HD1F9E9063EB7: '模板参数包不能具有默认参数'
# 'template parameter pack must be the last template parameter'
HD5749F5C7756: '模板参数包必须是最后一个模板参数'
# 'template parameter redefines default argument'
H8C66CF577C62: '模板参数重新定义了默认参数'
# 'template specialization declaration cannot be a friend'
HA8ECAC04AF8C: '模板特化声明不能是友元'
# 'template specialization or definition requires a template parameter list corresponding to the nested type %0'
HC868EA3957FF: '模板特化或定义需要与嵌套类型%0对应的模板参数列表'
# "template specialization requires 'template<>'"
H1ADEE7A736DF: "模板特化需要使用 'template<>'"
# 'template template argument %0 is more constrained than template template parameter %1'
HE3F8D9BFA908: '模板模板实参 %0 比模板模板参数 %1 更具约束性'
# 'template template argument has different template parameters than its corresponding template template parameter'
HB7542BD3C1FF: '模板模板实参的模板参数与其对应的模板模板参数不同'
# 'template template parameter must have its own template parameters'
H2E8B286B021F: '模板模板参数必须有自己的模板参数'
# "template template parameter requires 'class'%select{| or 'typename'}0 after the parameter list"
HC7B5002008B5: "模板模板参数在参数列表后需要 'class'%select{|或 'typename'}0"
# "template template parameter using 'typename' is a C++17 extension"
HD13D228AA386: "使用 'typename' 的模板模板参数是C++17的扩展"
# "template template parameter using 'typename' is incompatible with C++ standards before C++17"
H2724DAD0662B: "使用 'typename' 的模板模板参数与C++17之前的C++标准不兼容"
# 'templates can only be declared in namespace or class scope'
H549BBF1A776B: '模板只能在命名空间或类作用域中声明'
# 'templates cannot be declared inside of a local class'
H9817A58D9951: '模板不能在局部类内部声明'
# 'templates must have C++ linkage'
H7DA4A8DB6A41: '模板必须具有C++链接性'
# 'temporary bound to reference member of allocated object will be destroyed at the end of the full-expression'
H013054578BC3: '与分配对象的引用成员绑定的临时对象将在完整表达式结束时被销毁'
# 'temporary created here'
H6CF924D32FF7: '临时对象在此处创建'
# 'temporary of type %0 has %select{private|protected}1 destructor'
HA776568AF253: '类型为%0的临时对象具有%select{私有|受保护}1的析构函数'
# 'tentative array definition assumed to have one element'
H1578DBDB8944: '暂定数组定义假定有一个元素'
# 'tentative definition has type %0 that is never completed'
H2533423DBC92: '暂定定义具有未完成的类型%0'
# 'tentative definition of variable with internal linkage has incomplete non-array type %0'
H137EE1AFC5D6: '具有内部链接的变量的暂定定义具有不完整的非数组类型%0'
# "test module file extension '%0' has different version (%1.%2) than expected (%3.%4)"
HD419260C8BE7: "测试模块文件扩展名 '%0' 的版本 (%1.%2) 与预期 (%3.%4) 不同"
# 'the #__include_macros directive is only for internal use by -imacros'
H1FBDC6FD510E: '#__include_macros 指令仅用于 -imacros 的内部使用'
# 'the %0 sub-architecture does not support unaligned accesses'
H8EEF78B6F581: '%0 子架构不支持非对齐访问'
# 'the %0 type cannot be used to declare a program scope variable'
HCC2A02E45E01: '类型%0 不能用于声明程序作用域变量'
# 'the %0 type cannot be used to declare a structure or union field'
H3AA824360E4A: '类型%0不能用于声明结构体或联合体的字段'
# 'the %select{1st|2nd|3rd}1 template parameter of %0 needs to be %select{a type|an integer or enum value}2'
HC15D25E5BA46: '模板%0的第%select{1位|2位|3位}1个模板参数需要是%select{一个类型|一个整数或枚举值}2'
# 'the %select{function or variable|function}0 specified in an %select{alias|ifunc}1 must refer to its mangled name'
H2A963C3F164E: '在%select{别名|ifunc}1中指定的%select{函数或变量|函数}0必须引用其mangled名称'
# "the %select{message|string}0 object in %select{this static assertion|this asm operand}0 is missing %select{a 'size()' member function|a 'data()' member function|'data()' and 'size()' member functions}1"
HF8EFF7FCD3A1: "在%select{此静态断言|此asm操作数}0中的%select{消息|string}0对象缺少%select{'size()'成员函数|'data()'成员函数|'data()'和'size()'成员函数}1"
# "the '%0' unit is not supported with this instruction set"
H66612647AED8: "单元'%0'不受当前指令集支持"
# "the '%select{&|*|->}0' operator is unsupported in HLSL"
H831B25ED6E8C: "操作符'%select{&|*|->}0'在HLSL中不受支持"
# "the '[[_Noreturn]]' attribute spelling is deprecated in C23; use '[[noreturn]]' instead"
H584C1C164ECE: "在C23中，'[[Noreturn]]'属性拼写已弃用；请改用'[[noreturn]]'"
# "the 'copyprivate' clause must not be used with the 'nowait' clause"
H026F61D558F6: "'copyprivate'子句不能与'nowait'子句一起使用"
# "the 'static' modifier for the array size is not legal in new expressions"
H285525BB6E11: "在new表达式中，不允许使用'static'修饰符来指定数组大小"
# "the ApplicationExtensionSafe flag does not match: '%0' (provided) vs '%1' (found)"
H74ECAC68920E: "ApplicationExtensionSafe标志不匹配：提供的'%0'与找到的'%1'"
# 'the GNU address of label extension is not allowed in coroutines'
HEE9FFF3C021C: '协程中不允许使用GNU的标签地址扩展'
# "the NotForDyldSharedCache flag does not match: '%0' (provided) vs '%1' (found)"
HAD9256F7D2F3: "NotForDyldSharedCache标志不匹配：提供的'%0'与找到的'%1'"
# 'the __block storage type is not permitted'
H2951C6144658: '__block存储类型不允许使用'
# 'the address of a declaration with unknown type can only be cast to a pointer type'
H6D4B76B01E9C: '未知类型的声明的地址只能转换为指针类型'
# "the argument '%0' is not supported for option '%1'. Mapping to '%1%2'"
HA4EFCA49DC99: "选项'%1'不支持参数'%0'。映射到'%1%2'"
# "the clang compiler does not support '%0'"
HCB0DF6FD34A3: "clang编译器不支持'%0'"
# "the clang compiler does not support '%0' for C++ on Darwin/i386"
HAB9E0C38E134: "clang编译器在Darwin/i386的C++中不支持'%0'"
# "the clang compiler does not support '%0', %1"
H70791B1776AF: "clang编译器不支持'%0'，%1"
# 'the clang compiler does not support -pg option on %select{Darwin|versions of OS X 10.9 and later}0'
HEC221F97986E: 'clang编译器在%select{Darwin|OS X 10.9及更高版本}0上不支持-pg选项'
# "the combination of '%0' and '%1' is incompatible"
H04D1D2EB3A72: "'%0'和'%1'的组合不兼容"
# "the context %select{set|selector|property}0 '%1' was used already in the same 'omp declare variant' directive; %select{set|selector|property}0 ignored"
H6268D8504255: "在同一个 'omp declare variant' 指令中已经使用了上下文 %select{set|selector|property}0 '%1'；忽略该 %select{set|selector|property}0"
# "the context property '%0' can be nested in the context selector '%1' which is nested in the context set '%2'; try 'match(%2={%1(%0)})'"
HAA758F7206BE: "上下文属性 '%0' 可以嵌套在上下文选择器 '%1' 中，而该选择器又嵌套在上下文集 '%2' 中；尝试使用 'match(%2={%1(%0)})'"
# "the context property '%0' is not valid for the context selector '%1' and the context set '%2'; property ignored"
H88A5B848CED9: "上下文属性 '%0' 对于上下文选择器 '%1' 和上下文集 '%2' 无效；忽略该属性"
# "the context selector '%0' can be nested in the context set '%1'; try 'match(%1={%0%select{|(property)}2})'"
HDD6FFFA1FE6E: "上下文选择器 '%0' 可以嵌套在上下文集 '%1' 中；尝试使用 'match(%1={%0%select{|(property)}2})'"
# "the context selector '%0' in context set '%1' requires a context property defined in parentheses; selector ignored"
H4359A48C4F70: "上下文集 '%1' 中的上下文选择器 '%0' 需要在括号中定义上下文属性；忽略该选择器"
# "the context selector '%0' in the context set '%1' cannot have a score ('%2'); score ignored"
H98F3D66A37F6: "上下文集 '%1' 中的上下文选择器 '%0' 不能带有分数 '%2'；忽略该分数"
# "the context selector '%0' is not valid for the context set '%1'; selector ignored"
HDF7A50F1E9D4: "上下文集 '%1' 中的上下文选择器 '%0' 无效；忽略该选择器"
# "the coroutine promise type %0 declares both 'return_value' and 'return_void'"
H089B386C28E8: "协程承诺类型 %0 同时声明了 'return_value' 和 'return_void'"
# 'the current #pragma pack alignment value is modified in the included file'
H1259B6694648: '包含的文件修改了当前 #pragma pack 对齐值'
# 'the event_t type can only be used with __private address space qualifier'
HF7753CC750DA: 'event_t 类型只能与 __private 地址空间限定符一起使用'
# 'the experimental clang interpreter failed to evaluate an expression'
H0E50C442ED03: '实验性的 clang 解释器无法求值表达式'
# 'the explicit object parameter cannot be a function parameter pack'
HAC332D9FE6A2: '显式对象参数不能是函数参数包'
# 'the explicit object parameter cannot have a default argument'
HEF646D36FD87: '显式对象参数不能有默认参数'
# "the expression 'co_await __promise.final_suspend()' is required to be non-throwing"
HBE8E0E1AD063: "表达式 'co_await __promise.final_suspend()' 需要为不抛出类型"
# "the flag '%0' has been deprecated and will be ignored"
H97F3754670BE: "标志 '%0' 已弃用并将被忽略"
# "the form '-fmodule-file=<BMI-path>' is deprecated for standard C++ named modules; consider to use '-fmodule-file=<module-name>=<BMI-path>' instead"
H9E11832D49AD: "形式 '-fmodule-file=<BMI-path>' 对标准 C++ 命名模块已弃用；建议改用 '-fmodule-file=<module-name>=<BMI-path>'"
# "the given MCU does not support hardware multiply, but '-mhwmult' is set to %0"
HBC73BCBB2AD5: "所指定的 MCU 不支持硬件乘法，但 '-mhwmult' 设置为 %0"
# "the given MCU supports %0 hardware multiply, but '-mhwmult' is set to %1"
H33683D593A85: "所指定的 MCU 支持 %0 硬件乘法，但 '-mhwmult' 设置为 %1"
# 'the host cannot update a declare target variable that is not externally visible'
H626F4DD8E816: '主机无法更新不可外部访问的 declare target 变量'
# 'the ignored %select{set|selector|property}0 spans until here'
H78F2F2873540: '被忽略的 %select{set|selector|property}0 延伸到这里'
# 'the ignored tokens spans until here'
HE724FD8D9E24: '被忽略的标记一直延续到此处'
# 'the implementation of header units is in an experimental phase'
H822B183C153E: '头单元的实现尚处于实验阶段'
# "the implicit output of reduced BMI may be overrided by the output file specified by '--precompile'. please consider use '-fmodule-output=' to specify the output file for reduced BMI explicitly"
HC77BA90C9A9E: "简化的BMI的隐式输出可能被'--precompile'指定的输出文件覆盖。建议使用'-fmodule-output='显式指定简化的BMI的输出文件"
# "the inscan reduction list item must appear as a list item in an 'inclusive' or 'exclusive' clause on an inner 'omp scan' directive"
H5A6903CB5B88: "inscan缩减列表项必须出现在内部'omp scan'指令的'inclusive'或'exclusive'子句的列表项中"
# "the last '/TC' or '/TP' option takes precedence over earlier instances"
H1D4C07143ED6: "最后一个'/TC'或'/TP'选项覆盖前面的实例"
# "the library '%0=%1' is not supported, OpenMP will not be enabled"
H8332E220148A: "库'%0=%1'不受支持，OpenMP将不会启用"
# "the list item must appear in 'reduction' clause with the 'inscan' modifier of the parent directive"
H331559E5A96C: "列表项必须出现在父指令的'reduction'子句中带有'inscan'修饰符的位置"
# 'the loop %select{initializer|condition}0 expression depends on the current loop control variable'
H092C392BA41E: '循环%select{initializer|condition}0表达式依赖于当前循环控制变量'
# "the name of the construct must be specified in presence of 'hint' clause"
HF664729B6FC3: "在存在'hint'子句的情况下，必须指定构造名称"
# 'the number of preprocessor source tokens (%0) exceeds this token limit (%1)'
H205DE1F2F79F: '预处理器源标记的数量（%0）超过此限制（%1）'
# 'the object size sanitizer has no effect at -O0, but is explicitly enabled: %0'
H314C428C1C64: '对象大小检查器在-O0时无效，但被显式启用：%0'
# "the option '-flto=thin' is a work in progress"
H5F57C367214A: "选项'-flto=thin'尚在开发中"
# "the other acquisition of %0 '%1' is here"
HF9475FC44959: "另一个对%0 '%1'的获取在此处"
# 'the parameter for an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 may not be volatile'
HEAA7EB9FB2E0: '显式默认的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0的参数不能是volatile类型'
# 'the parameter for an explicitly-defaulted copy assignment operator must be an lvalue reference type'
H7CAB648A4737: '显式默认的拷贝赋值运算符的参数必须是左值引用类型'
# 'the parameter for an explicitly-defaulted move %select{constructor|assignment operator}0 may not be const'
H34E3C1F201FC: '显式默认的移动%select{构造函数|赋值运算符}0的参数不能是const类型'
# 'the parameter for this explicitly-defaulted copy %select{constructor|assignment operator}0 is const, but a member or base requires it to be non-const'
H7307965D0004: '此显式默认的拷贝%select{构造函数|赋值运算符}0的参数是const，但某个成员或基类要求其为非const'
# "the parameter of the 'ordered' clause must be greater than or equal to the parameter of the 'collapse' clause"
H21ACD6E7D4C2: "'ordered'子句的参数必须大于或等于'collapse'子句的参数"
# 'the pointee of the 2nd argument must match the element type of the 1st argument (%0 != %1)'
H13AC040EDF7B: '第二个参数的被指类型必须与第一个参数的元素类型一致（%0 != %1）'
# 'the pointer decremented by %0 refers before the beginning of the array'
H9FD5D86B7BD7: '减去%0后的指针指向数组的起始位置之前'
# 'the pointer incremented by %0 refers past the end of the array (that has type %1)'
H2098AEB20194: '指针增加%0后指向的地址超出了类型为%1的数组末尾'
# 'the pointer incremented by %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)'
H85FE07542C80: '在 %1 位地址空间中，包含 %2 位（%3 字节）元素的数组的最后一个元素后，指针增加 %0 的结果越界（最大可能元素数 %4 element%s5）'
# "the previous context %select{set|selector|property}0 '%1' used here"
H995F32331A92: "之前使用的上下文%select{设置|选择器|属性}0 '%1' 在此处"
# 'the provided selection does not overlap with the AST nodes of interest'
H10756E8D2178: '提供的选择与感兴趣的AST节点没有重叠'
# 'the referenced item is not found in any private clause on the same directive'
HBDA357C86E91: '在同一个指令中的任何私有子句中都未找到引用项'
# "the result of a delegate init call must be immediately returned or assigned to 'self'"
HA6A6824B2746: "委托初始化调用的结果必须立即返回或赋值给'self'"
# 'the resulting value is always non-negative after implicit conversion'
H9908ECBF3885: '隐式转换后的结果始终为非负值'
# "the second argument of '-fpatchable-function-entry' must be smaller than the first argument"
HEC0EC1D581E8: "参数'-fpatchable-function-entry'的第二个参数必须小于第一个参数"
# "the selected code is not a part of a function's / method's body"
H09129ED39DF9: '所选代码不属于某个函数/方法的主体部分'
# 'the selected expression cannot be extracted'
HC3B7DF91CF84: '无法提取所选表达式'
# 'the selected expression is too simple to extract'
HEFB1186DBBA0: '所选表达式过于简单无法提取'
# 'the semantics of this intrinsic changed with GCC version 4.4 - the newer semantics are provided here'
H1D55F6813757: '该内在函数的语义在GCC版本4.4后有所变化 - 这里提供的是新版本的语义'
# "the statement for '#pragma omp %0' must be a compound statement"
H8597FC2B3D8A: "'#pragma omp %0' 的语句必须是复合语句"
# "the statement for 'atomic capture' must be a compound statement of form '{v = x; x binop= expr;}', '{x binop= expr; v = x;}', '{v = x; x = x binop expr;}', '{v = x; x = expr binop x;}', '{x = x binop expr; v = x;}', '{x = expr binop x; v = x;}' or '{v = x; x = expr;}', '{v = x; x++;}', '{v = x; ++x;}', '{++x; v = x;}', '{x++; v = x;}', '{v = x; x--;}', '{v = x; --x;}', '{--x; v = x;}', '{x--; v = x;}' where x is an lvalue expression with scalar type"
H0E1E5BD56218: "'atomic capture' 的语句必须是以下形式的复合语句：'{v = x; x binop= expr;}'、'{x binop= expr; v = x;}'、'{v = x; x = x binop expr;}'、'{v = x; x = expr binop x;}'、'{x = x binop expr; v = x;}'、'{x = expr binop x; v = x;}' 或 '{v = x; x = expr;}'、'{v = x; x++;}'、'{v = x; ++x;}'、'{++x; v = x;}'、'{x++; v = x;}'、'{v = x; x--;}'、'{v = x; --x;}'、'{--x; v = x;}'、'{x--; v = x;}'，其中 x 是标量类型左值表达式"
# "the statement for 'atomic capture' must be an expression statement of form 'v = ++x;', 'v = --x;', 'v = x++;', 'v = x--;', 'v = x binop= expr;', 'v = x = x binop expr' or 'v = x = expr binop x', where x and v are both lvalue expressions with scalar type"
H47D428195CE9: "'atomic capture' 的语句必须是以下形式的表达式语句：'v = ++x;'、'v = --x;'、'v = x++;'、'v = x--;'、'v = x binop= expr;'、'v = x = x binop expr' 或 'v = x = expr binop x'，其中 x 和 v 均为标量类型左值表达式"
# "the statement for 'atomic compare capture' must be a compound statement of form '{v = x; cond-up-stmt}', ''{cond-up-stmt v = x;}', '{if(x == e) {x = d;} else {v = x;}}', '{r = x == e; if(r) {x = d;}}', or '{r = x == e; if(r) {x = d;} else {v = x;}}', where 'cond-update-stmt' can have one of the following forms: 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', or 'if(e == x) {x = d;}' where 'x', 'r', and 'v' are lvalue expressions with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '<' or '>'"
H09C6A6DB560B: "'atomic compare capture' 的语句必须是以下形式的复合语句：'{v = x; cond-up-stmt}'、'{cond-up-stmt v = x;}'、'{if(x == e) {x = d;} else {v = x;}}'、'{r = x == e; if(r) {x = d;}}' 或 '{r = x == e; if(r) {x = d;} else {v = x;}}'，其中 'cond-update-stmt' 可以是以下形式之一：'if(expr ordop x) {x = expr;}'、'if(x ordop expr) {x = expr;}'、'if(x == e) {x = d;}' 或 'if(e == x) {x = d;}'，其中 'x'、'r'、'v' 是标量类型左值表达式，'expr'、'e'、'd' 是标量类型表达式，'ordop' 是 '<' 或 '>' 中的一个"
# "the statement for 'atomic compare' must be a compound statement of form '{x = expr ordop x ? expr : x;}', '{x = x ordop expr? expr : x;}', '{x = x == e ? d : x;}', '{x = e == x ? d : x;}', or 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', 'if(e == x) {x = d;}' where 'x' is an lvalue expression with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '<' or '>'"
H4091D9BED6D2: "'atomic compare' 的语句必须是以下形式的复合语句：'{x = expr ordop x ? expr : x;}'、'{x = x ordop expr ? expr : x;}'、'{x = x == e ? d : x;}'、'{x = e == x ? d : x;}' 或 'if(expr ordop x) {x = expr;}'、'if(x ordop expr) {x = expr;}'、'if(x == e) {x = d;}'、'if(e == x) {x = d;}'，其中 'x' 是标量类型左值表达式，'expr'、'e'、'd' 是标量类型表达式，'ordop' 是 '<' 或 '>' 中的一个"
# "the statement for 'atomic read' must be an expression statement of form 'v = x;', where v and x are both lvalue expressions with scalar type"
HDAD21CA5AD66: "'atomic update'的语句必须是形式为'++x;'等的表达式语句"
# "the statement for 'atomic update' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type"
H106E8810ABCE: "'atomic write'的语句必须是形式为'x = expr;'的表达式语句"
# "the statement for 'atomic write' must be an expression statement of form 'x = expr;', where x is a lvalue expression with scalar type"
HAEE051C701D8: "用于'atomic write'的语句必须是形式为'x = expr;'的表达式语句，其中x是标量类型的左值表达式"
# "the statement for 'atomic' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type"
H182C909CFBBD: "用于'atomic'的语句必须是形式为'++x;'、'--x;'、'x++;'、'x--;'、'x binop= expr;'、'x = x binop expr'或'x = expr binop x'的表达式语句，其中x是标量类型的左值表达式"
# "the target architecture '%0' is not supported by the target '%1'"
H9EB5284C09D2: "目标架构'%0'不受目标'%1'支持"
# 'the total number of preprocessor source tokens (%0) exceeds the token limit (%1)'
H8A02325A6920: '预处理器源代码标记总数(%0)超过了标记限制(%1)'
# 'the two-parameter std::span construction is unsafe as it can introduce mismatch between buffer size and the bound information'
HB6B2C19333E2: '两个参数的std::span构造可能因缓冲区大小和边界信息不匹配而存在风险'
# 'the type %0 is already explicitly ownership-qualified'
H462F56962031: '类型%0已经显式具有所有权限定符'
# 'the type %0 is not a pointer to a fast-enumerable object'
HF043D197C95F: '类型%0不是指向快速可枚举对象的指针'
# 'the type of object expression %diff{($) does not match the type being destroyed ($)|does not match the type being destroyed}0,1 in pseudo-destructor expression'
HF8245CD4DD36: '对象表达式%diff{($)的类型与伪析构表达式中正在销毁的类型($)|不匹配}0,1'
# 'the type of the explicit object parameter of an explicitly-defaulted %select{copy|move}0 assignment operator should be reference to %1'
H48B3F2D609BF: '显式默认的%select{拷贝|移动}0赋值运算符的显式对象参数类型应为%1的引用'
# 'the user condition in the OpenMP context selector needs to be constant; %0 is not'
H518CAE3CEA63: 'OpenMP上下文选择器中的用户条件需要是常量；%0不是'
# "the value of 'simdlen' parameter must be less than or equal to the value of the 'safelen' parameter"
H05F684C1DEC1: "'simdlen'参数的值必须小于或等于'safelen'参数的值"
# "the value of the size argument in 'strncat' is too large, might lead to a buffer overflow"
H7CBEE5BA8363: "'strncat'的size参数值过大，可能导致缓冲区溢出"
# "the value of the size argument to 'strncat' is wrong"
H10EE22A40549: "'strncat'的size参数值有误"
# 'the vecreturn attribute can only be used on a POD (plain old data) class or structure (i.e. no virtual functions)'
HB24B6E1BF839: 'vecreturn属性只能用于POD（普通旧数据）类或结构体（即没有虚函数）'
# 'the vecreturn attribute can only be used on a class or structure with one member, which must be a vector'
H91431B029CC5: 'vecreturn属性只能用于包含一个成员的类或结构体，该成员必须是向量类型'
# "the warning option '-%0' is not supported"
H961C96696067: "警告选项'-%0'不受支持"
# 'there is no external assembler that can be used on this platform'
H36CA569B9742: '当前平台没有可用的外部汇编器'
# 'there is no symbol at the given location'
H99C4AECFC4C8: '在给定位置没有找到符号'
# 'this builtin is available only on AIX 7.2 and later operating systems'
H6E604B084F43: '该内置函数仅适用于AIX 7.2及更高版本操作系统'
# 'this builtin is only available on 32-bit targets'
H56D31FAC556E: '该内置函数仅支持32位目标平台'
# 'this builtin is only available on 64-bit targets'
HC0C706B2D8E7: '此内置函数仅在64位目标平台上可用'
# 'this builtin is only available on x86-64 and aarch64 targets'
H81BF150D8949: '此内置函数仅在x86-64和aarch64目标平台上可用'
# "this builtin requires 'dsp r2' ASE, please use -mdspr2"
HF59F7FBACC6E: "此内置函数需要'dsp r2' ASE，请使用-mdspr2选项"
# "this builtin requires 'dsp' ASE, please use -mdsp"
H2B317AB4FDC4: "此内置函数需要'dsp' ASE，请使用-mdsp选项"
# "this builtin requires 'msa' ASE, please use -mmsa"
H25EA8026E312: "此内置函数需要'msa' ASE，请使用-mmsa选项"
# 'this builtin requires ABI -mabi=%0'
H6643558E97E9: '此内置函数需要ABI -mabi=%0'
# 'this coroutine may be split into pieces; not every piece is guaranteed to be inlined'
HEF5E3EA3F783: '此协程可能被拆分为多个部分；并非每个部分都能保证被内联'
# "this declaration is not a prototype; add %select{'void'|parameter declarations}0 to make it %select{a prototype for a zero-parameter function|one}0"
HDD90A70940A7: '此声明不是函数原型；请添加%select{void|参数声明}0使其成为%select{一个无参数函数的原型|一个}0'
# 'this expression will be parsed as explicit(bool) in C++20'
HE2974A48FA92: '在C++20中，此表达式将被视为显式(bool)转换'
# 'this function cannot be a coroutine: %0 is an incomplete type'
HEB887A198DFF: '此函数不能是协程：%0 是一个不完整类型'
# 'this function cannot be a coroutine: %0 is not a class'
HF896DD5CD9DB: '此函数不能是协程：%0 不是一个类'
# "this function cannot be a coroutine: %q0 has no member named 'promise_type'"
HAD42B5488901: '此函数不能是协程：%q0 没有名为"promise_type"的成员'
# 'this function cannot be a coroutine: missing definition of specialization %0'
HFC5D41C5C0FA: '此函数不能是协程：缺少特化定义 %0'
# 'this is generally caused by modules with the same name found in multiple paths'
HB435423839CE: '这通常是由多个路径下找到同名模块所导致的'
# 'this placement new expression is not supported in constant expressions %select{|before C++2c}0'
HFED2CB8F9A5D: '在常量表达式中不支持此placement new表达式%select{|在C++2c之前}0'
# 'this pragma cannot appear in %0 declaration'
HCE58A657A4E9: '此#pragma不能出现在%0声明中'
# 'this style of line directive is a GNU extension'
H0B9D785486F6: '这种形式的行指令是GNU扩展'
# 'this target does not support pointer authentication'
HB298CA51FDBD: '此目标平台不支持指针认证'
# 'this type tag was not designed to be used with this function'
H6E259EADA90E: '此类型标签未设计为此函数使用'
# 'this use of statement expressions is not supported in a constant expression'
H15F3A7193C9C: '在常量表达式中不支持这种语句表达式用法'
# 'this value is too large for this fixed point type'
HC641D92F0E57: '该值对这种固定点类型来说过大'
# 'this warning is no longer in use and will be removed in the next release'
H0EF268B5B2F9: '此警告已不再使用，将在下一版本中移除'
# 'thread safety beta warning'
HB0419777F950: '线程安全Beta警告'
# 'thread safety verbose warning'
H313BE85969C3: '线程安全详细警告'
# 'thread warning in function %0'
H36B44B602302: '函数%0中的线程警告'
# 'thread-local declaration of %0 follows non-thread-local declaration'
HEFF70126975B: '%0的线程局部声明紧跟非线程局部声明'
# 'thread-local declaration of %0 with %select{static|dynamic}1 initialization follows declaration with %select{dynamic|static}1 initialization'
H912C45CDB374: '%0的线程局部声明带有%select{静态|动态}1初始化，而之前的声明使用的是%select{动态|静态}1初始化'
# 'thread-local storage is not supported for the current target'
H98D675ADC45A: '当前目标平台不支持线程局部存储'
# 'thread-local variable has non-trivial ownership: type is %0'
H6F11C930F55E: '线程局部变量具有非平凡的所有权：类型为%0'
# 'threadprivate variable with incomplete type %0'
HCB733257A55A: '线程私有变量具有不完整类型%0'
# "threadprivate variables are not allowed in '%0' clause"
HEEB356882606: "'%0'子句中不允许使用线程私有变量"
# 'threadprivate variables cannot be used in target constructs'
HB21F31B22998: '线程私有变量不能在目标构造中使用'
# 'three-way comparison between pointer and zero'
HD3520571E10A: '指针与零的三向比较'
# 'three-way comparison between vectors is not supported'
H00B5B249986A: '向量之间的三向比较不被支持'
# "three-way comparison cannot be synthesized because there is no viable function for %select{'=='|'<'}0 comparison"
H6263B6389D1C: '无法合成三向比较，因为没有可用的%select{等于|小于}0比较函数'
# 'tile arguments must refer to different tiles'
HC74F5110780C: '瓦片参数必须引用不同的瓦片'
# "timed out waiting to acquire lock file for module '%0'"
HD7ADFA168199: "等待获取模块'%0'的锁文件超时"
# 'tls_model must be "global-dynamic", "local-dynamic", "initial-exec" or "local-exec"'
H2BCDC88FA47E: 'tls_model必须是"global-dynamic"、"local-dynamic"、"initial-exec"或"local-exec"'
# 'to match this %0'
HDA13A5D2D868: '与这个%0匹配'
# "to match this ']'"
HEF9A1EC0D665: "与这个']'匹配"
# "to match this '{'"
H013B6E508561: "以匹配这个 '{'"
# 'token is not a valid binary operator in a preprocessor subexpression'
H93EB0C533EDF: '该标记不是预处理子表达式中的有效二元运算符'
# "token pasting of ',' and __VA_ARGS__ is a GNU extension"
H13889DCFA50D: "用 ',' 和 __VA_ARGS__ 进行标记粘贴是GNU扩展"
# 'too %select{few|many}0 arguments in call to %1'
H55C9E37AE906: '调用 %1 时参数%select{太少|太多}0'
# 'too %select{few|many}0 initializers in list for type %1 (expected %2 but found %3)'
HD545C2517E80: '类型 %1 的初始化列表中初始化项%select{太少|太多}0（预期 %2 但找到 %3）'
# 'too %select{few|many}0 parameters in the signature specified by the %1 attribute (expected %2; got %3)'
H6F4276FDBDF1: '由 %1 属性指定的签名中参数%select{太少|太多}0（预期 %2；实际 %3）'
# 'too %select{many|few}0 type arguments for class %1 (have %2, expected %3)'
H35A08DFD5F2A: '类 %1 的类型参数%select{太多|太少}0（已有 %2，预期 %3）'
# 'too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, at least argument %1 must be specified'
HF6BA10037D33: '调用 %select{函数|代码块|方法|内核函数}0 时，%select{|||执行配置 }0%select{|非对象 }2参数不足，至少必须指定参数 %1'
# 'too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, single argument %1 was not specified'
H9CA8A408A5C7: '调用 %select{函数|代码块|方法|内核函数}0 时，%select{|||执行配置 }0%select{|非对象 }2参数不足，单个参数 %1 未指定'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2'
H5939FAB31ED6: '调用 %select{函数|代码块|方法|内核函数}0 时，%select{|||执行配置 }0%select{|非对象 }3参数不足，预期 %1 个参数，但仅有 %2 个'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?'
HF20F679C52F2: '调用 %select{函数|代码块|方法|内核函数}0 时，%select{|||执行配置 }0%select{|非对象 }3参数不足，预期 %1 个参数，但仅有 %2 个；是否应使用 %4？'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2'
HD24171A04B0B: '调用 %select{函数|代码块|方法|内核函数}0 时，%select{|||执行配置 }0%select{|非对象 }3参数不足，预期至少 %1 个参数，但仅有 %2 个'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2; did you mean %4?'
HD3BBC6D9EFC0: '调用 %select{函数|代码块|方法|内核函数}0 时，%select{|||执行配置 }0%select{|非对象 }3参数不足，预期至少 %1 个参数，但仅有 %2 个；是否应使用 %4？'
# 'too few arguments provided to function-like macro invocation'
H1E346A7B8B3C: '函数式宏调用提供的参数太少'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2'
H90F884ECB318: '对 %select{函数|代码块|方法|内核函数}0 的调用参数过多，%select{|||执行配置 }0%select{|非对象 }3参数，期望 %1 个，实际有 %2 个'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?'
HCA745DFE1FDF: '对 %select{函数|代码块|方法|内核函数}0 的调用参数过多，%select{|||执行配置 }0%select{|非对象 }3参数，期望 %1 个，实际有 %2 个；是否应改为 %4？'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2'
H94A2619722A2: '对 %select{函数|代码块|方法|内核函数}0 的调用参数过多，%select{|||执行配置 }0%select{|非对象 }3参数，期望最多 %1 个，实际有 %2 个'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2; did you mean %4?'
HE9A38EF19888: '对 %select{函数|代码块|方法|内核函数}0 的调用参数过多，%select{|||执行配置 }0%select{|非对象 }3参数，期望最多 %1 个，实际有 %2 个；是否应改为 %4？'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected single argument %1, have %2 arguments'
HDBD2C1E2CE61: '对 %select{函数|代码块|方法|内核函数}0 的调用参数过多，%select{|||执行配置 }0%select{|非对象 }3参数，期望单个参数 %1，实际有 %2 个参数'
# 'too many %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected at most single %select{|non-object }3argument %1, have %2%select{|non-object}3 arguments'
HDAC13624D426: '对 %select{函数|代码块|方法|内核函数}0 的调用参数过多，%select{|||执行配置 }0参数，期望最多单个 %select{|非对象 }3参数 %1，实际有 %2%select{|非对象}3 参数'
# 'too many arguments provided to function-like macro invocation'
HBB5E8EFBFD08: '提供给函数式宏调用的参数过多'
# 'too many braces around %select{scalar |}0initializer'
H5C95D607138A: '在%select{标量 |}0初始化器周围有过多的花括号'
# 'too many errors emitted, stopping now'
H208E3BCCF078: '报告了过多的错误，现在停止'
# 'too many function parameters; subsequent parameters will be ignored'
H803517A338E0: '函数参数过多；后续参数将被忽略'
# "too many parameters (%0) for 'main': must be 0, 2, or 3"
H39E16B39631F: "'main'函数的参数过多（%0）：必须为0、2或3"
# 'top-level comma expression in array subscript is deprecated in C++20 and unsupported in C++23'
HE89EE6B0F334: '数组下标中的顶层逗号表达式在C++20中已弃用，并在C++23中不受支持'
# 'total number of threads cannot exceed %0'
H1884DB567221: '线程总数不能超过%0'
# 'total token limit set here'
HC6BF74A3FD57: '此处设置的总标记限制'
# 'trailing requires clause can only be used when declaring a function'
H084306C3877A: '尾随requires子句只能在声明函数时使用'
# 'trailing requires clause should be placed outside parentheses'
H548F58E8723A: '尾随requires子句应放在括号之外'
# 'trailing return type may not be nested within parentheses'
HC76578BE367C: '尾随返回类型不能嵌套在括号内'
# 'trailing return type must appear before trailing requires clause'
HA5D12CC5013B: '尾随返回类型必须出现在尾随requires子句之前'
# 'trailing return types are incompatible with C++98'
H32DC951D7875: '尾随返回类型与C++98不兼容'
# 'translation unit contains multiple module declarations'
HF895A4F45EF2: '翻译单元包含多个模块声明'
# 'translation unit is too large for Clang to process: ran out of source locations'
H8B3695BCDB65: '翻译单元太大，Clang无法处理：源位置已用尽'
# 'transparent union definition must contain at least one field; transparent_union attribute ignored'
H140F1B74DF83: '透明联合体定义必须包含至少一个字段；transparent_union属性被忽略'
# 'transparent_union attribute can only be applied to a union definition; attribute ignored'
HD786E3576B74: 'transparent_union属性只能应用于联合定义；属性被忽略'
# 'treat the string as an argument to avoid this'
H276A4BE7C44E: '将字符串视为参数以避免此错误'
# "treating #%select{include|import|include_next|__include_macros}0 as an import of module '%1'"
HCF878B660176: "将#%select{include|import|include_next|__include_macros}0视为模块'%1'的导入"
# "treating '%0' input as '%1' when in C++ mode, this behavior is deprecated"
H0FA024F7C782: "在C++模式下将'%0'输入视为'%1'，此行为已弃用"
# 'treating Ctrl-Z as end-of-file is a Microsoft extension'
H2B9F3B693225: '将Ctrl-Z视为文件结束符是Microsoft扩展'
# "treating Unicode character <U+%0> as an identifier character rather than as '%1' symbol"
H50914464E633: "将Unicode字符<U+%0>视为标识符字符而不是'%1'符号"
# 'treating Unicode character as whitespace'
HF7B2E2527DE4: '将Unicode字符视为空白符'
# "trigraph converted to '%0' character"
HED476D72F781: "三元组转换为'%0'字符"
# 'trigraph ends block comment'
H52594FE74E90: '三元组结束块注释'
# 'trigraph ignored'
H1C535A7D3139: '忽略三元组'
# "try 'match(%0={%1%2})'"
H766B462800CF: "尝试'match(%0={%1%2})'"
# 'trying to recursively use %0 as superclass of %1'
H22C1DF007CBE: '尝试递归使用%0作为%1的超类'
# 'type %0 can only be used as a function parameter in OpenCL'
H43CCACC05DF1: '类型%0只能在OpenCL中用作函数参数'
# 'type %0 cannot be decomposed'
HAD575CEF4CDD: '类型%0无法分解'
# 'type %0 cannot be narrowed to %1 in initializer list'
HA66630D471E5: '类型%0在初始化列表中无法缩小为%1'
# 'type %0 cannot be narrowed to %1 in initializer list in C++11'
H121C0CF66257: '类型%0在C++11的初始化列表中无法缩小为%1'
# "type %0 cannot be used prior to '::' because it has no members"
HB29A2AE6A5EB: "类型%0在'::'之前无法使用，因为它没有成员"
# 'type %0 decomposes into %3 %plural{1:element|:elements}2, but %select{%plural{0:no|:only %1}1|%1}4 %plural{1:name was|:names were}1 provided'
HF59CA2FD696F: '类型%0分解为%3 %plural{1:element|:elements}2，但提供了%select{%plural{0:no|:only %1}1|%1}4 %plural{1:name was|:names were}1'
# 'type %0 does not provide a %select{subscript|call}1 operator'
HCAF6714D32F7: '类型%0未提供%select{subscript|call}1运算符'
# 'type %0 found by destructor name lookup'
H35BD375D3364: '通过析构函数名称查找找到类型%0'
# 'type %0 has incompatible definitions in different translation units'
HB192C667507F: '类型%0在不同的翻译单元中具有不兼容的定义'
# 'type %0 has unexpected layout'
H8C8909F11F0A: '类型%0具有意外的布局'
# 'type %0 in generic association compatible with previously specified type %1'
H1178A958ED5C: '通用关联中的类型%0与之前指定的类型%1兼容'
# 'type %0 in generic association is a variably modified type'
HCA8F3A82743E: '通用关联中的类型%0是一个variably modified type'
# 'type %0 in generic association not an object type'
H9CBDAFFFD0D2: '类型 %0 在泛型关联中不是对象类型'
# 'type %0 is incomplete'
H68C687943CFB: '类型 %0 是不完整的'
# 'type %0 is not a direct or virtual base of %1'
HA6EFF9DEE3C5: '类型 %0 不是 %1 的直接或虚基类'
# 'type %0 is not trivially copyable and not guaranteed to be mapped correctly'
HA6A4CD2AE815: '类型 %0 不是平凡可复制的，且无法保证正确映射'
# 'type %0 of function parameter pack does not contain any unexpanded parameter packs'
H5D64B61067E5: '函数参数包 %0 中不包含未展开的参数包'
# 'type %0 of non-type template parameter is not a structural type'
H546F4F02218C: '非类型模板参数的类型 %0 不是结构性类型'
# 'type %0 requires %1 bytes of alignment and the default allocator only guarantees %2 bytes'
H82A5F7C1A758: '类型 %0 需要 %1 字节的对齐，而默认分配器仅保证 %2 字节'
# 'type %2 of %select{explicit instantiation|explicit specialization|partial specialization|redeclaration}0 of %1 does not match expected type %3'
H34154FB5D28F: '%select{显式实例化|显式特化|部分特化|重新声明}0 的 %1 的 %2 类型与预期类型 %3 不匹配'
# "type argument %0 cannot be qualified with '%1'"
HF21B2C8937B4: '类型参数 %0 不能用 "%1" 进行限定'
# 'type argument %0 cannot explicitly specify nullability'
H1330164CF91E: '类型参数 %0 不能显式指定空安全性'
# 'type argument %0 does not satisfy the bound (%1) of type parameter %2'
H3669CF5C9A7D: '类型参数 %0 不满足类型参数 %2 的边界（%1）'
# 'type argument %0 is neither an Objective-C object nor a block type'
HC89732C094A1: '类型参数 %0 既不是 Objective-C 对象，也不是块类型'
# "type argument %0 must be a pointer (requires a '*')"
HF674997DE917: '类型参数 %0 必须是指针（需要一个 "*"）'
# 'type argument of iboutletcollection attribute cannot be a builtin type'
H26C24AC03DB8: 'iboutletcollection 属性的类型参数不能是内置类型'
# 'type arguments cannot be applied to already-specialized class type %0'
H67EB09767F26: '无法将类型参数应用于已特化的类类型 %0'
# 'type arguments cannot be applied to non-class type %0'
H41CCF55FF38B: '无法将类型参数应用于非类类型 %0'
# 'type arguments cannot be applied to non-parameterized class %0'
HC40C2F44A862: '无法将类型参数应用于非参数化类 %0'
# 'type bound %0 for type parameter %1 conflicts with %select{implicit|previous}2 bound %3%select{for type parameter %5|}4'
H7F10FC1165B9: '类型参数 %1 的类型边界 %0 与 %select{隐式|之前的}2 边界 %3%select{对类型参数 %5|}4 冲突'
# 'type bound %0 for type parameter %1 is not an Objective-C pointer type'
H80B67C4F94CD: '类型参数 %1 的类型边界 %0 不是 Objective-C 指针类型'
# "type bound %1 for type parameter %0 cannot be qualified with '%2'"
H3CC7E562DE4D: '类型参数 %0 的类型边界 %1 不能用 "%2" 进行限定'
# 'type constraint differs in template redeclaration'
HA94E71A6CC7A: '模板重新声明中类型约束不同'
# 'type conversion function declared here'
H7B0CCA1F5818: '类型转换函数在此处声明'
# 'type declaration hidden'
H161A31411076: '类型声明被隐藏'
# 'type definition in a constexpr %select{function|constructor}0 is a C++14 extension'
HB61A32D40D4A: 'constexpr %select{函数|构造函数}0 中的类型定义是C++14扩展'
# 'type definition in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
H51291DDF6B58: 'constexpr %select{函数|构造函数}0 中的类型定义与C++14之前的版本不兼容'
# 'type inference of a declaration other than a plain identifier with optional trailing attributes is a Clang extension'
HB4EF9FC7F52F: '非普通标识符（可带尾置属性）的类型推导是Clang扩展'
# 'type is given name %0 for linkage purposes by this %select{typedef|alias}1 declaration'
HFEABA5A13E20: '此%select{typedef|别名}1声明为链接目的将类型命名为%0'
# 'type is not C-compatible due to this %select{base class|default member initializer|lambda expression|friend declaration|member declaration}0'
H8BEB926AC2A7: '由于以下%select{基类|默认成员初始化器|lambda表达式|友元声明|成员声明}0，类型不兼容C兼容'
# 'type name does not allow %select{<ERROR>|constexpr|consteval|constinit}0 specifier to be specified'
H2BAC4BD9B411: '类型名称不允许指定%select{<ERROR>|constexpr|consteval|constinit}0说明符'
# 'type name does not allow function specifier to be specified'
H63933758FA41: '类型名称不允许指定函数说明符'
# 'type name does not allow storage class to be specified'
HD221C2943356: '类型名称不允许指定存储类'
# 'type name requires a specifier or qualifier'
H9BCBB335F47F: '类型名称需要指定说明符或限定符'
# 'type nullability specifier %0 is a Clang extension'
HFDBD8198839C: '类型空值限定符%0是Clang扩展'
# 'type of %ordinal0 parameter of local declaration does not match definition%diff{ ($ vs $)|}1,2'
HC35F751A0E20: '本地声明第%ordinal0参数的类型与定义不匹配%diff{ ($ vs $)|}1,2'
# 'type of %ordinal0 parameter of member declaration does not match definition%diff{ ($ vs $)|}1,2'
H6D265791AD7D: '成员声明第%ordinal0参数的类型与定义不匹配%diff{ ($ vs $)|}1,2'
# 'type of UTF-8 string literal will change from array of char to array of char8_t in C23'
HDD96729D3F80: '在C23中，UTF-8字符串字面量的类型将从char数组变为char8_t数组'
# 'type of UTF-8 string literal will change from array of const char to array of const char8_t in C++20'
H2FF4EC88FBDF: '在C++20中，UTF-8字符串字面量的类型将从const char数组变为const char8_t数组'
# 'type of machine mode does not match type of base type'
HCC37C6223BD0: '机器模式类型与基类型类型不匹配'
# 'type of machine mode does not support base vector types'
HC82FE5FB775E: '机器模式类型不支持基础向量类型'
# 'type of property %0 (%1) does not match type of accessor %2 (%3)'
H588E7AE2B664: '属性%0 (%1)的类型与访问器%2 (%3)的类型不匹配'
# 'type of property %0 (%1) does not match type of instance variable %2 (%3)'
H73BAE4F8734B: '属性 %0 (%1) 的类型与实例变量 %2 (%3) 的类型不匹配'
# 'type of property %0 does not match type of accessor %1'
H270F876040C0: '属性 %0 的类型与访问器 %1 的类型不匹配'
# 'type of property %0 in class extension does not match property type in primary class'
H132F7594C298: '类扩展中的属性 %0 类型与主类中的属性类型不匹配'
# 'type of setter must be void'
HD41AE4C60492: '设置器的类型必须为 void'
# 'type of specialized non-type template argument depends on a template parameter of the partial specialization'
HBDE8FF32FC3A: '部分特化模板参数的非类型模板实参类型依赖于该部分特化的模板参数'
# 'type of thread-local variable has non-trivial destruction'
H8E6776B80F65: '线程局部变量的类型具有非平凡析构'
# "type operand %0 of 'typeid' cannot have '%1' qualifier"
HBE87B8BABE8E: "运算符 'typeid' 的类型操作数 %0 不能带有 '%1' 限定符"
# 'type parameter %0 bound %1 cannot explicitly specify nullability'
H73C9FD2AB78B: '类型参数 %0 的绑定 %1 不能显式指定空安全属性'
# 'type parameter %0 declared here'
HFF5B8C2A68FC: '类型参数 %0 在此处声明'
# "type specifier missing, defaults to 'int'"
H4B268E82A57A: "缺少类型说明符，缺省为 'int'"
# "type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int"
H8CEE1B0F6CB9: "缺少类型说明符，缺省为 'int'; ISO C99 及后续标准不支持隐式 int"
# 'type trait requires %0%select{| or more}1 argument%select{|s}2; have %3 argument%s3'
H5F2DEBC2DD6F: '类型特征需要 %0%select{|或更多}1 参数%select{|s}2；但提供了 %3 参数%s3'
# 'type was declared read-only here'
HAFE8C580C1C1: '类型在此处被声明为只读'
# 'type-id cannot have a name'
H0F4A38BF6BC0: '类型标识符不能有名称'
# 'type-less parameter names in function declaration'
H4275A67CD2BD: '函数声明中存在无类型参数名称'
# 'typedef declarator cannot be qualified'
H13CBEB4EC130: 'typedef 声明符不能有限定符'
# 'typedef member %0 cannot be a bit-field'
HF1C17DDE556A: 'typedef 成员 %0 不能是位域'
# 'typedef name must be an identifier'
H0FF9C8135AE0: 'typedef 名称必须是标识符'
# 'typedef requires a name'
HD4A732841C3B: 'typedef 需要一个名称'
# 'typeid applied to expression of polymorphic type %0 is not allowed in a constant expression in C++ standards before C++20'
H56E5AEAEB4DB: '在 C++20 之前的 C++ 标准中，对多态类型 %0 的表达式应用 typeid 不允许出现在常量表达式中'
# 'typeid will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0'
H44DAF1F1B628: 'typeid 无法工作，因为 RTTI 数据被 %select{-fno-rtti-data|/GR-}0 禁用'
# 'typename is allowed for identifiers only'
HEE2C4836DC27: 'typename 仅允许用于标识符'
# 'typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0 member in %1; argument deduction not allowed here'
H15F65651B175: 'typename 指定符引用 %select{类模板|函数模板|变量模板|别名模板|模板模板参数|模板}0 的成员 %1；此处不允许参数推导'
# 'typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0; argument deduction not allowed here'
HDDA5FA8262A7: 'typename 指定符引用 %select{类模板|函数模板|变量模板|别名模板|模板模板参数|模板}0；此处不允许参数推导'
# 'typename specifier refers to a dependent using declaration for a value %0 in %1'
HA4640204C28B: 'typename 指定符引用一个依赖的 using 声明的值 %0 在 %1 中'
# 'typename specifier refers to a non-type template'
HDA01E7DE1981: 'typename 指定符引用非类型模板'
# 'typename specifier refers to non-type %0'
H68FFAB15F6B4: 'typename 指定符引用非类型 %0'
# 'typename specifier refers to non-type member %0 in %1'
HAD3AB5D3DF5D: 'typename 指定符引用 %1 中的非类型成员 %0'
# 'types cannot be declared in an anonymous %select{struct|union}0'
HB8A6E3596B04: '类型不能在匿名 %select{struct|union}0 中声明'
# 'types declared in an anonymous %select{struct|union}0 are a Microsoft extension'
H10CD33288972: '匿名 %select{struct|union}0 中声明的类型是 Microsoft 扩展'
# 'types may not be defined in a for range declaration'
HA0579AB1E4A8: 'for 范围声明中不能定义类型'
# "types with 'sycl_special_class' attribute must have one and only one '__init' method defined"
H49F85977919C: "具有 'sycl_special_class' 属性的类型必须定义且仅定义一个 '__init' 方法"
# "umbrella directory '%0' not found"
H7F60E99942C1: "umbrella 目录 '%0' 未找到"
# "umbrella for module '%0' already covers this directory"
HAE8DEE1E4013: "模块 '%0' 的 umbrella 已覆盖此目录"
# "umbrella header for module '%0' does not include header '%1'"
H803B3F536D5A: "模块 '%0' 的 umbrella 头文件未包含头文件 '%1'"
# "unable to create target: '%0'"
H48D73D54C838: '无法创建目标："%0"'
# 'unable to execute command: %0'
H1274C3267D8B: '无法执行命令：%0'
# "unable to find %0 directory, expected to be in '%1' found via %2"
HFA08DE02A86A: "无法找到 %0 目录，预期位于通过 %2 定位的 '%1'"
# "unable to find %select{'::operator new(size_t, nothrow_t)'|'::operator new(size_t, align_val_t, nothrow_t)'}1 for %0"
HD53B43D38AB3: "无法为 %0 找到 %select{'::operator new(size_t, nothrow_t)'|'::operator new(size_t, align_val_t, nothrow_t)'}1"
# 'unable to find a Visual Studio installation; try running Clang from a developer command prompt'
HD5A60BEBFC34: '未找到 Visual Studio 安装；尝试从开发者命令提示符运行 Clang'
# "unable to find module '%0'"
H4F4B8FBAA599: '无法找到模块“%0”'
# "unable to find plugin '%0'"
H694242203542: '无法找到插件“%0”'
# "unable to handle compilation, expected exactly one compiler job in '%0'"
H0ED90FBA3001: '无法处理编译，期望在“%0”中恰好有一个编译任务'
# 'unable to interface with target machine'
H48913BEFE8AE: '无法与目标机器建立接口'
# 'unable to load PCH file'
H0C8F5802F259: '无法加载PCH文件'
# "unable to load basic block sections function list: '%0'"
H3C61D53F0989: '无法加载基本块节函数列表：“%0”'
# "unable to load plugin '%0': '%1'"
HEABDF34863F0: '无法加载插件“%0”：“%1”'
# 'unable to make temporary file: %0'
HB69A4D68B994: '无法创建临时文件：%0'
# "unable to merge a subprocess's serialized diagnostics"
H0736A846C8D2: '无法合并子进程的序列化诊断信息'
# 'unable to open CC_LOG_DIAGNOSTICS file: %0 (using stderr)'
H5386FA1E767C: '无法打开CC_LOG_DIAGNOSTICS文件：%0（使用标准错误输出）'
# 'unable to open CC_PRINT_HEADERS file: %0 (using stderr)'
H9ABA30151CEC: '无法打开CC_PRINT_HEADERS文件：%0（使用标准错误输出）'
# 'unable to open CC_PRINT_OPTIONS file: %0'
HEA741366E890: '无法打开CC_PRINT_OPTIONS文件：%0'
# 'unable to open file %0 for serializing diagnostics (%1)'
HD09A684B5E47: '无法打开文件%0用于序列化诊断信息（%1）'
# "unable to open output file '%0': '%1'"
H1FD155FFBE98: '无法打开输出文件“%0”：“%1”'
# "unable to open statistics output file '%0': '%1'"
HDC9884A86150: '无法打开统计信息输出文件“%0”：“%1”'
# 'unable to overwrite file %0: %1'
HF040F371E4DB: '无法覆盖文件%0：%1'
# 'unable to protect inline asm that clobbers stack pointer against stack clash'
H57F37138A9DF: '无法保护破坏堆栈指针的内联汇编以防止堆栈冲突'
# "unable to read PCH file %0: '%1'"
H53BCE7FDE626: '无法读取PCH文件%0：“%1”'
# 'unable to remove file: %0'
HA87F741C0BFD: '无法删除文件：%0'
# "unable to rename temporary '%0' to output file '%1': '%2'"
H621AA5D0DBAB: '无法将临时文件“%0”重命名为输出文件“%1”：“%2”'
# 'unable to resolve declare reduction construct for type %0'
H4CBC0B2EAEEC: '无法解析类型%0的声明式规约构造'
# 'unable to set working directory: %0'
H1915AC32A7BB: '无法设置工作目录：%0'
# 'unannotated fall-through between switch labels'
HD2F0C0FDF581: 'switch标签间的未注释穿透'
# 'unannotated fall-through between switch labels in partly-annotated function'
H8BA6FF77BB8B: '部分注释的函数中switch标签间的未注释穿透'
# "unary fold expression has empty expansion for operator '%0' with no fallback value"
HE62A3703EA3A: "一元折叠表达式为操作符'%0'的展开为空且无备用值"
# 'unary operator not supported, only increment and decrement operations permitted'
HCFDDCEAA7D4F: '不支持的一元运算符，仅允许增量和减量操作'
# 'undeclared identifier %0 in destructor name'
H9E161BF60045: '析构函数名称中未声明的标识符%0'
# 'undeclared selector %0'
H76DFE4FB888F: '未声明的选择器%0'
# 'undeclared selector %0; did you mean %1?'
HFF50CB7951F9: '未声明的选择器%0；是否是指%1？'
# "undeclared variable %0 used as an argument for '#pragma unused'"
H1A926D40EA78: "未声明的变量%0被用作'#pragma unused'的参数"
# 'undefining builtin macro'
H855B9F8C6AE6: '试图取消定义内置宏'
# 'under -fcoro-aligned-allocation, the non-aligned allocation function for the promise type %0 has higher precedence than the global aligned allocation function'
H677A6074184D: '在-fcoro-aligned-allocation下，承诺类型%0的非对齐分配函数比全局对齐分配函数具有更高的优先级'
# 'underaligned exception object thrown'
H67F3421C41BE: '抛出未对齐的异常对象'
# "unelaborated friend declaration is a C++11 extension; specify '%select{struct|interface|union|class|enum}0' to befriend %1"
H85486A35A143: "未详细声明的友元声明是C++11扩展；请指定'%select{struct|interface|union|class|enum}0'来与%1建立友元关系"
# 'unexpected %0 in function call; perhaps remove the %0?'
HF91D5DDAC941: '函数调用中出现意外的%0；是否需要移除%0？'
# "unexpected %0, expected to see one of %select{|'best_case', 'full_generality', }1'single_inheritance', 'multiple_inheritance', or 'virtual_inheritance'"
H715E4C7A8362: "意外的%0，期望看到%select{|'best_case', 'full_generality', }1'single_inheritance', 'multiple_inheritance'或'virtual_inheritance'之一"
# "unexpected '#pragma acc ...' in program"
H1E1E01704393: "程序中出现意外的'#pragma acc ...'"
# "unexpected '#pragma omp ...' in program"
H46D7021997C2: "程序中出现意外的'#pragma omp ...'"
# "unexpected '%0' clause, '%1' is specified already"
H5B200478E6AE: "意外的'%0'子句，'%1'已被指定"
# "unexpected '%0' clause, only %select{'device_type'|'enter' or 'link'|'enter', 'link' or 'device_type'|'device_type', 'indirect'|'enter', 'link', 'device_type' or 'indirect'}1 clauses expected"
H3763BE9D9C9F: "意外的'%0'子句，仅允许%select{'device_type'|'enter'或'link'|'enter', 'link'或'device_type'|'device_type', 'indirect'|'enter', 'link', 'device_type'或'indirect'}1子句"
# "unexpected '%0' clause, only %select{'device_type'|'to' or 'link'|'to', 'link' or 'device_type'|'device_type', 'indirect'|'to', 'link', 'device_type' or 'indirect'}1 clauses expected"
H1A9F6651CC12: "意外的 '%0' 子句，仅预期 %select{'device_type'|'to' 或 'link'|'device_type', 'link' 或 'device_type'|'device_type', 'indirect'|'to', 'link', 'device_type' 或 'indirect'}1 子句"
# "unexpected '(', only 'to', 'link' or 'device_type' clauses expected for 'begin declare target' directive"
H5361030EF185: "在 'begin declare target' 指令中，意外的 '(', 仅预期 'to'、'link' 或 'device_type' 子句"
# "unexpected ':' in nested name specifier; did you mean '::'?"
HC8B611B07937: "嵌套名称限定符中的意外 ':'，您是否想输入 '::'？"
# "unexpected ';' before %0"
H257D20769B88: "%0 之前的意外 ';'"
# "unexpected '@' in member specification"
HFD6F988E847A: "成员说明中的意外 '@'"
# "unexpected '@' in program"
H0E6C2D976254: "程序中的意外 '@'"
# "unexpected 'enter' clause, use 'to' instead"
H005905027939: "意外的 'enter' 子句，应使用 'to'"
# "unexpected 'execution' modifier in non-executable context"
HA6BB9CA468FA: "在非可执行上下文中意外的 'execution' 修饰符"
# "unexpected 'to' clause, use 'enter' instead"
H48CD21AE4031: "意外的 'to' 子句，应使用 'enter'"
# "unexpected OpenACC directive %select{|'#pragma acc %1'}0"
H996256861627: "意外的 OpenACC 指令 %select{|'#pragma acc %1'}0"
# "unexpected OpenMP clause '%0' in directive '#pragma omp %1'"
H1C5752C27ACF: "在指令 '#pragma omp %1' 中，OpenMP 子句 '%0' 意外"
# "unexpected OpenMP directive %select{|'#pragma omp %1'}0"
HEF8086A19118: "意外的 OpenMP 指令 %select{|'#pragma omp %1'}0"
# "unexpected argument '%0' to '#pragma %1'%select{|; expected %3}2"
HB8C385DE07A5: "对 '#pragma %1' 的意外参数 '%0'%select{|; 预期 %3}2"
# "unexpected argument '%0' to '#pragma clang attribute'; expected 'push' or 'pop'"
H3133E5143B09: "对 '#pragma clang attribute' 的意外参数 '%0'，预期 'push' 或 'pop'"
# "unexpected argument '%0' to '#pragma clang fp %1'; expected %select{'fast' or 'on' or 'off'|'on' or 'off'|'on' or 'off'|'ignore', 'maytrap' or 'strict'|'source', 'double' or 'extended'}2"
H371571C43BD4: "对 '#pragma clang fp %1' 的意外参数 '%0'，预期 %select{'fast' 或 'on' 或 'off'|'on' 或 'off'|'on' 或 'off'|'ignore', 'maytrap' 或 'strict'|'source', 'double' 或 'extended'}2"
# "unexpected argument '%0' to '#pragma clang optimize'; expected 'on' or 'off'"
H1485FAA86056: "对 '#pragma clang optimize' 的意外参数 '%0'，预期 'on' 或 'off'"
# 'unexpected argument to debug command'
H3827CC068DE1: '调试命令的意外参数'
# 'unexpected character <U+%0>'
H5B9099D7894E: '意外字符 <U+%0>'
# "unexpected clause after an implicit 'enter' clause"
H3710E8F80D5B: "隐式 'enter' 子句之后的意外子句"
# "unexpected clause after an implicit 'to' clause"
H2010F6D7C809: "隐式 'to' 子句之后的意外子句"
# "unexpected debug command '%0'"
H8054F9A13F94: "意外的调试命令 '%0'"
# 'unexpected end of default argument expression'
H2637B90369AC: '默认参数表达式意外结束'
# 'unexpected end of exception specification'
HE58D2A2E3875: '异常说明意外结束'
# 'unexpected expression: number of expressions is larger than the number of associated loops'
H7A04530C8247: '意外的表达式：表达式数量大于关联的循环数量'
# "unexpected extra argument '%0' to '#pragma clang optimize'"
HD169A0238D64: "#pragma clang optimize 指令意外多出参数 '%0'"
# 'unexpected extra tokens at end of @import declaration'
HC94D2D8555A6: '@import声明末尾存在意外的额外标记'
# 'unexpected interface name %0: expected expression'
HD34771026F11: '意外的接口名称 %0：预期为表达式'
# 'unexpected namespace name %0: expected expression'
HD2F7F8269F1D: '意外的命名空间名称 %0：预期为表达式'
# 'unexpected namespace scope prior to decltype'
H276642EE3F52: '在decltype之前存在意外的命名空间作用域'
# "unexpected operation specified in 'append_args' clause, expected 'interop'"
H7343FC2DA837: "在'append_args'子句中指定了意外的操作，预期应为'interop'"
# "unexpected output symbol graph '%1'; please provide '--symbol-graph-dir=<directory>' instead"
H16E9C665ACBA: "意外的输出符号图 '%1'；请改为提供 '--symbol-graph-dir=<directory>'"
# "unexpected parameter '%0' in availability attribute, not permitted in %select{HLSL|C/C++}1"
H3A2F294B2383: "在可用性属性中遇到意外参数 '%0'，%select{HLSL|C/C++}1 中不允许"
# 'unexpected token after Objective-C string'
H279452517A7B: 'Objective-C字符串之后存在意外的标记'
# 'unexpected token in pragma diagnostic'
HF7F8BD94B55D: '在#pragma diagnostic指令中检测到意外的标记'
# 'unexpected type name %0: expected expression'
H5096D6005D2D: '意外的类型名称 %0：预期为表达式'
# 'unexpected type name %0: expected identifier'
HECE4BA85049C: '意外的类型名称 %0：预期为标识符'
# "unexpected value; use 'true' or 'false'"
HBC54A5A54D19: "意外的值；请使用'true'或'false'"
# 'unguarded header; consider using #ifdef guards or #pragma once'
H1B291D4D56CA: '未受保护的头文件；建议使用#ifdef保护或#pragma once'
# 'unicode literals are incompatible with C standards before C23'
H7CE9D5273D56: 'Unicode字面量与C23之前的C标准不兼容'
# 'unicode literals are incompatible with C++ standards before C++17'
H41D963C4F029: 'Unicode字面量与C++17之前的C++标准不兼容'
# 'unicode literals are incompatible with C++98'
H63FE9D503E73: 'Unicode字面量与C++98不兼容'
# 'unicode literals are incompatible with C99'
H413288F05A72: 'Unicode字面量与C99不兼容'
# 'unimplemented constexpr lambda feature: %0 (coming soon!)'
H49A46ED86D09: '未实现的constexpr lambda特性: %0 (即将推出!)'
# 'unimplemented pure virtual method %0 in %1'
H6BCBAEFB56A1: '%1中的纯虚方法%0未实现'
# 'uninitialized reference member is here'
HD2F77230D93D: '未初始化的引用成员在此处'
# 'uninitialized variable in a constexpr %select{function|constructor}0 is a C++20 extension'
HD0E4F93C0D47: 'constexpr %select{函数|构造函数}0中的未初始化变量是C++20扩展'
# 'uninitialized variable in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
HB023F58DC7FA: 'constexpr %select{函数|构造函数}0中的未初始化变量与C++20前的标准不兼容'
# 'union member %0 has reference type %1'
H0725C5FA90A3: '联合体成员%0具有引用类型%1'
# 'union member %0 has reference type %1, which is a Microsoft extension'
H717E84EDF789: '联合体成员%0具有引用类型%1，这是Microsoft扩展'
# 'unions cannot be base classes'
H3537D21C3F62: '联合体不能作为基类'
# 'unions cannot have base classes'
HC69C8BA7958A: '联合体不能有基类'
# 'unions cannot have virtual functions'
HE6462B703CAB: '联合体不能有虚函数'
# 'universal character name referring to a control character is incompatible with C standards before C23'
H443795B4C160: '引用控制字符的通用字符名与C23之前的C标准不兼容'
# 'universal character name referring to a control character is incompatible with C++98'
H441444D5A2FF: '引用控制字符的通用字符名与C++98不兼容'
# 'universal character name refers to a control character'
H0A302EE7A7D5: '通用字符名引用了控制字符'
# 'universal character name refers to a surrogate character'
H38343641D115: '通用字符名引用了代理字符'
# 'universal character names are only valid in C99 or C++'
H6C064E2FEAA1: '通用字符名仅在C99或C++中有效'
# "universal character names are only valid in C99 or C++; treating as '\\' followed by identifier"
H57AF83D90AE3: "通用字符名仅在C99或C++中有效；将其视为反斜杠'\\'后接标识符"
# "unknown %0 warning specifier: '%1'"
HE021FCA9FD45: "未知的%0警告说明符: '%1'"
# 'unknown %select{type|class}1 name %0; did you mean %2?'
H3C8376ED6B78: '未知的%select{类型|类}1名称%0；您是否指%2？'
# "unknown %select{warning|remark}0 option '%1'%select{|; did you mean '%3'?}2"
HE86784D7A808: "未知的 %select{警告|备注}0 选项 '%1'%select{|; 你是否是指 '%3'?}2"
# "unknown '-mindirect-jump=' option '%0'"
H632D52B85B4D: "未知的 '-mindirect-jump=' 选项 '%0'"
# "unknown FP unit '%0'"
HC0D93947CA5F: "未知的浮点单元 '%0'"
# 'unknown HLSL semantic %0'
H173D19A6AD63: '未知的 HLSL 语义 %0'
# "unknown action '%1' for '#pragma %0' - ignored"
HD5134EB4614C: "未知的 '#pragma %0' 动作 '%1' - 已忽略"
# "unknown action for '#pragma %0' - ignored"
HC6ADA3F7938E: "未知的 '#pragma %0' 动作 - 已忽略"
# "unknown analyzer-config '%0'"
H50FE6AD53FF0: "未知的 analyzer-config '%0'"
# "unknown argument '%0'; did you mean '%1'?"
HBDB4C2710C85: "未知的参数 '%0'; 你是否是指 '%1'?"
# "unknown argument ignored in clang-cl '%0'; did you mean '%1'?"
HFC74C4C6226A: "未知的 clang-cl 参数 '%0' 被忽略; 你是否是指 '%1'?"
# "unknown argument ignored in clang-cl: '%0'"
HC759BFBE35F6: "未知的 clang-cl 参数被忽略: '%0'"
# "unknown argument: '%0'"
HA16D3B1BF1E9: "未知的参数: '%0'"
# "unknown assumption string '%0' may be misspelled; attribute is potentially ignored, did you mean '%1'?"
H50CF8A7A4EC4: "未知的假设字符串 '%0' 可能拼写错误; 属性可能被忽略，你是否是指 '%1'?"
# "unknown assumption string '%0'; attribute is potentially ignored"
H585A62063A9D: "未知的假设字符串 '%0'; 属性可能被忽略"
# 'unknown attribute %0 ignored'
H2C00F439265B: '未知的属性 %0 被忽略'
# "unknown attribute '%0'"
HB9EC0CD4D3F9: "未知的属性 '%0'"
# "unknown attribute subject rule '%0'"
H3D3386816A55: "未知的属性主题规则 '%0'"
# 'unknown cast annotation __bridge_retain; did you mean __bridge_retained?'
H99CA4EEB19EE: '未知的类型转换注释 __bridge_retain; 你是否是指 __bridge_retained?'
# 'unknown command tag name'
H11BCD33A99AD: '未知的命令标签名称'
# "unknown command tag name '%0'; did you mean '%1'?"
H7FD2FDFA8A87: "未知的命令标签名称 '%0'; 你是否是指 '%1'?"
# 'unknown diagnostic option'
HB8C73037AA51: '未知的诊断选项'
# 'unknown environment %0 in availability macro'
HAEC8AEED3CAD: '在可用性宏中未知的环境 %0'
# "unknown escape sequence '\\%0'"
H4849F8435E28: "未知的转义序列 '\\%0'"
# 'unknown kind of pragma comment'
HA06D4573713E: '#pragma comment 的未知类型'
# 'unknown linkage language'
H6501D0DE4EA8: '未知的链接语言'
# "unknown module '%0'"
H99985C296846: "未知的模块 '%0'"
# "unknown or ill-formed Objective-C runtime '%0'"
HDD07911A4A21: "未知或格式错误的Objective-C运行时 '%0'"
# 'unknown platform %0 in availability macro'
HD5C8076C5089: '在可用性宏中未知的平台 %0'
# 'unknown platform, assuming -mfloat-abi=%0'
HE055695902FF: '未知的平台，假设为 -mfloat-abi=%0'
# 'unknown pragma ignored'
H2A263E84EA76: '忽略未知的 #pragma'
# 'unknown pragma in STDC namespace'
HB8BAEB9D2633: 'STDC命名空间中的未知 #pragma'
# 'unknown property attribute %0'
HA552B52A5631: '未知的属性 %0'
# 'unknown receiver %0; did you mean %1?'
HF53B2435A683: '未知的接收者 %0；您是否是指 %1？'
# "unknown register name '%0' in asm"
H0A30B49D2F93: "内联汇编中的未知寄存器名称 '%0'"
# "unknown remark serializer format: '%0'"
H4745BF37BA54: "未知的备注序列化格式: '%0'"
# "unknown sanitizer '%0' ignored"
H7A7513A62BEF: "未知的sanitizer '%0' 被忽略"
# "unknown state '%0'"
HBCA6965044DA: "未知的状态 '%0'"
# 'unknown symbolic operand name in inline assembly string'
HA556FD6AA91E: '内联汇编字符串中的未知符号操作数名称'
# "unknown target ABI '%0'"
HCA5838C6F428: "未知的目标ABI '%0'"
# "unknown target CPU '%0'"
H70DCB9C1156C: "未知的目标CPU '%0'"
# "unknown target triple '%0'"
HF45924A5A477: "未知的目标三元组 '%0'"
# 'unknown template name %0'
HF6FA1BD9E3B7: '未知模板名称 %0'
# 'unknown type name %0'
HE3210F6A77D6: '未知类型名称 %0'
# 'unknown type name %0; did you mean %1?'
H2AA39E457B1F: '未知类型名称 %0；是否是指 %1？'
# 'unknown visibility %0'
HD580631FB230: '未知可见性 %0'
# "unknown warning group '%0'"
H8B8A3DBA2D6F: "未知的警告组 '%0'"
# "unknown warning group '%0', ignored"
H9E42BAF52A2D: "未知的警告组 '%0'，已忽略"
# "unknown%select{ | embed}0 preprocessor parameter '%1'"
HD697EE356FF3: "未知%select{ | embed}0 预处理器参数 '%1'"
# 'unnamed enumeration must be a definition'
H4B9605BBAC49: '未命名的枚举必须是一个定义'
# 'unnamed type as template argument is incompatible with C++98'
HCF539CBCF367: '未命名类型作为模板参数与C++98不兼容'
# 'unnamed type used in template argument was declared here'
H766AB8914B51: '模板参数中使用的未命名类型是在此处声明的'
# 'unnamed variable cannot be implicitly captured in a lambda expression'
HC2AE531DDA32: '未命名的变量不能在lambda表达式中被隐式捕获'
# 'unparsed tokens following type'
H64EC0A0DBA9B: '类型之后存在未解析的标记'
# 'unqualified base initializer of class templates is a Microsoft extension'
H18E0D4547A36: '类模板的未限定基类初始化器是Microsoft扩展'
# "unqualified call to '%0'"
HA083B268F3B3: '对 "%0" 的未限定调用'
# 'unqualified friend declaration referring to type outside of the nearest enclosing namespace is a Microsoft extension; add a nested name specifier'
H99771505062C: '指向最近包含命名空间之外类型的未限定友元声明是Microsoft扩展；请添加嵌套名称限定符'
# 'unreachable declaration of template entity is here'
H8957FB46EC11: '模板实体的不可达声明在此处'
# "unrecognized parameter passing direction, valid directions are '[in]', '[out]' and '[in,out]'"
H451D99C06285: '未识别的参数传递方向，有效方向是 "[in]"、"[out]" 和 "[in,out]"'
# 'unrecognized platform name %0'
H3352495501E4: '未识别的平台名称 %0'
# 'unsequenced modification and access to %0'
HF69B798309CF: '对 %0 的未序列化修改和访问'
# 'unsupported %0 gpu architecture: %1'
HFE203A3E528C: '不受支持的 %0 GPU 架构： %1'
# "unsupported '%0' value '%1'; use 'ios-macabi' instead"
H4B7365627CB3: "不支持的 '%0' 值 '%1'；请改用 'ios-macabi'"
# 'unsupported CUDA gpu architecture: %0'
HBDA907ABC960: '不支持的CUDA GPU架构: %0'
# 'unsupported MC/DC boolean expression; contains an operation with a nested boolean expression. Expression will not be covered'
H0E188D9916C4: '不支持的MC/DC布尔表达式；包含带有嵌套布尔表达式操作。该表达式将不会被覆盖'
# 'unsupported MC/DC boolean expression; number of conditions (%0) exceeds max (%1). Expression will not be covered'
H97B49477D381: '不支持的MC/DC布尔表达式；条件数量（%0）超过最大值（%1）。该表达式将不会被覆盖'
# 'unsupported MC/DC boolean expression; number of test vectors (%0) exceeds max (%1). Expression will not be covered'
HA1952652ED2D: '不支持的MC/DC布尔表达式；测试向量数量（%0）超过最大值（%1）。该表达式将不会被覆盖'
# 'unsupported OpenCL extension %0 - ignoring'
H90715CF4E48F: '不支持的OpenCL扩展%0 - 忽略'
# "unsupported architecture '%0' for MS-style inline assembly"
H4CDA8CDAE447: "不支持的架构 '%0' 用于MS风格的内联汇编"
# "unsupported architecture '%0' for host compilation"
HF6B9D10A3CB2: "不支持的架构 '%0' 用于主机编译"
# "unsupported argument '%1' to option '%0'"
HF8679865943E: "选项 '%0' 的不支持参数 '%1'"
# "unsupported argument '%1' to option '%0' for target '%2'"
H4C786BC0FD2F: "目标 '%2' 的选项 '%0' 不支持参数 '%1'"
# "unsupported branch protection specification '%0'"
H2A7469D4D5C2: "不支持的分支保护规范 '%0'"
# 'unsupported combination: -header-include-format=%0 and -header-include-filtering=%1'
HDE5448E6CD09: '不支持的组合：-header-include-format=%0 和 -header-include-filtering=%1'
# 'unsupported combination: CC_PRINT_HEADERS_FORMAT=%0 and CC_PRINT_HEADERS_FILTERING=%1'
H2798CD78D9FC: '不支持的组合：CC_PRINT_HEADERS_FORMAT=%0 和 CC_PRINT_HEADERS_FILTERING=%1'
# 'unsupported expression with unknown type'
H3F334416D50C: '包含未知类型的表达式'
# 'unsupported inline asm: input with type %diff{$ matching output with type $|}0,1'
HA68AF7F61C41: '不支持的内联汇编：类型%diff{$与输出类型匹配的$|}0,1输入'
# 'unsupported non-standard concatenation of string literals'
H5B7E63184569: '不支持的非标准字符串字面量连接'
# "unsupported option '%0'"
H76DA0BF83FA2: "不支持的选项 '%0'"
# "unsupported option '%0' for language mode '%1'"
HFB2A15C316AA: "语言模式 '%1' 的不支持选项 '%0'"
# "unsupported option '%0' for target '%1'"
H3BBDE17AAC2A: "目标 '%1' 的不支持选项 '%0'"
# "unsupported option '%0'; did you mean '%1'?"
H4AD874895A11: "不支持的选项 '%0'；是否是指 '%1'？"
# "unsupported runtime library '%0' for platform '%1'"
HE43F5A0809F2: "平台 '%1' 不支持的运行时库 '%0'"
# 'unsupported signature for %q0'
H15BCEB35CA2A: '%q0 的签名不支持'
# "unsupported standard library implementation: 'std::%0' is not a class template"
HA2971F6C2CFB: "不支持的标准库实现：'std::%0' 不是一个类模板"
# 'unsupported type for named register variable'
H1A238AEF63D8: '命名寄存器变量的类型不支持'
# "unsupported unwind library '%0' for platform '%1'"
H36E9F0E6CE47: "平台 '%1' 不支持的展开库 '%0'"
# 'unsupported vector cast from %0 to %1 in a constant expression'
H0EB0D2450B52: '常量表达式中不支持将 %0 转换为 %1 的向量转换'
# 'unsupported: anonymous type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition'
H912212F218D9: '不支持：在计算链接属性后，%select{typedef|alias}0 声明为链接目的给匿名类型命名；请在此处添加标签名以在定义前建立链接'
# "unterminated '#pragma clang attribute push' at end of file"
HAA76B77750A8: "文件末尾未终止的 '#pragma clang attribute push'"
# "unterminated '#pragma pack (push, ...)' at end of file"
H95BE59428151: "文件末尾未终止的 '#pragma pack (push, ...)'"
# 'unterminated /* comment'
H43A167D7F07E: '未终止的 /* 注释'
# 'unterminated conditional directive'
H9448FAFF2F9A: '未终止的条件指令'
# 'unterminated function-like macro invocation'
HD9DD62FCE328: '未终止的宏函数调用'
# 'unterminated symbolic operand name in inline assembly string'
HBE23072A59B4: '内联汇编字符串中未终止的符号操作数名称'
# 'unused %select{function|variable}0 template %1'
H1A13AD1AD99E: '未使用的 %select{function|variable}0 模板 %1'
# 'unused %select{typedef|type alias}0 %1'
HF81285298D17: '未使用的 %select{typedef|type alias}0 %1'
# "unused attribute %0 in '#pragma clang attribute push' region"
HE033EC53FB54: "在 '#pragma clang attribute push' 区域中未使用的属性 %0"
# 'unused exception parameter %0'
H53C55F431BFF: '未使用的异常参数 %0'
# 'unused function %0'
H452452A2578C: '未使用的函数 %0'
# 'unused label %0'
H876AC9FC8066: '未使用的标签 %0'
# 'unused member function %0'
HCD85BCD73655: '未使用的成员函数 %0'
# 'unused parameter %0'
HA3441FCB7F5E: '未使用的参数 %0'
# 'unused variable %0'
HC6697F7C70D3: '未使用的变量 %0'
# 'unwind clobber cannot be used with asm goto'
HF66EC6AC58F5: '无法与asm goto一起使用unwind clobber'
# 'use %select{__bridge_retained|CFBridgingRetain call}1 to make an ARC object available as a +1 %0'
H2F547772958A: '使用 %select{__bridge_retained|CFBridgingRetain 调用}1 将ARC对象作为+1 %0可用'
# 'use %select{__bridge_transfer|CFBridgingRelease call}1 to transfer ownership of a +1 %0 into ARC'
HF8A351DB4284: '使用 %select{__bridge_transfer|CFBridgingRelease 调用}1 将+1 %0的所有权转移到ARC'
# 'use %select{an alias declaration|a typedef declaration|a reference|a const variable|a constexpr variable}0 instead'
H31FA52067035: '改用 %select{别名声明|typedef声明|引用|const变量|constexpr变量}0'
# "use '!=' to turn this compound assignment into an inequality comparison"
HFF11B4D027A3: "使用 '!=' 将此复合赋值转换为不等比较"
# "use '%0' for a bitwise operation"
HC5B930A30B61: "使用 '%0' 进行按位运算"
# "use '%0' instead"
H3E25F181DE0F: "改为使用 '%0'"
# "use '%0'%select{| or '%3'|, '%3', or '%4'|, '%3', '%4', or '%5'}2 for '%1' standard"
H8EF0F3BAA8D4: "为 '%1' 标准使用 '%0'%select{| 或 '%3'|，'%3'，或 '%4'|，'%3'，'%4'，或 '%5'}2"
# "use '--' to treat subsequent arguments as filenames"
H6A626367FC6F: "使用 '--' 将后续参数视为文件名"
# "use '=' to turn this equality comparison into an assignment"
H59DEE49ECF0A: "使用 '=' 将此相等比较转换为赋值"
# "use '==' to turn this assignment into an equality comparison"
H00083B312DD9: "使用 '==' 将此赋值转换为相等比较"
# "use 'framework module' to declare module '%0'"
H4A41FDAB21BC: "使用 'framework module' 声明模块 '%0'"
# "use 'isEqual:' instead"
H4DB59E9DD438: "改为使用 'isEqual:'"
# "use 'static' to give inline function %0 internal linkage"
HFF537B0E0104: "使用 'static' 为内联函数 %0 提供内部链接"
# "use 'static_cast' to adjust the pointer correctly while %select{upcasting|downcasting}0"
H11DA11C5BD86: "在%select{向上转换|向下转换}0时，使用 'static_cast' 正确调整指针"
# "use 'template' keyword to treat '%0' as a dependent template name"
H7991087B2538: "使用 'template' 关键字将 '%0' 视为相关模板名称"
# "use 'thread_local' to allow this"
H797BF646E244: "使用 'thread_local' 允许这"
# "use '|=' to turn this inequality comparison into an or-assignment"
H080693EB5666: "使用 '|=' 将此不等比较转换为或赋值"
# 'use -analyzer-disable-all-checks to disable all static analyzer checkers'
H352E7076CB09: '使用 -analyzer-disable-all-checks 禁用所有静态分析器检查器'
# 'use -fbracket-depth=N to increase maximum nesting level'
H336E5F530373: '使用 -fbracket-depth=N 增加最大嵌套级别'
# "use -foperator-arrow-depth=N to increase 'operator->' limit"
HF5AE9E6C2AED: "使用 -foperator-arrow-depth=N 增加 'operator->' 限制"
# 'use -ftemplate-depth=N to increase recursive template instantiation depth'
HB6D1F29D249C: '使用 -ftemplate-depth=N 增加递归模板实例化深度'
# 'use /Tc or /Tp to set input type for standard input'
HA357D9386AFC: '使用 /Tc 或 /Tp 为标准输入设置输入类型'
# 'use __attribute__((visibility("hidden"))) attribute instead'
H69E62EF34DBF: '改用 __attribute__((visibility("hidden"))) 属性'
# 'use __bridge to convert directly (no change in ownership)'
HF999F719DC1E: '使用 __bridge 进行直接转换（不改变所有权）'
# 'use __bridge with C-style cast to convert directly (no change in ownership)'
H25381B224554: '使用 __bridge 结合 C 风格强制转换进行直接转换（不改变所有权）'
# 'use __bridge_retained with C-style cast to make an ARC object available as a +1 %0'
H89038B186CBF: '使用 __bridge_retained 结合 C 风格强制转换，使+1 %0在ARC中可用'
# 'use __bridge_transfer with C-style cast to transfer ownership of a +1 %0 into ARC'
H0BF38DCCAF48: '使用 __bridge_transfer 结合 C 风格强制转换，将+1 %0的所有权转移给ARC'
# 'use array indexing to silence this warning'
H85B32746AF01: '使用数组索引消除此警告'
# 'use constraint modifier "%0"'
H96B4F36A2D84: '使用约束修饰符“%0”'
# 'use declarations are only allowed in top-level modules'
HB528050B8967: '使用声明仅允许在顶层模块中'
# "use function '%0' instead"
H30EA9A5A15F6: '改用函数‘%0’'
# 'use non-reference type %0'
HE4A5CE8520B2: '使用非引用类型%0'
# 'use non-reference type %0 to make construction explicit or type %1 to prevent copying'
HAB8A2938766C: '使用非引用类型%0显式构造，或使用类型%1防止复制'
# 'use nullability type specifier %0 to affect the innermost pointer type of %1'
HA9A4302606C7: '使用空值类型说明符%0影响%1的最内层指针类型'
# 'use of %0 with tag type that does not match previous declaration'
H4AAB2FCDDAB1: '使用与之前声明不匹配的标签类型%0'
# 'use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments'
H8F99144D2E34: '使用%select{类模板|函数模板|变量模板|别名模板|模板模板参数|概念|模板}0 %1需要模板实参'
# 'use of %select{infinity|NaN}0%select{| via a macro}1 is undefined behavior due to the currently enabled floating-point options'
H18AE2A8F681F: '使用%select{无穷大|NaN}0%select{|通过宏}1由于当前启用的浮点选项导致未定义行为'
# 'use of %select{type|declaration}0 %1 requires %2 support'
H39DB55887936: '使用 %select{类型|声明}0 %1 需要 %2 支持'
# "use of '@import' in framework header is discouraged, including this header requires -fmodules"
H455C5312D820: "在框架头文件中使用 '@import' 不被推荐，包含此头文件需要启用 -fmodules"
# "use of '@import' when modules are disabled"
HE80AA99C30B1: "禁用模块时使用 '@import'"
# "use of '__int128' with '__vector bool' requires VSX support enabled (on POWER10 or later)"
HBB36DE187BFD: "使用 '__int128' 与 '__vector bool' 需要启用 VSX 支持（适用于 POWER10 或更高版本）"
# "use of '__int128' with '__vector' requires extended Altivec support (available on POWER8 or later)"
H02493A6B8143: "使用 '__int128' 与 '__vector' 需要扩展的 Altivec 支持（适用于 POWER8 或更高版本）"
# "use of '__super' inside a lambda is unsupported"
H5812045C24A5: "在 lambda 内使用 '__super' 是不受支持的"
# "use of 'double' with '__vector' requires VSX support to be enabled (available on POWER7 or later)"
HFF794EBE240D: "使用 'double' 与 '__vector' 需要启用 VSX 支持（适用于 POWER7 或更高版本）"
# "use of 'long long' with '__vector' requires VSX support (available on POWER7 or later) to be enabled"
HEDE074D6F05D: "使用 'long long' 与 '__vector' 需要启用 VSX 支持（适用于 POWER7 或更高版本）"
# "use of 'long' with '__vector' is deprecated"
H194F4A31DAD4: "使用 'long' 与 '__vector' 是已弃用的"
# "use of 'operator->' on type %0 would invoke a sequence of more than %1 'operator->' calls"
HE55B12BF8DE6: "使用类型 %0 的 'operator->' 会触发超过 %1 次 'operator->' 调用序列"
# "use of 'static_assert' without inclusion of <assert.h> is a Microsoft extension"
HFC681B3993FC: "未包含 <assert.h> 时使用 'static_assert' 是 Microsoft 扩展"
# "use of 'template' keyword outside of a template is incompatible with C++98"
HADE615C257C6: "在模板外使用 'template' 关键字与 C++98 不兼容"
# "use of 'typename' outside of a template is incompatible with C++98"
HBD30DC1F2094: "在模板外使用 'typename' 关键字与 C++98 不兼容"
# 'use of @defs is not supported on this architecture and platform'
HA2315B23A421: '在此架构和平台上不支持使用 @defs'
# 'use of C-style parameters in Objective-C method declarations is deprecated'
H124575A24936: '在 Objective-C 方法声明中使用 C 风格参数已弃用'
# "use of GNU 'missing =' extension in designator"
HE3037B23921A: '使用 GNU 缺失 "=" 扩展在设计符中'
# 'use of GNU ?: conditional expression extension, omitting middle operand'
H0DE762B90B0D: '使用 GNU ?: 条件表达式扩展，省略中间操作数'
# 'use of GNU address-of-label extension'
HA7B26095AD53: '使用 GNU 地址-of-label 扩展'
# 'use of GNU array range extension'
H678FC3DF1C6F: '使用 GNU 数组范围扩展'
# 'use of GNU indirect-goto extension'
H3D429B23EFAC: '使用 GNU 间接跳转扩展'
# 'use of GNU old-style field designator extension'
H85575BE49C11: '使用 GNU 旧式字段指定符扩展'
# 'use of GNU statement expression extension'
HD7924EDC2399: '使用 GNU 语句表达式扩展'
# 'use of GNU statement expression extension from macro expansion'
HDFF296407839: '通过宏展开使用 GNU 语句表达式扩展'
# 'use of NULL in arithmetic operation'
H72A441293B63: '在算术运算中使用 NULL'
# 'use of Objective-C property in function nested in Objective-C container not supported, move function outside its container'
H1B2603FEAF82: '在 Objective-C 容器嵌套的函数中使用 Objective-C 属性不被支持，需将函数移至容器外部'
# 'use of __private_extern__ on a declaration may not produce external symbol private to the linkage unit and is deprecated'
HC7A56E0EB4D2: '在声明中使用 __private_extern__ 可能无法生成链接单元私有外部符号，并已弃用'
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is a C++23 extension"
H6A5DD5BE1302: '使用 "#%select{<BUG IF SEEN>|elifdef|elifndef}0" 指令是 C++23 扩展'
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is a C23 extension"
H0BF82439932C: '使用 "#%select{<BUG IF SEEN>|elifdef|elifndef}0" 指令是 C23 扩展'
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is incompatible with C standards before C23"
HDFCC088F181F: '使用 "#%select{<BUG IF SEEN>|elifdef|elifndef}0" 指令与 C23 之前的标准不兼容'
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is incompatible with C++ standards before C++23"
H16A663A66375: '使用 "#%select{<BUG IF SEEN>|elifdef|elifndef}0" 指令与 C++23 之前的标准不兼容'
# 'use of address-of-label extension outside of a function body'
HEBDAFDF05EDA: '在函数体外使用地址-标签扩展'
# 'use of an empty initializer is a C23 extension'
HD0F8B4BA3FB2: '使用空初始化器是 C23 扩展'
# 'use of an empty initializer is incompatible with C standards before C23'
H28862631C8FD: '使用空初始化器与 C23 之前的标准不兼容'
# "use of bitwise '%0' with boolean operands"
H3DCD98477290: '对布尔操作数使用按位 "%0" 运算符'
# 'use of default argument to function %0 that is declared later in class %1'
HBEFC6E561806: '使用在类 %1 后续声明的函数 %0 的默认参数'
# 'use of dynamic_cast requires -frtti'
HE86B35BE234A: '使用 dynamic_cast 需要 -frtti 选项'
# 'use of empty enum'
H0A3EEAE0C204: '使用空枚举'
# 'use of enumeration in a nested name specifier is a C++11 extension'
H9F1C227C8017: '在嵌套名称说明符中使用枚举是 C++11 扩展'
# 'use of function %0 is discouraged; there is no way to check for failure but failure may still occur, resulting in a possibly exploitable security vulnerability'
H123B46BAB412: '使用函数 %0 不被推荐；该函数可能出现无法检测的失败，从而导致可被利用的安全漏洞'
# 'use of function template name with no prior declaration in function call with explicit template arguments is a C++20 extension'
H17E19DFB3C7C: '在显式模板参数的函数调用中使用未声明的函数模板名称是 C++20 扩展'
# 'use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20'
H1C25D5B6691F: '在显式模板实参的函数调用中使用未预先声明的函数模板名称不符合 C++20 之前的 C++ 标准'
# "use of implicit 'typename' is incompatible with C++ standards before C++20"
HFA6B14FF689A: "使用隐式 'typename' 不符合 C++20 之前的 C++ 标准"
# "use of incomplete type %0 in a '_Generic' association is incompatible with C standards before C2y"
H805F57844181: "在 '_Generic' 关联中使用不完整类型 %0 不符合 C2y 之前的 C 标准"
# "use of logical '%0' with constant operand"
H91174008E58D: '在常量操作数中使用逻辑运算符 "%0"'
# 'use of member %0 before its declaration is a Microsoft extension'
HF1849841B9E7: '在声明前使用成员 %0 是 Microsoft 扩展'
# 'use of member %0 found via unqualified lookup into dependent bases of class templates is a Microsoft extension'
H8CD447C8CC3A: '通过非限定查找访问类模板的依赖基类中的成员 %0 是 Microsoft 扩展'
# 'use of multiple declarators in a single using declaration is a C++17 extension'
H82698382734A: '在单个 using 声明中使用多个声明符是 C++17 扩展'
# 'use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17'
HF5A1B33A1986: '在单个 using 声明中使用多个声明符不符合 C++17 之前的 C++ 标准'
# "use of non-standard escape character '\\%0'"
H8F21313E1DFF: "使用非标准转义字符 '\\%0'"
# 'use of non-static data member %0 in an unevaluated context is incompatible with C++98'
H47868E15CED8: '在未求值上下文中使用非静态数据成员 %0 不符合 C++98 标准'
# 'use of null pointer as non-type template argument is incompatible with C++98'
H6944D3B803C2: '将空指针用作非类型模板实参不符合 C++98 标准'
# 'use of old-style cast'
H0C8605CE0E58: '使用旧式类型转换'
# 'use of out-of-scope declaration of %0%select{| whose type is not compatible with that of an implicit declaration}1'
H9DFA1FDF94B0: '使用超出作用域的声明 %0%select{| 其类型与隐式声明的类型不兼容}1'
# "use of overloaded operator '%0' is ambiguous (operand type %1)"
H4300BB2DDBA6: "重载运算符 '%0' 的使用存在歧义（操作数类型 %1）"
# "use of overloaded operator '%0' is ambiguous (with operand types %1 and %2)"
H792DBC228D1F: "重载运算符 '%0' 的使用存在歧义（操作数类型 %1 和 %2）"
# 'use of placement new requires explicit declaration'
H992499F64501: '使用 placement new 需要显式声明'
# "use of private header from outside its module: '%0'"
H4B3CFE33871D: "从其模块外部使用私有头文件: '%0'"
# 'use of reference outside its lifetime is not allowed in a constant expression'
H2C7D8C6358B3: '在常量表达式中使用超出生命周期的引用是不允许的'
# 'use of result of assignment to object of volatile-qualified type %0 is deprecated'
H0FD6FA3111E8: '使用 volatile 限定类型 %0 的赋值结果属于已弃用用法'
# "use of right-shift operator ('>>') in template argument will require parentheses in C++11"
H4B1C2F8BF668: "在 C++11 中模板实参中使用右移运算符 ('>>') 需要显式添加括号"
# 'use of the %0 attribute is a C++14 extension'
HD7333826DEB8: '使用%0属性是C++14的扩展'
# 'use of the %0 attribute is a C++17 extension'
H9D6E9F75124A: '使用%0属性是C++17的扩展'
# 'use of the %0 attribute is a C++20 extension'
H85EE1317CADA: '使用%0属性是C++20的扩展'
# 'use of the %0 attribute is a C++23 extension'
H3769FB94DD63: '使用%0属性是C++23的扩展'
# 'use of this expression in an %0 attribute requires parentheses'
H4B6BF2EAA0DF: '在%0属性中使用此表达式需要括号'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++14 extension'
H009816A3B264: '在constexpr %select{function|constructor}0中使用此语句是C++14的扩展'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++20 extension'
H383EABB05A34: '在constexpr %select{function|constructor}0中使用此语句是C++20的扩展'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++23 extension'
H3CD433F9DEED: '在constexpr %select{function|constructor}0中使用此语句是C++23的扩展'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
HDB9F101C6FD8: '在constexpr %select{function|constructor}0中使用此语句与C++14之前的C++标准不兼容'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
H10E657C568DA: '在constexpr %select{function|constructor}0中使用此语句与C++20之前的C++标准不兼容'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
HBB6862211968: '在constexpr %select{function|constructor}0中使用此语句与C++23之前的C++标准不兼容'
# 'use of typeid requires -frtti'
H6516CAF74372: '使用typeid需要-frtti选项'
# 'use of unary operator that may be intended as compound assignment (%0=)'
H52686183E946: '使用可能意图作为复合赋值运算符（%0=）的一元运算符'
# 'use of undeclared %0'
H4249B6D3D66A: '使用未声明的%0'
# 'use of undeclared %0; did you mean %1?'
H152AECD0CF73: '使用未声明的%0；是否是指%1？'
# 'use of undeclared identifier %0'
H2DA2A4EF5956: '使用未声明的标识符%0'
# 'use of undeclared identifier %0; did you mean %1?'
H448AE4CE2F58: '使用未声明的标识符%0；是否是指%1？'
# 'use of undeclared identifier %0; unqualified lookup into dependent bases of class template %1 is a Microsoft extension'
HB6A34859F540: '使用未声明的标识符%0；类模板%1的依赖基类中未限定查找是Microsoft扩展'
# 'use of undeclared label %0'
H685C1928674B: '使用未声明的标签%0'
# "use of undefined marker '%0'"
HAEC3C6045C74: "使用未定义的标记'%0'"
# 'use of unknown builtin %0'
HBFCE16721923: '使用未知的内置函数%0'
# 'use reference type %0 to prevent copying'
H96F12D2BC3F2: '使用引用类型%0以防止拷贝'
# "use same version number separators '_' or '.'; as in 'major[.minor[.subminor]]'"
H152CFF6748B3: "请使用相同的版本号分隔符'_'或'.'，例如'major[.minor[.subminor]]'"
# "use the GNU '__attribute__' syntax"
H7DBF5BB23C34: "使用GNU的'__attribute__'语法"
# 'used here'
H1359FF249380: '在此处使用'
# 'used in initialization here'
H9614905D4DE2: '在此初始化中使用'
# 'used type %0 where __hlsl_resource_t is required'
HB0299AD4C891: '此处使用类型%0，但需要__hlsl_resource_t类型'
# 'used type %0 where arithmetic or pointer type is required'
HEF054774D419: '此处使用类型%0，但需要算术类型或指针类型'
# 'used type %0 where floating point type is not allowed'
HF095E0FB08EE: '此处使用类型%0，但不允许使用浮点类型'
# 'used type %0 where integer is required'
HCD053F3A5F86: '此处使用类型%0，但需要整数类型'
# 'used type %0 where integer or floating point type is required'
H46DF1623ED73: '此处使用类型%0，但需要整数或浮点类型'
# 'used%select{| in pointer arithmetic| in buffer access}0 here'
H2D0FA9F859F9: '此处%select{使用|在指针运算中使用|在缓冲区访问中使用}0'
# "user-defined literal suffixes %select{<ERROR>|not starting with '_'|containing '__'}0 are reserved%select{; no literal will invoke this operator|}1"
H414028466FC2: '用户定义的字面量后缀%select{<ERROR>|不以"_"开头|包含"__"}0是保留的%select{；没有字面量会调用此运算符|}1'
# 'using'
H92BD75EBD8FD: '使用'
# 'using %0 directive in %select{NSString|CFString}1 which is being passed as a formatting argument to the formatting %select{method|CFfunction}2'
HFA21A8452E12: '在%select{NSString|CFString}1中使用%0指令，该指令作为格式参数传递给格式%select{方法|CF函数}2'
# 'using %0 with a literal is redundant'
HA26F40AA0176: '与字面量一起使用%0是多余的'
# 'using %select{integer|floating point|complex}1 absolute value function %0 when argument is of %select{integer|floating point|complex}2 type'
H2A1C61EF88A1: '当参数为%select{整数|浮点|复数}2类型时，使用%select{整数|浮点|复数}1类型的绝对值函数%0'
# "using '%%P' format specifier with an Objective-C pointer results in dumping runtime object structure, not object value"
H513C1ECC12E7: '在Objective-C指针中使用"%%P"格式说明符会导致转储运行时对象结构，而不是对象值'
# "using '%%P' format specifier without precision"
HE89A56274479: '未指定精度时使用"%%P"格式说明符'
# "using '%0' format specifier annotation outside of os_log()/os_trace()"
H2CE6DDE79E74: '在os_log()/os_trace()之外使用"%0"格式说明符注释'
# "using '%0' format specifier, but argument has boolean value"
HDDBB822724E7: "使用'%0'格式说明符，但参数具有布尔值"
# "using declaration annotated with 'using_if_exists' here"
HDB8ACBC0FBF5: "此处使用标注有'using_if_exists'的声明"
# 'using declaration cannot refer to a constructor'
HF62840A086D5: 'using声明不能引用构造函数'
# 'using declaration cannot refer to a destructor'
HE836ECBAB540: 'using声明不能引用析构函数'
# 'using declaration cannot refer to a namespace'
H0DDDFEE0D0FD: 'using声明不能引用命名空间'
# 'using declaration cannot refer to a template specialization'
H99346E56FD07: 'using声明不能引用模板特化'
# 'using declaration cannot refer to class member'
H667DB55E8D61: 'using声明不能引用类成员'
# 'using declaration in class refers into %0, which is not a class'
H703FE2D02B05: '类中的 using 声明引用到 %0，但该类型不是类'
# 'using declaration naming a scoped enumerator is a C++20 extension'
H5CF0B64CDA35: 'using声明引用作用域枚举是C++20扩展'
# 'using declaration naming a scoped enumerator is incompatible with C++ standards before C++20'
H52802307DDAC: 'using声明引用作用域枚举与C++20之前的标准不兼容'
# 'using declaration pack expansion at block scope produces multiple values'
HFC5BC61E58BC: '块作用域中的using声明包展开会产生多个值'
# 'using declaration referring to %1 with %select{internal|module|unknown}0 linkage cannot be exported'
HFDD1D0A3610E: '引用具有%select{内部|模块|未知}0链接的%1的using声明无法导出'
# "using declaration referring to inaccessible member '%0' (which refers to accessible member '%1') is a Microsoft compatibility extension"
HA7AB89787DCC: "引用不可访问成员'%0'（其指向可访问成员'%1'）是Microsoft兼容扩展"
# 'using declaration refers into %0, which is not a base class of %1'
HE8EC9FE5FD16: 'using 声明引用到 %0，但该类型不是 %1 的基类'
# 'using declaration refers to its own class'
H435B6D84F0D6: 'using声明引用其自身类'
# 'using declaration requires a qualified name'
H9CE75E7C4CF5: 'using声明需要限定名称'
# "using directive refers to implicitly-defined namespace 'std'"
H5C8831D062A8: 'using指令引用隐式定义的命名空间"std"'
# 'using enum %select{requires an enum or typedef name|does not permit an elaborated enum specifier}0'
H07DCC7345590: '使用枚举%select{需要枚举或typedef名称|不允许使用扩展的枚举说明符}0'
# 'using enum declaration is a C++20 extension'
H30E94CBBC49F: 'using enum声明是C++20扩展'
# 'using enum declaration is incompatible with C++ standards before C++20'
HA6B3DF063338: 'using enum声明与C++20之前的标准不兼容'
# "using length modifier '%0' with conversion specifier '%1' is not supported by ISO C"
HCAD96DA2A48D: "使用长度修饰符 '%0' 与转换说明符 '%1' 不受ISO C支持"
# 'using namespace directive in global context in header'
HDFF3F4F00DD3: '头文件全局作用域中使用using命名空间指令'
# "using sysroot for '%0' but targeting '%1'"
H23CBFE9436FA: "使用'%0'的sysroot，但目标平台是'%1'"
# 'using the result of an assignment as a condition without parentheses'
HD808A1E3A9FB: '将赋值表达式的结果用作条件时未使用括号'
# 'using the undeclared type %0 as a default template argument is a Microsoft extension'
H9BAAEE7535FA: '将未声明的类型%0作为默认模板参数是Microsoft扩展'
# 'using unversioned Android target directory %0 for target %1; unversioned directories will not be used in Clang 19 -- provide a versioned directory for the target version or lower instead'
H120D3110B47A: '为目标%1使用未版本化的Android目标目录%0；Clang 19将不再使用未版本化的目录——请为对应版本提供版本化的目录或使用更低版本'
# 'using-enum cannot name a dependent type'
H3DC57F2168E8: 'using-enum不能命名一个相关依赖类型'
# 'uuid attribute contains a malformed GUID'
H1FAF5254B686: 'uuid属性包含格式错误的GUID'
# 'uuid does not match previous declaration'
H1E8E115FA4D8: 'uuid与之前的声明不匹配'
# 'valid %0 clauses start with %1; %select{token|tokens}2 will be ignored'
HA977999237FF: '有效的%0子句以%1开头；%select{token|tokens}2将被忽略'
# 'valid target CPU values are: %0'
HB573A028A656: '有效的目标CPU值为：%0'
# 'value %0 is outside the range of representable values of type %1'
H76B206381D68: '值%0超出类型%1可表示的范围'
# 'value %1 cannot be represented in type %0'
H0FCCEC09B538: '值%1无法用类型%0表示'
# "value '%0' out of range for constraint '%1'"
H2964C78586A1: "值'%0'超出约束'%1'的范围"
# 'value is not an integer: %0'
HDF6724275715: '值不是整数：%0'
# 'value of #pragma pack(show) == %0'
H78F0B6172824: '#pragma pack(show)的值为%0'
# 'value of the aligned pointer (%0) is not a multiple of the asserted %1 %plural{1:byte|:bytes}1'
HCBC69FE1B218: '对齐指针的值(%0)不是声明的%1 %plural{1:byte|:bytes}1的倍数'
# "value of type %0 is not contextually convertible to 'bool'"
H8D6D08CCD77E: "类型%0的值无法上下文转换为'bool'"
# 'value of type %0 is not implicitly convertible to %1'
H7F07136EE80D: '类型%0的值无法隐式转换为%1'
# "value returned by '__builtin_counted_by_ref' cannot be %select{assigned to a variable|passed into a function|returned from a function}0"
H0D53FCA7346F: "由'__builtin_counted_by_ref'返回的值不能%select{被赋值给变量|被传递给函数|从函数返回}0"
# "value returned by '__builtin_counted_by_ref' cannot be used in %select{an array subscript|a binary}0 expression"
H4F263548602C: "'__builtin_counted_by_ref'返回的值不能用于%select{数组下标|二进制}0表达式"
# 'value size does not match register size specified by the constraint and modifier'
H45E5585EA0B2: '值大小与约束和修饰符指定的寄存器大小不匹配'
# 'varargs not allowed in requires expression'
H65BA20F3C0FC: 'requires表达式中不允许使用可变参数'
# "variable %0 cannot be declared both 'extern' and with the 'loader_uninitialized' attribute"
H66B3CD6187EF: "变量%0不能同时声明为'extern'和带有'loader_uninitialized'属性"
# 'variable %0 cannot be implicitly captured in a lambda with no capture-default specified'
H17BA614E3EF4: '在未指定捕获默认方式的lambda中不允许隐式捕获变量%0'
# 'variable %0 cannot be threadprivate because it is %select{thread-local|a global named register variable}1'
HF72C764C6D1B: '变量%0不能是线程私有变量，因为它%select{是线程局部变量|是命名寄存器全局变量}1'
# 'variable %0 declared with deduced type %1 cannot appear in its own initializer'
H9648530537F2: '具有推导类型%1的变量%0不能出现在自身的初始化器中'
# 'variable %0 is %select{decremented|incremented}1 both in the loop header and in the loop body'
H5880C36D679C: '变量 %0 在循环头和循环体中均被%select{递减|递增}1'
# "variable %0 is %select{used|captured}1 uninitialized whenever %select{'%3' condition is %select{true|false}4|'%3' loop %select{is entered|exits because its condition is false}4|'%3' loop %select{condition is true|exits because its condition is false}4|switch %3 is taken|its declaration is reached|%3 is called}2"
H5B3E786190C7: "当%select{'%3'条件%select{为真|为假}4|'%3'循环%select{被进入|因条件为假退出}4|'%3'循环%select{条件为真|因条件为假退出}4|switch %3 被选中|其声明被访问|%3 被调用}2时，变量 %0 在%select{使用|被捕获}1时未初始化"
# 'variable %0 is declared here'
H9C1D29CE922D: '变量%0在此处声明'
# 'variable %0 is uninitialized when %select{used here|captured by block}1'
HC11F7DAD1A0E: '变量%0在%select{此处使用时|被捕获到块中时}1时未初始化'
# 'variable %0 is uninitialized when passed as a const reference argument here'
H12F79B618200: '变量%0在作为常量引用参数传递时未初始化'
# 'variable %0 is uninitialized when used within its own initialization'
H9B3210B51205: '变量%0在自身初始化过程中使用时未初始化'
# 'variable %0 is%select{| explicitly}1 captured here'
HC5A87C36FF05: '变量%0%select{被显式|}1在此处捕获'
# 'variable %0 may be uninitialized when %select{used here|captured by block}1'
HC0A7D9F9078D: '变量%0可能在%select{此处使用时|被捕获到块中时}1时未初始化'
# 'variable %0 must have explicitly specified data sharing attributes'
H9EFAEC625413: '变量%0必须显式指定数据共享属性'
# 'variable %0 must have explicitly specified data sharing attributes, data mapping attributes, or in an is_device_ptr clause'
H577354E45CD4: '变量%0必须显式指定数据共享属性、数据映射属性，或出现在is_device_ptr子句中'
# 'variable %0 set but not used'
H9EEEA592434A: '变量%0被赋值但未使用'
# 'variable %0 with flexible array member cannot be captured in a lambda expression'
HEE231707A80F: '具有柔性数组成员的变量%0不能被捕获到lambda表达式中'
# 'variable %0 with type %1 has incompatible initializer of type %2'
HECE6754B3154: '类型为%1的变量%0具有类型%2的不兼容初始值'
# 'variable %0 with unknown type cannot be given a function type'
HBD6B0E34602F: '类型未知的变量%0不能被赋予函数类型'
# "variable %select{|in unary expression|on right hand side of assignment|on left hand side of assignment|on left hand side of compound assignment|on left hand side of assignment}2('%3') must match variable used %select{|in unary expression|on right hand side of assignment|<not possible>|on left hand side of compound assignment|on left hand side of assignment}0('%1') from the first statement"
H68D8E5C8B649: "在%select{|单目表达式中|赋值语句右侧|赋值语句左侧|复合赋值语句左侧|赋值语句左侧}2的变量'%3'必须与第一条语句中%select{|单目表达式使用的|赋值右侧使用的|<不可用>|复合赋值左侧使用的|赋值左侧使用的}0的变量'%1'保持一致"
# 'variable already marked as mapped in current construct'
HA15930719644: '变量已在当前上下文中被标记为映射'
# "variable appearing in '%0' clause of OpenACC 'declare' directive must be in the same scope as the directive"
H32CD6FB44C7B: "在OpenACC 'declare'指令的'%0'子句中出现的变量必须与指令处于同一作用域"
# "variable can appear only once in OpenMP '%0' clause"
H084B181F0F6F: "OpenMP '%0'子句中的变量只能出现一次"
# "variable can appear only once in OpenMP 'target update' construct"
H78D2AF4A7A62: "OpenMP 'target update'构造中的变量只能出现一次"
# 'variable captured in declare target region must appear in a to clause'
H2004C3E36B6D: '在declare target区域捕获的变量必须出现在to子句中'
# 'variable declaration in a constexpr %select{function|constructor}0 is a C++14 extension'
H953C3A7294B8: '在constexpr %select{函数|构造函数}0中的变量声明是C++14扩展'
# 'variable declaration in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
H5037F674FC7B: '在constexpr %select{函数|构造函数}0中的变量声明与C++14之前的版本不兼容'
# 'variable declaration in condition cannot have a parenthesized initializer'
HA7027EDD1E14: '条件中的变量声明不能带有括号初始化器'
# 'variable declaration in condition must have an initializer'
H031DEC12DA47: '条件中的变量声明必须具有初始化器'
# 'variable declaration in for loop is a C99-specific feature'
HCED2B7B23919: '在for循环中声明的变量是C99特有功能'
# 'variable declared constinit here'
HBD9CCEC96BCC: '此处声明的constinit变量'
# "variable declared with 'objc_externally_retained' cannot be modified in ARC"
H47C52BC3E77D: "'objc_externally_retained'声明的变量在ARC中不可修改"
# 'variable does not have a constant initializer'
HB267A973AA07: '变量没有常量初始化器'
# 'variable has incomplete type %0'
HF07B48579A53: '变量具有不完整类型%0'
# 'variable in constant address space must be initialized'
H66FDD0998C58: '常量地址空间中的变量必须被初始化'
# 'variable is not assignable (missing __block type specifier)'
HAA0B269B98F3: '变量不可分配（缺少__block类型说明符）'
# 'variable length array cannot be formed during template argument deduction'
HF26A880CF088: '模板参数推导期间无法形成变量长度数组'
# "variable length array declaration cannot have 'extern' linkage"
H2436B28C5991: "变量长度数组声明不能具有'extern'链接"
# "variable length array declaration cannot have 'static' storage duration"
H9C9D3E1402A9: "可变长数组声明不能具有 'static' 存储持续期"
# 'variable length array declaration not allowed at file scope'
H01CDB7349FFD: '在文件作用域中不允许声明可变长数组'
# 'variable length array folded to constant array as an extension'
H861F6896A4A9: '作为扩展，将可变长数组折叠为常量数组'
# 'variable length array must be bound in function definition'
HACDD33225FC5: '可变长数组必须在函数定义中确定大小'
# 'variable length array used'
HFCB17814F664: '使用了可变长数组'
# 'variable length arrays are a C99 feature'
H82A7E9913A2F: '可变长数组是C99特性'
# "variable length arrays are not supported %select{for the current target|in '%1'}0"
H5707BCACEAC8: '可变长数组%select{当前目标不支持|在"%1"中不支持}0'
# 'variable length arrays are not supported for the current target'
H50B2A4B545B7: '当前目标不支持可变长数组'
# 'variable length arrays are not supported in OpenCL'
H201996231D1A: 'OpenCL中不支持可变长数组'
# "variable length arrays are not supported in OpenMP tasking regions with 'untied' clause"
H20FB8AB94029: '在带有"untied"子句的OpenMP任务区域中不支持可变长数组'
# 'variable length arrays in C++ are a Clang extension'
HCD7C2CD01723: 'C++中的可变长数组是Clang扩展'
# "variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?"
H53E1EE683577: "C++中的可变长数组是Clang扩展；是否想使用'static_assert'？"
# 'variable length arrays in a coroutine are not supported'
HD279E72346CE: '协程中的可变长数组不被支持'
# 'variable must be of integer or %select{pointer|random access iterator}0 type'
H4F34EF5C94E2: '变量必须为整数或%select{指针|随机访问迭代器}0类型'
# "variable named 'main' with external linkage has undefined behavior"
H38BA25ED2BA1: "具有外部链接的名为'main'的变量具有未定义行为"
# 'variable of non-literal type %1 cannot be defined in a constexpr %select{function|constructor}0 before C++23'
H5F89C6201D7E: '非字面类型%1的变量在C++23之前不能在constexpr %select{函数|构造函数}0中定义'
# "variable of non-reference type %0 can be used only with 'val' modifier, but used with '%1'"
HFF57CDDBE63D: '非引用类型%0的变量只能与"val"修饰符一起使用，但实际使用了"%1"'
# 'variable of type %1 has %select{private|protected}2 destructor'
H8BC8C9632B1A: '类型%1的变量具有%select{private|protected}2访问权限的析构函数'
# "variable referenced by 'link' clause not in global or namespace scope must be marked 'extern'"
HF7968BA9CE92: "'link'子句引用的不在全局或命名空间作用域中的变量必须标记为'extern'"
# "variable referenced in '%0' clause of OpenACC 'declare' directive was already referenced"
H8FFABBD53A56: "在OpenACC 'declare'指令的'%0'子句中引用的变量已被先前引用过"
# 'variable template partial specialization %0 cannot be redefined'
HB5621CB8D5D4: '变量模板的部分特化%0不能被重新定义'
# 'variable templates are a C++14 extension'
H031A6133F773: '变量模板是C++14的扩展功能'
# 'variable templates are incompatible with C++ standards before C++14'
HC36BFC632A54: '变量模板与C++14之前的C++标准不兼容'
# "variable with 'loader_uninitialized' attribute cannot have an initializer"
H9908D11CFEF9: "具有'loader_uninitialized'属性的变量不能有初始化器"
# "variable with 'loader_uninitialized' attribute must have a trivial default constructor"
H30559420B01D: "具有'loader_uninitialized'属性的变量必须具有平凡的默认构造函数"
# 'variable with local storage in initial value of threadprivate variable'
H06BE1F004442: '线程私有变量的初始值中包含具有局部存储的变量'
# 'variable%select{s| %1|s %1 and %2|s %1, %2, and %3|s %1, %2, %3, and %4}0 used in loop condition not modified in loop body'
H78CB81888F63: '变量%select{s| %1|s %1和%2|s %1、%2和%3|s %1、%2、%3和%4}0在循环条件中使用，但在循环体内未被修改'
# 'variable-sized object may not be initialized'
HF22D786D9F31: '可变大小的对象不能被初始化'
# 'variables in function scope cannot be declared static'
H588D8DBF6957: '函数作用域内的变量不能声明为static'
# 'variables in the %0 address space can only be declared in the outermost scope of a kernel function'
H077534025BE2: '位于%0地址空间的变量只能在核函数的最外层作用域中声明'
# 'variably modified type %0 cannot be used as a template argument'
H43ADD4446C3D: '可变修改类型%0不能用作模板参数'
# "variably modified type declaration cannot have 'extern' linkage"
H31174A21A725: '可变修改类型的声明不能具有extern链接性'
# 'variably modified type declaration not allowed at file scope'
H0326E5892284: '不允许在文件作用域中声明可变修改类型'
# 'variably-modified type %0 cannot be used in a constexpr %select{function|constructor}1'
HA78DFABA86CF: '可变修改类型%0不能在constexpr %select{函数|构造函数}1中使用'
# "variadic 'friend' declarations are a C++2c extension"
H3D2FFF66A145: '可变参数的"friend"声明是C++2c的扩展'
# "variadic 'friend' declarations are incompatible with C++ standards before C++2c"
H365CB532BF3E: '可变参数的"friend"声明与C++2c之前的C++标准不兼容'
# 'variadic function cannot use %0 calling convention'
HEC894E082768: '可变参数函数不能使用%0调用约定'
# 'variadic macros are a C99 feature'
H6AA48F3D31FE: '可变参数宏是C99的特性'
# 'variadic macros are a Clang extension in OpenCL'
H1CAB7A29DC4C: '在OpenCL中，可变参数宏是Clang的扩展'
# 'variadic macros are incompatible with C++98'
H4BD20CD6A5E1: '可变参数宏与C++98不兼容'
# 'variadic templates are a C++11 extension'
H499FA3A280B8: '可变参数模板是C++11的扩展'
# 'variadic templates are incompatible with C++98'
H4B7B3608CF46: '可变参数模板与C++98不兼容'
# "variant function in '#pragma omp declare variant' is itself marked as '#pragma omp declare variant'"
H82A01F59E7E3: '在#pragma omp declare variant中声明的变体函数本身也被标记为#pragma omp declare variant'
# "variant in '#pragma omp declare variant' is the same as the base function"
HEC73C56687BA: '在#pragma omp declare variant中的变体与基函数类型相同'
# "variant in '#pragma omp declare variant' with type %0 is incompatible with type %1%select{| with appended arguments}2"
H443E0ACFD62A: '在#pragma omp declare variant中的变体类型%0与类型%1%select{|附加参数}2不兼容'
# 'vector component access exceeds type %0'
HA6E77B2F0A3C: '向量组件访问超过类型%0'
# 'vector component access has invalid length %0; supported lengths are: 1,2,3,4,8,16'
HCB71F9B8CFBC: '向量组件访问具有无效长度%0；支持的长度为：1,2,3,4,8,16'
# "vector component name '%0' is a feature from OpenCL version 3.0 onwards"
H6B53729D7A1D: "向量组件名称'%0'是OpenCL 3.0及更高版本中的特性"
# 'vector condition type %0 and result type %1 do not have elements of the same size'
H9FFA8360C1AF: '向量条件类型%0和结果类型%1的元素大小不一致'
# 'vector condition type %0 and result type %1 do not have the same number of elements'
H48693917C57D: '向量条件类型%0和结果类型%1的元素数量不一致'
# 'vector initializers are not compatible with NEON intrinsics in big endian mode'
H20E090504D21: '向量初始化器与大端模式下的NEON内在函数不兼容'
# 'vector is not assignable (contains duplicate components)'
HA13B723E09E4: '该向量不可分配（包含重复的组件）'
# 'vector operands do not have the same elements sizes (%0 and %1)'
H20CF2F14B1AB: '向量操作数的元素大小不一致（%0和%1）'
# 'vector operands do not have the same number of elements (%0 and %1)'
H02E2D0489C4C: '向量操作数的元素数量不一致（%0和%1）'
# 'vector operands to the vector conditional must be the same type %diff{($ and $)|}0,1}'
HBD47DE4A7313: '向量条件运算符的向量操作数必须是相同类型%diff{($和$)|}0,1}'
# 'vector size not an integral multiple of component size'
H77E12186A8E0: '向量大小不是组件大小的整数倍'
# "vectorize_width loop hint malformed; use vectorize_width(X, fixed) or vectorize_width(X, scalable) where X is an integer, or vectorize_width('fixed' or 'scalable')"
H52976DB4C3C0: "向量化宽度循环提示格式错误；请使用vectorize_width(X, fixed)或vectorize_width(X, scalable)，其中X为整数，或vectorize_width('fixed'或'scalable')"
# "vendor '%0' is not supported: '%1'"
HEF7F8EFDE1D2: "供应商'%0'不受支持：'%1'"
# "version '%0' in target triple '%1' is invalid"
H638A2A1C27BA: "目标三元组'%1'中的版本'%0'无效"
# 'version control conflict marker in file'
H58D6C666A33F: '文件中存在版本控制冲突标记'
# "version for '%0' already specified"
HD1955B4EAF6D: "版本号 '%0' 已经被指定"
# 'version list contains duplicate entries'
HDC1A5F99BC1B: '版本列表包含重复项'
# "version list contains entries that don't impact code generation"
H346B24B0B01F: '版本列表包含不影响代码生成的条目'
# 'version number must have non-zero major, minor, or sub-minor version'
H32D5C8ECFF2D: '版本号必须包含非零的主版本、次版本或修订版本'
# 'violations found for %0'
HC357EBB7E4D0: '在 %0 中发现违规'
# 'virtual base class declared here'
H2738AB0FED80: '虚基类在此处声明'
# 'virtual constexpr functions are incompatible with C++ standards before C++20'
H0CA73C06B6D5: '虚拟 constexpr 函数与 C++20 之前的语言标准不兼容'
# "virtual destructor requires an unambiguous, accessible 'operator delete'"
H23281750E023: "虚拟析构函数需要明确且可访问的 'operator delete'"
# "virtual filesystem overlay file '%0' not found"
H26F74FB8B8C2: "虚拟文件系统覆盖文件 '%0' 未找到"
# 'virtual function %0 has a different return type %diff{($) than the function it overrides (which has return type $)|than the function it overrides}1,2'
HD8B18D2DDADC: '虚函数 %0 的返回类型%diff{($) 与它覆盖的函数（其返回类型为 $）不同|与它覆盖的函数不同}1,2'
# 'virtual function %0 has different attributes %diff{($) than the function it overrides (which has $)|than the function it overrides}1,2'
H105CB368BBFA: '虚函数 %0 的属性%diff{($) 与它覆盖的函数（其属性为 $）不同|与它覆盖的函数不同}1,2'
# 'virtual function %0 has different calling convention attributes %diff{($) than the function it overrides (which has calling convention $)|than the function it overrides}1,2'
HB03FA37606B1: '虚函数 %0 的调用约定属性%diff{($) 与它覆盖的函数（其调用约定为 $）不同|与它覆盖的函数不同}1,2'
# 'virtual function %q0 has more than one final overrider in %1'
H80394FC58D1D: '虚函数 %q0 在 %1 中有多个最终覆盖者'
# 'virtual function cannot be constexpr'
H01635D482A33: '虚拟函数不能声明为 constexpr'
# 'virtual function cannot have a requires clause'
H138054D4510B: '虚拟函数不能带有 requires 子句'
# 'virtual functions are not supported in C++ for OpenCL'
H820F01CD9896: 'C++ 中的 OpenCL 不支持虚拟函数'
# 'virtual functions are unsupported in HLSL'
H207695B65E04: 'HLSL 不支持虚拟函数'
# 'virtual inheritance is unsupported in HLSL'
H8C2B278220B7: 'HLSL 不支持虚拟继承'
# "virtual method %0 is inside a 'final' class and can never be overridden"
HAC30D95A1570: "虚拟方法 %0 位于 'final' 类中且无法被重写"
# 'visibility does not match previous declaration'
H17040BB5EC03: '可见性与之前的声明不匹配'
# 'void %select{function|method|block}1 %0 should not return void expression'
HCA9EAB88160F: 'void %select{function|method|block}1 %0 不应返回 void 表达式'
# 'void block should not return a value'
H1C0762ECEC55: 'void block 不应返回值'
# 'volatile %select{temporary created|object declared|member declared}0 here'
HBA1E3AEA8BE2: 'volatile %select{临时创建的|声明的对象|声明的成员}0 此处'
# 'volatile qualifier in structured binding declaration is deprecated'
H8119BA6E8068: '在结构化绑定声明中使用 volatile 限定符已弃用'
# 'volatile-qualified parameter type %0 is deprecated'
H9F774F8B8E15: 'volatile 限定的参数类型 %0 已弃用'
# 'volatile-qualified return type %0 is deprecated'
H34762436C2FA: 'volatile 限定的返回类型 %0 已弃用'
# 'was searched for in the directory: %0'
H4B8949005850: '在目录中搜索过： %0'
# 'weak %select{variable|property|implicit property|instance variable}0 %1 is accessed multiple times in this %select{function|method|block|lambda}2 but may be unpredictably set to nil; assign to a strong variable to keep the object alive'
H7F2B64A607B2: '在该 %select{函数|方法|块|lambda}2 中多次访问 weak %select{变量|属性|隐式属性|实例变量}0 %1，但可能不可预测地被设为 nil；将其赋值给 strong 变量以保持对象存活'
# 'weak %select{variable|property|implicit property|instance variable}0 %1 may be accessed multiple times in this %select{function|method|block|lambda}2 and may be unpredictably set to nil; assign to a strong variable to keep the object alive'
H301C12832949: '在该 %select{函数|方法|块|lambda}2 中多次访问 weak %select{变量|属性|隐式属性|实例变量}0 %1，可能被不可预测地设为 nil；将其赋值给 strong 变量以保持对象存活'
# 'weak attribute declared on a __strong type property in GC mode'
H088D436307D2: '在GC模式下，对 __strong 类型属性声明了 weak 属性'
# 'weak declaration cannot have internal linkage'
HC1895405FFA7: 'weak 声明不能具有内部链接性'
# 'weak identifier %0 never declared'
H22A978739C8D: 'weak 标识符 %0 从未被声明'
# 'weakref declaration must have internal linkage'
H8016E3683340: 'weakref 声明必须具有内部链接性'
# 'weakref declaration of %0 must also have an alias attribute'
H101799E65B31: '%0 的 weakref 声明还必须具有别名属性'
# 'weakref declaration of %0 must be in a global context'
HDA1EB6DAD24A: '%0 的 weakref 声明必须处于全局上下文中'
# 'when applied to this declaration'
HA6DB04448955: '当应用于该声明时'
# 'when implemented by class %0'
H9F7ED2DB900A: '当由类 %0 实现时'
# "when looking up '%select{begin|end}0' function for range expression of type %1"
HC4C870329421: '在查找类型 %1 的范围表达式对应的 `%select{begin|end}0` 函数时'
# 'when type is in parentheses, array cannot have dynamic size'
HBDE59C8D782B: '当类型在括号中时，数组不能具有动态大小'
# 'which delegates to'
H90C5BED46FE0: '其委托给'
# 'while building implicit deduction guide first needed here'
HD4658CE20D59: '在构建隐式推导指南时首次需要此处'
# 'while calculating associated constraint of template %0 here'
HD4CBA036E98A: '在计算模板 %0 的关联约束时需要此处'
# 'while checking a default template argument used here'
H7E4F64D4A848: '在检查此处使用的默认模板参数时'
# "while checking constraint satisfaction for class template partial specialization '%0' required here"
H190F26B4DB43: "在检查类模板偏特化 '%0' 的约束满足要求时需要此处"
# "while checking constraint satisfaction for function '%0' required here"
H1A3A707B1D73: "在检查函数 '%0' 的约束满足要求时需要此处"
# "while checking constraint satisfaction for template '%0' required here"
H19BE8EB0741D: "在检查模板 '%0' 的约束满足要求时需要此处"
# "while checking constraint satisfaction for variable template partial specialization '%0' required here"
HD73CEE0E62DB: "在检查变量模板偏特化 '%0' 的约束满足要求时需要此处"
# "while checking implicit 'delete this' for virtual destructor"
H738DE49AA679: '在检查虚析构函数的隐式 "delete this" 时'
# "while checking the satisfaction of concept '%0' requested here"
HE2FF74B26A28: '在检查此处请求的概念 "%0" 的满足要求时'
# 'while checking the satisfaction of nested requirement requested here'
HE3D634694184: '在检查此处请求的嵌套要求满足时'
# "while declaring the corresponding implicit 'operator==' for this defaulted 'operator<=>'"
H332A7297AC58: '在为此默认的 "operator<=>" 声明对应的隐式 "operator==" 时'
# 'while declaring the implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 for %0'
HAC5877F575DC: '在为此 %0 声明隐式 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}1 时'
# 'while loop has empty body'
H374FEF617D4F: 'while loop 的空体'
# 'while loop outside of a function'
HAB96332E82A6: '函数外的 while 循环'
# "while rewriting comparison as call to 'operator<=>' declared here"
H9A478A9E2AA1: '在将比较重写为此处声明的 "operator<=>" 调用时'
# 'while substituting deduced template arguments into function template %0 %1'
H4E16912522F9: '在将推导出的模板参数代入函数模板 %0 %1 时'
# 'while substituting explicitly-specified template arguments into function template %0 %1'
H862C7E7129FA: '在将显式指定的模板参数代入函数模板 %0 %1 时'
# 'while substituting into a lambda expression here'
H154EA9F3EDC1: '在将此处的 lambda 表达式代入时'
# 'while substituting into concept arguments here; substitution failures not allowed in concept arguments'
HAC706623FF86: '在将概念参数此处代入时；概念参数不允许替换失败'
# 'while substituting prior template arguments into %select{non-type|template}0 template parameter%1 %2'
HF0EDCF82D09D: '在将先前模板参数代入 %select{非类型|模板}0 模板参数%1 %2 时'
# 'while substituting template arguments into constraint expression here'
H19C71987DC07: '在替换模板参数到此处的约束表达式时'
# 'whitespace is not allowed in parameter passing direction'
H82BD58AB277F: '参数传递方向中不允许有空白字符'
# 'whitespace recommended after macro name'
H47F8347E0371: '建议在宏名后添加空白字符'
# 'whitespace required after macro name'
H2F43B2E26F3A: '必须在宏名后添加空白字符'
# 'widen this field to %0 bits to store all values of %1'
HD1698255B212: '将此字段的宽度扩展为%0位以存储%1的所有值'
# 'width of bit-field %0 (%1 bits) exceeds the width of its type; value will be truncated to %2 bit%s2'
H8896C13CC6D9: '位字段 %0 (%1 位) 的宽度超过其类型宽度；值将被截断至 %2 bit%s2'
# 'width of%select{ anonymous|}0 bit-field%select{| %1}0 (%2 bits) exceeds the %select{width|size}3 of its type (%4 bit%s4)'
H02B50746D7D1: '位字段%select{匿名|}0 的宽度%select{| %1}0 (%2 位) 超过其类型的%select{宽度|大小}3 (%4 bit%s4)'
# 'within field of type %0 declared here'
HEC6FDC220283: '在类型%0的字段中，该字段在此处声明'
# 'writable atomic property %0 cannot pair a synthesized %select{getter|setter}1 with a user defined %select{getter|setter}2'
HA65A16D8E26B: '可写原子属性%0不能将合成的%select{getter|setter}1与用户定义的%select{getter|setter}2配对'
# 'wrong argument format for hlsl attribute, use %0 instead'
H514518256D51: 'HLSL属性的参数格式错误，应使用%0'
# 'wrong fpu width; %select{LSX|LASX}0 depends on 64-bit FPU'
H65FC5C473561: 'FPU宽度错误；%select{LSX|LASX}0依赖于64位FPU'
# "you need to include <typeinfo> before using the 'typeid' operator"
H64B8C0D4E612: "在使用'typeid'运算符前需要包含<typeinfo>"
# 'z/OS target level "%0" is discontinued'
HB5BA348592D3: 'z/OS目标级别"%0"已弃用'
# 'z/OS target level "%0" is invalid'
H0080755EFA11: 'z/OS目标级别"%0"无效'
# 'zero %0 size'
HF7816CFF7955: '零%0大小'
# 'zero as null pointer constant'
H824A61FB1C48: '使用零作为空指针常量'
# 'zero field width in scanf format string is unused'
H122ACCFBBD62: 'scanf格式字符串中的零字段宽度未被使用'
# 'zero linear step (%0 %select{|and other variables in clause }1should probably be const)'
HDA0E059C273A: '零线性步长（%0 %select{|和子句中的其他变量}1应声明为const）'
# 'zero size arrays are an extension'
H49512BBF0CE4: '零长度数组是扩展特性'
# "zero-length array section is not allowed in 'depend' clause"
HC5FAF4CE6159: "零长度数组部分在'depend'子句中不允许"
# 'zero-length arrays are not permitted in %select{C++|SYCL device code|HIP device code}0'
H2F083F032372: '零长度数组在%select{C++|SYCL device code|HIP device code}0中不允许使用'
